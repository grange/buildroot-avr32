diff -Nwrup -x.git fltk-1.1.9/configh.in FLTK_1.x-DirectFB/configh.in
--- fltk-1.1.9/configh.in	2007-02-08 15:14:30.000000000 -0500
+++ FLTK_1.x-DirectFB/configh.in	2009-11-28 15:48:05.869153408 -0500
@@ -131,6 +131,15 @@
 #undef __APPLE_QD__
 
 /*
+ * DIRECTFB:
+ * 
+ * All drawing function use DirectFB library.
+ *
+ */
+ 
+#define DIRECTFB 0
+
+/*
  * HAVE_OVERLAY:
  *
  * Use the X overlay extension?  FLTK will try to use an overlay
diff -Nwrup -x.git fltk-1.1.9/configure FLTK_1.x-DirectFB/configure
--- fltk-1.1.9/configure	2008-04-27 04:28:21.000000000 -0400
+++ FLTK_1.x-DirectFB/configure	2009-11-28 15:48:05.872152486 -0500
@@ -1316,6 +1316,7 @@ Optional Features:
   --enable-FEATURE[=ARG]  include FEATURE [ARG=yes]
   --enable-cygwin         use the CygWin libraries default=no
   --enable-debug          turn on debugging default=no
+  --enable-directfb       turn on DirectFB support default=no
   --enable-gl             turn on OpenGL support default=yes
   --enable-shared         turn on shared libraries default=no
   --enable-threads        enable multi-threading support
@@ -1859,6 +1860,12 @@ else
     DEBUGFLAG=""
 fi
 
+# Check whether --enable-directfb was given.
+if test "${enable_directfb+set}" = set; then
+  enableval=$enable_directfb;
+fi
+
+
 # Check whether --enable-gl was given.
 if test "${enable_gl+set}" = set; then
   enableval=$enable_gl;
@@ -9217,6 +9224,17 @@ _ACEOF
 	    THREADS="threads"
 	fi
 
+	if test x$enable_directfb == xyes; then
+	    cat >>confdefs.h <<\_ACEOF
+#define DIRECTFB 1
+_ACEOF
+
+	    cat >>confdefs.h <<\_ACEOF
+#define USE_COLORMAP 0
+_ACEOF
+
+	    LIBS="$LIBS -ldirect -ldirectfb -lfusion $X_EXTRA_LIBS"
+	else
 		{ echo "$as_me:$LINENO: checking for X" >&5
 echo $ECHO_N "checking for X... $ECHO_C" >&6; }
 
@@ -10544,6 +10562,7 @@ echo "$as_me: WARNING: Ignoring librarie
 	fi
 
 	LIBS="$LIBS -lXext -lX11 $X_EXTRA_LIBS"
+	fi
 	CFLAGS="$CFLAGS $X_CFLAGS"
 	CXXFLAGS="$CXXFLAGS $X_CFLAGS"
 	LDFLAGS="$X_LIBS $LDFLAGS"
@@ -12001,6 +12020,9 @@ case $uname in
 	fi
         ;;
     *)
+	if test x$enable_directfb = xyes; then
+	    graphics="DirectFB"
+	else
         graphics="X11"
 	if test x$enable_xft = xyes; then
 	    graphics="$graphics+Xft"
@@ -12011,6 +12033,7 @@ case $uname in
 	if test x$enable_xinerama = xyes; then
 	    graphics="$graphics+Xinerama"
 	fi
+	fi
         ;;
 esac
 
diff -Nwrup -x.git fltk-1.1.9/configure.in FLTK_1.x-DirectFB/configure.in
--- fltk-1.1.9/configure.in	2008-04-11 12:53:01.000000000 -0400
+++ FLTK_1.x-DirectFB/configure.in	2009-11-28 15:48:05.873159527 -0500
@@ -117,6 +117,8 @@ else
     DEBUGFLAG=""
 fi
 
+AC_ARG_ENABLE(directfb, [  --enable-directfb       turn on DirectFB support [default=no]])
+
 AC_ARG_ENABLE(gl, [  --enable-gl             turn on OpenGL support [default=yes]])
 
 AC_ARG_ENABLE(shared, [  --enable-shared         turn on shared libraries [default=no]])
@@ -696,6 +698,11 @@ case $uname in
 	    THREADS="threads"
 	fi
 
+	if test x$enable_directfb == xyes; then
+	    AC_DEFINE(DIRECTFB,1)
+	    AC_DEFINE(USE_COLORMAP,0)
+	    LIBS="$LIBS -ldirect -ldirectfb -lfusion $X_EXTRA_LIBS"
+	else
 	dnl Check for X11...
 	AC_PATH_XTRA
 
@@ -708,6 +715,7 @@ case $uname in
 	fi
 
 	LIBS="$LIBS -lXext -lX11 $X_EXTRA_LIBS"
+	fi
 	CFLAGS="$CFLAGS $X_CFLAGS"
 	CXXFLAGS="$CXXFLAGS $X_CFLAGS"
 	LDFLAGS="$X_LIBS $LDFLAGS"
@@ -1091,6 +1099,9 @@ case $uname in
 	fi
         ;;
     *)
+	if test x$enable_directfb = xyes; then
+	    graphics="DirectFB"
+	else
         graphics="X11"
 	if test x$enable_xft = xyes; then
 	    graphics="$graphics+Xft"
@@ -1101,6 +1112,7 @@ case $uname in
 	if test x$enable_xinerama = xyes; then
 	    graphics="$graphics+Xinerama"
 	fi
+	fi
         ;;
 esac
 
diff -Nwrup -x.git fltk-1.1.9/FL/DirectFB.H FLTK_1.x-DirectFB/FL/DirectFB.H
--- fltk-1.1.9/FL/DirectFB.H	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/FL/DirectFB.H	2009-11-28 15:48:05.842154085 -0500
@@ -0,0 +1,667 @@
+//
+// "$Id: DirectFB.H,v 1.3 2006-10-31 09:31:14 nikego Exp $"
+//
+// DirectFB header file for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+
+// Do not directly include this file, instead use <FL/x.H>.  It will
+// include this file if DIRECTFB is defined.  This is to encourage
+// portability of even the system-specific code...
+
+#ifndef Fl_X_H
+#  error "Never use <DirectFB.H> directly; include <FL/x.H> instead."
+#endif // !Fl_X_H
+
+#include <config.h>
+
+// to make debug version uncomment the next line
+//#define DEBUG 1
+
+#ifdef DEBUG
+// to enable DirectFB's debug tracing
+# define  DIRECT_ENABLE_DEBUG (1)
+#endif 
+
+#include <directfb.h>
+#include <directfb_version.h>
+#include <FL/xutils.h>
+
+// In some of the distributions, the gcc header files are missing some stuff:
+#ifndef LPMINMAXINFO
+#define LPMINMAXINFO MINMAXINFO*
+#endif
+#ifndef VK_LWIN
+#define VK_LWIN 0x5B
+#define VK_RWIN 0x5C
+#define VK_APPS 0x5D
+#endif
+
+#include <stdio.h>
+
+// This is the super interface, it's the entry point to all functionality.
+extern IDirectFB*               fl_dfb; 
+extern IDirectFBDisplayLayer*   fl_display_layer;
+extern GC                       fl_screen; //The primary surface, i.e. the "screen".
+
+void print_last_dump();
+
+#ifdef DEBUG 
+
+#define DFBCHECK(x...)\
+  {\
+    DFBResult err = x;\
+    if (err != DFB_OK){\
+        fprintf( stderr, "Error '%s' occured in %s <%d>:\n\t", DirectFBErrorString(err), __FILE__, __LINE__ );\
+        fprintf( stderr, #x );\
+        print_last_dump();\
+       /* DirectFBErrorFatal( #x, err );*/\
+      }\
+  }
+  
+#else
+
+    #define DFBCHECK(x...) x
+    
+#endif
+  
+/******************************************************/
+/*   DirectFB's  assist functions                     */
+/******************************************************/
+
+static inline int
+get_caps( GC gc ){
+  DFBSurfaceCapabilities ret_caps = DSCAPS_NONE;
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->GetCapabilities(gc->surface, &ret_caps));
+  return ret_caps;
+}   
+
+static inline int
+get_pixel_format(GC gc){
+  DFBSurfacePixelFormat pixel_format = DSPF_UNKNOWN;
+  if (gc && gc->surface)
+    gc->surface->GetPixelFormat(gc->surface, &pixel_format);
+  return (int)pixel_format;
+}
+
+static inline void
+get_size(GC gc, int* width, int* height ){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->GetSize(gc->surface, width, height));
+}
+
+static inline void
+get_visible_rectangle( GC gc, DFBRectangle* rect ){
+  if (gc && gc->surface)
+    DFBCHECK( gc->surface->GetVisibleRectangle( gc->surface, rect ) );
+}
+
+// summary
+static inline int
+get_surface_description(GC gc, DFBSurfaceDescription* desc){
+  if (gc && gc->surface) {
+    desc->flags     = (DFBSurfaceDescriptionFlags)(DSDESC_CAPS|DSDESC_WIDTH|DSDESC_HEIGHT|DSDESC_PIXELFORMAT);    
+    desc->caps      = (DFBSurfaceCapabilities)get_caps( gc ); 
+    get_size( gc, &desc->width , &desc->height );
+    desc->pixelformat = (DFBSurfacePixelFormat)get_pixel_format( gc );
+    return DFB_OK;
+  }
+  return DFB_INVARG;
+}
+    
+static inline void
+get_palette(GC gc, IDirectFBPalette** pal){
+  if (gc && gc->surface)
+    DFBCHECK( gc->surface->GetPalette( gc->surface, pal ) );
+}
+
+static inline void* 
+lock_surface(GC gc, int flags, int *ret_pitch){
+  void* buffer = 0;
+  if (gc && gc->surface)
+    if (DFB_OK == gc->surface->Lock(gc->surface, (DFBSurfaceLockFlags)flags,\
+      &buffer, ret_pitch))
+      return buffer;
+  return 0;   
+}
+
+static inline void 
+unlock_surface(GC gc){
+  if (gc && gc->surface)
+    gc->surface->Unlock( gc->surface ); 
+}
+
+static inline void
+flip_gc(GC gc, DFBRegion *region, int flags){
+    DFBCHECK(gc->surface->Flip( gc->surface, region,( DFBSurfaceFlipFlags)flags ) );
+}
+    
+static inline void
+clear_gc(GC gc, uchar red, uchar green, uchar blue, uchar alpha){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->Clear(gc->surface, red, green, blue, alpha));
+}
+    
+static inline int
+set_clip(GC gc, DFBRegion* reg){
+  if (gc && gc->surface){
+    if( reg ){
+      DFBRegion r = *reg;
+      if (r.x2) r.x2--;
+      if (r.y2) r.y2--;
+      return gc->surface->SetClip( gc->surface, &r );
+    }else
+      return gc->surface->SetClip( gc->surface, reg );
+  }
+  return DFB_INVARG;
+}
+
+static inline int
+get_clip(GC gc, DFBRegion* reg){
+  if (gc && gc->surface)
+    if (reg){
+      return gc->surface->GetClip(gc->surface, reg);
+    }
+  return DFB_INVARG;
+}
+
+inline void
+set_drawing_flags(GC gc, int flags){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->SetDrawingFlags(gc->surface, (DFBSurfaceDrawingFlags)flags));
+}
+
+static inline void
+set_src_blend_function( GC gc, int func ){
+  if (gc && gc->surface)
+   gc->surface->SetSrcBlendFunction( gc->surface, (DFBSurfaceBlendFunction) func );
+}
+
+static inline void
+set_dst_blend_function( GC gc, int func ){
+  if (gc && gc->surface)
+   gc->surface->SetDstBlendFunction( gc->surface, (DFBSurfaceBlendFunction) func );
+}
+
+static inline void
+set_porter_duff(GC gc, int rule){
+  if (gc && gc->surface)
+    gc->surface->SetPorterDuff( gc->surface, (DFBSurfacePorterDuffRule)rule );
+}
+
+static inline void
+set_blitting_flags(GC gc, int flags){
+    DFBCHECK( gc->surface->SetBlittingFlags(gc->surface, (DFBSurfaceBlittingFlags)flags ) );
+}
+
+static inline void
+blit(GC dest,GC src, DFBRectangle* rect, int x , int y){
+  if (src && dest && dest->surface && src->surface)
+    DFBCHECK(dest->surface->Blit(dest->surface,src->surface, rect, x, y));
+}
+    
+static inline void
+set_surface_font(GC gc, IDirectFBFont* font){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->SetFont(gc->surface, font));  
+}
+
+static inline IDirectFBFont* 
+get_surface_font(GC gc){
+    IDirectFBFont* ret_font = 0;
+    if (gc && gc->surface)
+      gc->surface->GetFont(gc->surface, &ret_font);
+    return ret_font;
+}
+
+static inline int
+set_color(GC gc, u8 _r,u8 _g,u8 _b,u8 _a){
+  if (gc && gc->surface)
+  {
+    gc->r = _r;
+    gc->g = _g;
+    gc->b = _b;
+    gc->a = _a;
+    DFBCHECK( gc->surface->SetColor( gc->surface,_r,_g,_b,_a ) );
+  }
+  return 0;
+}
+
+/*static inline int
+set_color(GC gc, u8 _color){
+  if (gc && gc->surface)
+    DFBCHECK( gc->surface->SetColorIndex(gc->surface, _color));
+  return 0;
+}*/  
+
+static inline int
+set_src_color_key(GC gc, u8 _color){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->SetSrcColorKeyIndex(gc->surface, _color));
+  return 0;
+}
+
+static inline int
+set_src_color_key(GC gc, u8 r, u8 g, u8 b){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->SetSrcColorKey( gc->surface, r, g, b));
+  return 0;
+}
+
+static inline int
+set_dst_color_key( GC gc, u8 _color ){
+    DFBCHECK(gc->surface->SetDstColorKeyIndex(gc->surface, _color ));
+    return 0;
+}
+
+static inline int
+set_dst_color_key(GC gc, u8 r, u8 g , u8 b ){
+  if (gc && gc->surface)
+    DFBCHECK(gc->surface->SetDstColorKey(gc->surface, r, g, b));
+  return 0;
+}
+
+void
+draw_lines(GC gc, Region reg, int n );
+
+void
+draw_string(GC gc, const char* str, int n,  int x, int y, DFBSurfaceTextFlags flags );
+
+void
+get_string_width(IDirectFBFont *font, const char* s, int n, int * width);
+
+int
+set_clip_mask(Pixmap mask);
+
+/*********************************************************************
+ * window's functions
+ * */
+
+static inline DFBWindowID
+get_id( IDirectFBWindow* window ){
+    DFBWindowID ret_id;
+    if ( window && ( DFB_OK == window->GetID( window, &ret_id ) ) )
+        return ret_id;
+    return 0;   
+}
+
+static inline void
+set_opacity(IDirectFBWindow* window, int opacity){
+  if (window)
+	DFBCHECK( window->SetOpacity( window, opacity ) );
+}
+
+static inline int
+get_opacity(IDirectFBWindow* window){
+  uchar ret_op;
+  if (window)
+    DFBCHECK(window->GetOpacity(window, &ret_op));
+  return ret_op;
+}
+
+static inline void
+get_size(IDirectFBWindow* window, int* width, int* height){
+  if (window)
+    DFBCHECK(window->GetSize(window, width, height));
+}
+
+static inline void
+resize( IDirectFBWindow* window, int width, int height){
+  if (window)
+    DFBCHECK(window->ResizeSurface(window, width, height));
+}
+
+static inline void
+get_position(IDirectFBWindow* window,int* x, int* y){
+  if (window)
+    DFBCHECK(window->GetPosition(window, x, y));
+}
+
+static inline void
+set_cursor_shape(IDirectFBDisplayLayer* layer, GC cursor, int hot_x, int hot_y){
+  if (layer)
+    DFBCHECK(layer->SetCursorShape(layer, cursor ? cursor->surface : 0, hot_x, hot_y));
+}
+
+static inline void
+raise_to_top(IDirectFBWindow* window){
+  if (window)
+    DFBCHECK(window->RaiseToTop(window));
+}
+
+
+/**********************************************************************/	
+
+static inline void
+wait_for_event_with_timeout(IDirectFBEventBuffer* buffer, unsigned sec, unsigned msec){
+  if (buffer)
+	DFBCHECK( buffer->WaitForEventWithTimeout( buffer, sec, msec ) );
+}
+
+static inline void
+set_cursor_opacity(IDirectFBDisplayLayer* layer, int opacity){
+  if (layer)
+	DFBCHECK(layer->SetCursorOpacity(layer, opacity));
+}
+
+static inline void
+get_cursor_position(IDirectFBDisplayLayer* layer, int* xx, int* yy){
+  if (layer)
+    DFBCHECK( layer->GetCursorPosition( layer, xx, yy ) );
+}
+
+GC
+create_gc(const DFBSurfaceDescription* desc);
+
+GC 
+create_gc(IDirectFBWindow* window);
+
+GC
+create_gc(GC parent_gc, const DFBRectangle* rect);
+
+GC
+create_gc(int caps, int flags, int pixelformat, int width, int height);
+
+IDirectFBWindow* 
+create_window(const DFBWindowDescription* desc);
+
+IDirectFBWindow* 
+get_window( DFBWindowID xid );
+
+static inline void
+grab_pointer(IDirectFBWindow* window){
+  if (window)
+    DFBCHECK( window->GrabPointer( window ) );
+}
+
+static inline void
+ungrab_pointer(IDirectFBWindow* window){
+  if (window)
+    DFBCHECK(window->UngrabPointer(window));
+}
+
+static inline void
+set_win_cursor_shape(IDirectFBWindow* win, GC cursor, int hot_x, int hot_y){
+  if (win)
+    DFBCHECK(win->SetCursorShape(win, cursor ? cursor->surface : 0, hot_x, hot_y));
+}
+
+
+static inline void
+set_options(IDirectFBWindow* window, int opts){
+  if (window)
+    DFBCHECK(window->SetOptions(window, (DFBWindowOptions)opts));
+}
+
+static inline int
+create_font(const char*	filename, const DFBFontDescription*	desc, IDirectFBFont** ret_interface){
+  if (fl_dfb)
+    fl_dfb->CreateFont(fl_dfb, filename, desc, ret_interface);
+  return 0;   
+}
+
+static inline int
+get_font_height( IDirectFBFont* font ){
+    int height=0;
+    if (font && ( DFB_OK == font->GetHeight(font, &height)))
+        return height;
+    return 0;   
+}
+    
+static inline int
+get_font_descender( IDirectFBFont* font ){
+    int descender=0;
+    if( font && ( DFB_OK == font->GetDescender( font, &descender ) ) )
+        return -descender;
+    return 0;   
+}
+
+static inline int
+get_surface_description( IDirectFBImageProvider* image_provider, DFBSurfaceDescription* desc ){
+  if (image_provider) 
+	image_provider->GetSurfaceDescription( image_provider, desc );	
+  return DFB_OK;
+}
+
+static inline IDirectFBImageProvider*
+create_image_provider(const char *name){
+  IDirectFBImageProvider *image_provider;
+  if (fl_dfb && (DFB_OK == fl_dfb->CreateImageProvider(fl_dfb, name, &image_provider)) )
+    return image_provider;
+  return 0;
+}
+	
+static inline void
+render_to( IDirectFBImageProvider *image_provider, GC gc, DFBRectangle* rect ){
+  if (image_provider)
+	image_provider->RenderTo( image_provider, gc->surface, rect );
+}
+
+static inline void 
+release( IDirectFBSurface* s ){
+  if (s && fl_dfb)
+    s->Release( s );
+} 
+
+static inline void 
+release( IDirectFBWindow *w ){
+  if (w && fl_dfb)
+    w->Release( w );
+} 
+
+static inline void 
+release( IDirectFBInputDevice* d ){
+  if (d && fl_dfb)
+    d->Release( d );
+} 
+
+extern void print_gc_list();
+extern void free_gc_list();
+extern void fl_free_cursors();
+extern void _fl_show_cursor(int);
+
+#define fl_display    fl_display_layer
+#define xdisplay      fl_display_layer
+#define Fl_Region     Region
+#define display_layer fl_display_layer
+
+static inline int 
+pixel_format(){
+  extern u32 pixf_;
+  return pixf_;
+}
+
+static inline bool
+have_lut(){
+  extern bool lut_;
+  return lut_;
+}
+
+int fl_init_dfb(int argc, char **argv);
+
+FL_EXPORT void fl_clip_region(Fl_Region);
+
+#include "Fl_Window.H"
+// this object contains all directfb-specific stuff about a window:
+// Warning: this object is highly subject to change!
+FL_EXPORT void fl_open_display();
+FL_EXPORT void fl_open_display(Display*);
+FL_EXPORT void fl_close_display();
+
+extern VisualInfo               visual_info;
+extern FL_EXPORT dfbWindow      fl_message_window;
+extern FL_EXPORT VisualInfo*    fl_visual;
+extern FL_EXPORT Colormap 	    fl_colormap;
+extern FL_EXPORT Surface        fl_gc;
+extern FL_EXPORT Window         fl_window;
+extern FL_EXPORT IDirectFBFont* fl_xfont;
+
+extern FL_EXPORT ulong      fl_xpixel(Fl_Color i);
+extern FL_EXPORT ulong      fl_xpixel(uchar r, uchar g, uchar b);
+extern FL_EXPORT void       fl_clip_region(Fl_Region);
+extern FL_EXPORT Fl_Region  fl_clip_region();
+
+// feed events into fltk:
+FL_EXPORT int fl_handle(const DFBWindowEvent&);
+
+// you can use these in Fl::add_handler() to look at events:
+//extern FL_EXPORT const DFBWindowEvent* fl_xevent;
+extern FL_EXPORT ulong fl_event_time;
+	
+// flip a rectangle of screen 
+FL_EXPORT void fl_flip( GC surf, int x, int y, int w, int h );
+FL_EXPORT void fl_flip( int x, int y, int w, int h );
+FL_EXPORT void fl_flip( GC surf, Region r );
+
+/*******************************************************/
+// off-screen pixmaps: create, destroy, draw into, copy to window:
+
+typedef Pixmap Fl_Offscreen;
+
+Fl_Offscreen fl_create_offscreen(int w,int h);
+Fl_Offscreen fl_create_offscreen_argb(int w,int h);//with alpha mask
+
+void fl_delete_offscreen(Fl_Offscreen);
+
+// begin/end are functions that save the old state in global variables:
+
+void fl_begin_offscreen(Fl_Offscreen);
+void fl_end_offscreen();
+void fl_copy_offscreen(int _x,int _y,int _w,int _h,Fl_Offscreen offscreen,int srcx,int srcy);
+void fl_copy_offscreen_bk(int _x,int _y,int _w,int _h,Fl_Offscreen offscreen,int srcx,int srcy,ulong bkcolor );
+//void fl_copy_offscreen_with_mask(int _x, int _y, int _w, int _h, void* offscreen, int srcx, int srcy, void* mask );
+void fl_draw_abgr_to_argb(const uchar* array, int x, int y, int w, int h);
+
+
+#if 0 //FIXME SetDstColorKeyIndex is not working !
+	extern int _dstcol_Blit( GC,GC,DFBRectangle*, int,int,int );
+#   define __Blit( s ,i, r, x ,y, c ) _dstcol_Blit( s ,i, r, x ,y, c )
+#else
+#   define __Blit( s ,i, r, x ,y, c ) _Blit( s ,i, r, x ,y )
+#endif
+
+GC 
+fl_load_image( const char *infname, int& w, int& h, GC* mask );
+
+uchar*
+fl_load_image( const char *infname, int& w, int& h, int& d );
+
+int 
+BitBlit( GC dest, int dest_x, int dest_y, int width, int height,GC src, int src_x,int src_y );
+
+/*************************************************************************************/
+/* Bitmap masks   */
+
+typedef Fl_Offscreen Fl_Bitmask;
+
+extern FL_EXPORT Fl_Bitmask fl_create_bitmask(int w, int h, const uchar *data);
+extern FL_EXPORT Fl_Bitmask fl_create_alphamask(int w, int h, int d, int ld, const uchar *data);
+extern FL_EXPORT void fl_delete_bitmask(Fl_Bitmask bm);
+
+#define CHILD_ID 0x8000 
+
+/*************************************************************************************/
+// this object contains all X-specific stuff about a window:
+// Warning: this object is highly subject to change!  It's definition
+// is only here so that fl_xid can be declared inline:
+class FL_EXPORT Fl_X {
+public:
+  	XID         xid;
+  	dfbWindow  _xid;
+  	Fl_Window*  w;
+  	Fl_Region   region;
+  	GC          gc;    //client's context
+  	GC          win_gc;//window's context
+
+  	char        wait_for_expose;
+  	char        backbuffer_bad; // used for XDBE
+  
+  	static Fl_X* first;
+  	Fl_X *next;
+  	static Fl_X* i(const Fl_Window* wi) {return wi->i;}
+/*------------------------------------------------------------------------*/  
+  	void setwindow( Fl_Window* wi ) {w=wi; wi->i=this;}
+  	void sendxjunk();
+  	static Fl_X* make_xid(Fl_Window*);
+  	static Fl_X* set_xid(Fl_Window*, dfbWindow);
+   	char first_draw;//FIXME it's a flag to show the window after first drawing
+	// kludges to get around protection:  	
+  	void flush(); 
+  	static void x(Fl_Window* wi, int X) {wi->x(X);}
+  	static void y(Fl_Window* wi, int Y) {wi->y(Y);}
+   	static void release();
+   	
+   	Fl_Window *header;
+   	void draw_window_frame();
+   	void enter_window(bool);
+   	void set_gc(int W=-1,int H=-1);
+   	DFBRectangle origin_size;
+   	int minimize_;
+   	int maximize(){return origin_size.w!=0;};
+   	void set_maximize();
+   	int minimize(){return minimize_;}
+   	void delete_icon();
+   	void set_minimize();
+	void restore_size(int X=-1,int Y=-1,int W=-1,int H=-1);
+	short minw,minh,maxw,maxh,dw,dh;
+    Cursor cursors[2];
+};
+
+//compatibitily with FLTK2
+#define CreatedWindow Fl_X
+
+// convert xid <-> Fl_Window:
+/*static inline WindowID fl_wnd(const Fl_Window* w){
+    return Fl_X::i(w)->_xid;
+}*/
+static inline Window fl_xid(const Fl_Window* w){
+    return Fl_X::i(w)->xid;
+}
+
+FL_EXPORT Fl_Window* fl_find( Window xid );
+FL_EXPORT Fl_Window* fl_find( dfbWindow _xid );
+
+Fl_X *get_parent_xid( Fl_Widget* w );
+
+void delete_icon( Fl_Window* win );
+
+extern FL_EXPORT char fl_override_redirect; // hack into Fl_X::make_xid()
+extern FL_EXPORT int fl_background_pixel;  // hack into Fl_X::make_xid()
+
+// Dummy function to register a function for opening files via the window manager...
+static inline void fl_open_callback(void (*)(const char *)) {
+}
+
+extern FL_EXPORT int fl_parse_color(const char* p, uchar& r, uchar& g, uchar& b);
+extern FL_EXPORT void fl_free_dfbfonts();
+
+void fl_deinit_dfb(void);
+
+#if USE_COLORMAP
+void init_xcolormap();
+#endif
+
+//
+// End of "$Id: DirectFB.H,v 1.3 2006-10-31 09:31:14 nikego Exp $".
+//
diff -Nwrup -x.git fltk-1.1.9/FL/Fl_GIF_Image.H FLTK_1.x-DirectFB/FL/Fl_GIF_Image.H
--- fltk-1.1.9/FL/Fl_GIF_Image.H	2005-04-15 20:13:17.000000000 -0400
+++ FLTK_1.x-DirectFB/FL/Fl_GIF_Image.H	2009-11-28 15:48:05.845154140 -0500
@@ -1,5 +1,5 @@
 //
-// "$Id: Fl_GIF_Image.H 4288 2005-04-16 00:13:17Z mike $"
+// "$Id: Fl_GIF_Image.H,v 1.1 2006-04-06 14:01:27 nikego Exp $"
 //
 // GIF image header file for the Fast Light Tool Kit (FLTK).
 //
@@ -28,8 +28,15 @@
 #ifndef Fl_GIF_Image_H
 #define Fl_GIF_Image_H
 #  include "Fl_Pixmap.H"
+#include <config.h>  
 
-class FL_EXPORT Fl_GIF_Image : public Fl_Pixmap {
+class FL_EXPORT Fl_GIF_Image : public 
+#ifndef DIRECTFB
+	Fl_Pixmap
+#else
+	Fl_RGB_Image
+#endif	
+	{
 
   public:
 
@@ -39,5 +46,5 @@ class FL_EXPORT Fl_GIF_Image : public Fl
 #endif
 
 //
-// End of "$Id: Fl_GIF_Image.H 4288 2005-04-16 00:13:17Z mike $".
+// End of "$Id: Fl_GIF_Image.H,v 1.1 2006-04-06 14:01:27 nikego Exp $".
 //
diff -Nwrup -x.git fltk-1.1.9/FL/fltk_dfb_ex.h FLTK_1.x-DirectFB/FL/fltk_dfb_ex.h
--- fltk-1.1.9/FL/fltk_dfb_ex.h	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/FL/fltk_dfb_ex.h	2009-11-28 15:48:05.853153701 -0500
@@ -0,0 +1,129 @@
+#ifndef __FLTK_DFB_EX_H__
+#define __FLTK_DFB_EX_H__ 
+
+/************************************************************************
+ * External FLTK`s functions which available in DirectFB`s version of the library only.
+*/
+
+/* create offscreen compatible with primary surface */
+extern void* fl_create_offscreen(int w,int h);
+
+/* create ARGB offscreen*/
+extern void* fl_create_offscreen_rgb(int w,int h);
+
+/* delete offscreen*/
+extern void fl_delete_offscreen(void* surface);
+
+/* set offscreen as current drawing surface*/
+extern void fl_begin_offscreen(void* surface );
+
+/* restore old drawing surface*/
+extern void fl_end_offscreen();
+
+/* copy from offscreen to current surface*/
+extern void fl_copy_offscreen(int _x,int _y,int _w,int _h,void* offscreen,int srcx,int srcy);
+
+/* bkcolor color is excluded when copying */
+extern void fl_copy_offscreen_bk(int _x,int _y,int _w,int _h,void* offscreen,int srcx,int srcy,ulong bkcolor);
+
+/* 
+ *  filter and smooth functions. 
+ *  They draw good-looking image especially if your display has low resolution ( e.c.640x480 ).
+ */
+ 
+/* available masks for filtering  
+ * 
+ * 1 - 2 X 2		 1 1
+ * 					 1 1  
+ * 
+ * 2 - 3 X 3        1 1 1 
+ *                  1 1 1 
+ *                  1 1 1
+ *
+ * 3 - 3 X 3        1 1 1
+ *                  1 2 1
+ *                  1 1 1 
+ * 
+ * 4 - 3 X 3        1 2 1
+ *                  2 4 2
+ *                  1 2 1 
+ * 
+ * 5 - 3 X 3        0 2 0
+ *                  2 4 2
+ *                  0 2 0
+ * 
+ * 6 - 4 X 4       1 1 1 1 
+ *                 1 1 1 1
+ *                 1 1 1 1 
+ *                 1 1 1 1
+ * 
+ * 7 - 7 X 7   1 2  3  4  3 2 1 
+ *             2 4  6  8  6 4 2 
+ *             3 6  9 12  9 6 5
+ *             4 8 12 16 12 8 4 
+ *             3 6  9 12  9 6 5 
+ *             2 4  6  8  6 4 2 
+ *             1 2  3  4  3 2 1
+ */
+/* filter offscreen rectangle using mask */
+extern void fl_filter_offscreen(void* offscreen,int x,int y,int w,int h,int mask);
+
+/* filter widget's rectangle*/
+extern void fl_filter_widget(Fl_Widget *wdg, int mask ); 
+
+/* draw a smooth line */
+extern void fl_line(double x1, double y1, double x2, double y2);
+
+/* draw a smooth edge. 
+ * The egde is a line having only one smooth side ( left hand side ). */
+extern void fl_edge(double x1, double y1, double x2, double y2);
+
+/* start drawing smooth lines */
+extern void fl_begin_smooth_line();
+
+/* start drawing a closed sequence of smooth lines*/
+extern void fl_begin_smooth_loop();
+
+/*
+ *  start drawing of polygon with smooth edges
+ *  list the points in clockwise direction
+ 1         2
+  *--->-----* 
+  |######### \
+  |########## \
+  ^########### V
+  |############ \
+  |############# \
+  *-------<-------* 
+ 0                 3
+*/
+extern void fl_begin_smooth_polygon();
+
+/* set and get a mask which be used after fl_draw() function*/
+extern void set_text_smooth(int);
+extern int get_text_smooth();
+
+/* hide/show the cursor*/
+extern void fl_show_cursor(int);
+
+
+/*******************************************************************
+ *   it's an example of using of smooth drawing 
+ *   Fl_Smooth_Clock class declaration
+ *   
+ */
+
+#include <FL/Fl_Clock.H>
+
+class Fl_Smooth_Clock: public Fl_Clock{
+public: 
+    Fl_Smooth_Clock(int x,int y,int w,int h, const char *l = 0):Fl_Clock(x,y,w,h,l){};    
+protected:    
+    void drawsmhands(Fl_Color fill, Fl_Color line);
+    virtual void draw();
+    void draw(int X, int Y, int W, int H); 
+};
+
+
+/****************************************************************************/
+#endif
diff -Nwrup -x.git fltk-1.1.9/FL/Makefile FLTK_1.x-DirectFB/FL/Makefile
--- fltk-1.1.9/FL/Makefile	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/FL/Makefile	2009-11-28 15:48:05.852153755 -0500
@@ -0,0 +1,63 @@
+#
+# "$Id: Makefile.in 5745 2007-03-15 13:27:41Z mike $"
+#
+# Header makefile for the Fast Light Tool Kit (FLTK).
+#
+# Copyright 1998-2007 by Bill Spitzak and others.
+#
+# This library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Library General Public
+# License as published by the Free Software Foundation; either
+# version 2 of the License, or (at your option) any later version.
+#
+# This library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Library General Public License for more details.
+#
+# You should have received a copy of the GNU Library General Public
+# License along with this library; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+# USA.
+#
+# Please report all bugs and problems on the following page:
+#
+#      http://www.fltk.org/str.php
+#
+
+include ../makeinclude
+
+all:
+
+clean:
+
+depend:
+
+install:
+	echo "Installing include files in $(DESTDIR)$(includedir)..."
+	$(RMDIR) $(DESTDIR)$(includedir)/FL
+	$(INSTALL_DIR) $(DESTDIR)$(includedir)/FL
+	for file in *.[hrH]; do \
+		$(INSTALL_DATA) $$file $(DESTDIR)$(includedir)/FL; \
+	done
+	cd $(DESTDIR)$(includedir)/FL;\
+	for file in *.H; do\
+		$(RM) "`basename $$file H`h";\
+		$(LN) $$file "`basename $$file H`h";\
+	done
+	$(RM) $(DESTDIR)$(includedir)/FL/fl_file_chooser.H
+	$(LN) Fl_File_Chooser.H $(DESTDIR)$(includedir)/FL/fl_file_chooser.H
+	$(RM) $(DESTDIR)$(includedir)/FL/fl_file_chooser.h
+	$(LN) Fl_File_Chooser.H $(DESTDIR)$(includedir)/FL/fl_file_chooser.h
+	$(RM) $(DESTDIR)$(includedir)/Fl
+	$(LN) FL $(DESTDIR)$(includedir)/Fl
+
+uninstall:
+	echo "Uninstalling include files..."
+	$(RMDIR) $(DESTDIR)$(includedir)/FL
+	$(RM) $(DESTDIR)$(includedir)/Fl
+
+
+#
+# End of "$Id: Makefile.in 5745 2007-03-15 13:27:41Z mike $".
+#
diff -Nwrup -x.git fltk-1.1.9/FL/x.H FLTK_1.x-DirectFB/FL/x.H
--- fltk-1.1.9/FL/x.H	2006-07-18 07:23:20.000000000 -0400
+++ FLTK_1.x-DirectFB/FL/x.H	2009-11-28 15:48:05.855154687 -0500
@@ -33,12 +33,16 @@
 #ifndef Fl_X_H
 #  define Fl_X_H
 
+#include <config.h>
+
 #  include "Enumerations.H"
 
 #  ifdef WIN32
 #    include "win32.H"
 #  elif defined(__APPLE__)
 #    include "mac.H"
+#  elif defined(DIRECTFB)
+#	include "DirectFB.H"
 #  else
 #    if defined(_ABIN32) || defined(_ABI64) // fix for broken SGI Irix X .h files
 #      pragma set woff 3322
@@ -142,7 +146,6 @@ extern FL_EXPORT int fl_parse_color(cons
 
 #  endif
 #endif
-
 //
 // End of "$Id: x.H 5262 2006-07-18 11:23:20Z matt $".
 //
diff -Nwrup -x.git fltk-1.1.9/FL/xutils.h FLTK_1.x-DirectFB/FL/xutils.h
--- fltk-1.1.9/FL/xutils.h	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/FL/xutils.h	2009-11-28 15:48:05.856153881 -0500
@@ -0,0 +1,963 @@
+//
+// "$Id xutils.h 4563 2006-03-06 23:03:34Z  $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// Written by Nikita Egorov (NikeGo@gmail.com) 
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+
+#ifndef _XUTILS_H_
+#define _XUTILS_H_ 
+
+#include <stdio.h> 
+#include <malloc.h>
+#include <directfb.h>
+#include <directfb_strings.h>
+#include <directfb_util.h>
+
+#include "Enumerations.H"
+
+#define Success		   0	/* everything's okay */
+
+#if USE_ALLOCA
+/* alloca() is available, so use it for better performance */
+#define ALLOCA(size)    alloca(size)
+#define FREEA(pmem)
+#else
+/* no alloca(), so use malloc()/free() instead */
+#define ALLOCA(size)    Xmalloc(size)
+#define FREEA(pmem) Xfree(pmem)
+#endif
+
+/* malloc stuff */
+#if MALLOC_0_RETURNS_NULL
+/* for machines that do not return a valid pointer for malloc(0)*/
+# define Xmalloc(size) malloc(((size) == 0 ? 1 : (size)))
+# define Xrealloc(ptr, size) realloc((ptr), ((size) == 0 ? 1 : (size)))
+# define Xcalloc(nelem, elsize) calloc(((nelem) == 0 ? 1 : (nelem)), (elsize))
+#else
+# define Xmalloc(size) malloc((size))
+# define Xrealloc(ptr, size) realloc((ptr), (size))
+# define Xcalloc(nelem, elsize) calloc((nelem), (elsize))
+#endif
+
+#define Xfree(ptr) free((ptr))
+
+#define swap(a,b) do { a ^= b; b ^= a; a ^= b; } while (0)
+
+typedef struct surface_context {
+  IDirectFBSurface* surface;
+  DFBUpdates        updates;
+  surface_context*  clip_mask;
+  DFBRegion         clip_region;
+  struct {            
+    u8 r,g,b,a;       // current color
+  };
+  struct {
+    u32 dashmask;     // An actual bitmask of the dash values
+    u32 dashcount;    // The number of bits defined in the dashmask
+    u32 bit;          // current bit
+ };
+}*GC,*Surface;
+
+typedef uintptr_t               XID;
+typedef XID                     Window;
+typedef XID                     Drawable;
+typedef XID                     Pixmap;
+typedef DFBPoint                XPoint;
+typedef DFBPoint                POINT;
+
+typedef DFBRectangle            RECT;
+typedef DFBRectangle            XRectangle;
+typedef DFBRegion*              Region;
+typedef IDirectFBFont*          XFont;
+typedef IDirectFBWindow*        dfbWindow;
+
+typedef ulong                   Colormap;
+typedef IDirectFBDisplayLayer   Display;
+
+typedef XID                     KeySym;
+
+// try to convert xid into a pointer
+#define ISGC(xid) ((xid)&~0xFFFF)?(GC)(xid):0
+
+#define PIXMAP(surf) (Pixmap)(surf)
+
+GC find_gc(XID xid);
+
+typedef struct POINT_f {
+    double x;
+    double y;
+} POINT_f_t;
+
+/* outline and filled arc and pie types*/
+#define ARC         0x0001  /* arc*/
+#define OUTLINE     0x0002
+#define ARCOUTLINE  0x0003  /* arc + outline*/
+#define PIE         0x0004  /* pie (filled)*/
+#define ELLIPSE     0x0008  /* ellipse outline*/
+#define ELLIPSEFILL 0x0010  /* ellipse filled*/
+
+/* set polygon fill routine*/
+#define EDGEPOLYFILL    1   /* edge table, malloc, qsort*/
+#define HAVEFLOAT       1
+
+/* Fill mode  */
+#define FILL_SOLID          0
+#define FILL_STIPPLE        1
+#define FILL_OPAQUE_STIPPLE 2
+#define FILL_TILE           3
+
+#define MIN(a,b)      ((a) < (b) ? (a) : (b))
+#define MAX(a,b)      ((a) > (b) ? (a) : (b))
+
+#if 1
+#  define MEMORY_TYPE DSCAPS_VIDEOONLY
+#else
+#  define MEMORY_TYPE DSCAPS_SYSTEMONLY
+#endif
+
+void release_gc(GC gc);
+void release_window(dfbWindow win);
+
+#define __tolower(a) (((a) >= 'A' && ((a) <= 'Z') ? ((a)+('a'-'A')):(a)))
+#define __toupper(a) (((a) >= 'a' && ((a) <= 'z') ? ((a)-('a'-'A')):(a)))
+
+/*
+ * Where to find fonts...
+ */
+ 
+#define X11_FONT_DIR1 "/usr/fonts/truetype"
+#define X11_FONT_DIR2 "/usr/X11R6/lib/X11/fonts/TrueType"
+
+#define X11_RGBTXT "/usr/X11R6/lib/X11/rgb.txt"
+
+/* Changeable options*/
+#define USE_ALLOCA		1	/* set if system has alloca()*/
+#define MALLOC_0_RETURNS_NULL	0	/* not yet needed*/
+
+/* required settings*/
+#define NeedFunctionPrototypes	1	/* ANSI C*/
+#define XLIB_ILLEGAL_ACCESS	1	/* define real structures*/
+
+/* deal with _Xconst differences in X11 header files*/
+#ifndef XCONST
+#define XCONST	_Xconst
+#endif
+
+
+#define None 0 
+
+/*
+ * cursor structure for DirectFB
+ */
+
+typedef struct _cursor {
+	Pixmap shape;
+	int hot_x;
+	int hot_y;
+    Pixmap source;
+    Pixmap mask;
+}*Cursor;
+
+/* Display classes  used in opening the connection 
+ * Note that the statically allocated ones are even numbered and the
+ * dynamically changeable ones are odd numbered */
+
+#define StaticGray  0
+#define GrayScale   1
+#define StaticColor 2
+#define PseudoColor 3
+#define TrueColor   4
+#define DirectColor 5
+
+#define LSBFirst		0
+#define MSBFirst		1
+
+/*
+ * Visual structure; contains information about colormapping possible.
+ */
+typedef struct {
+	void *ext_data;	/* hook for extension to hang data */
+	int visualid;	  /* visual id of this visual */
+	int c_class;	  /* C++ class of screen (monochrome, etc.) */
+	unsigned long red_mask, green_mask, blue_mask;	/* mask values */
+	int bits_per_rgb;	/* log base 2 of distinct color values */
+	int map_entries;	/* color map entries */
+} Visual;
+
+/*
+ * Information used by the visual utility routines to find desired visual
+ * type from the many visuals a display may support.
+ */
+typedef struct {
+  Visual *visual;
+  int visualid;
+  int screen;
+  int depth;
+  int c_class;					/* C++ */
+  unsigned long red_mask;
+  unsigned long green_mask;
+  unsigned long blue_mask;
+  int colormap_size;
+  int bits_per_rgb;
+  int byte_order;
+///////////
+  int bits_per_pixel;
+  int bytes_per_pixel;
+} VisualInfo;
+
+
+#define Status int 
+#define _Xconst const
+
+
+// create compatible surface system memory only;
+GC create_mem_gc( int w ,int h, int pf = -1 );
+Pixmap create_pixmap( int w ,int h, int pf = -1 );
+
+/*defines for unmodified (Xrm) Xlib routines...*/
+/*#define LockDisplay(dpy)
+#define UnlockDisplay(dpy)
+#define _XLockMutex(lock)
+#define _XUnlockMutex(lock)
+#define _XCreateMutex(lock)
+#define _XFreeMutex(lock)
+*/
+/* ImageFormat -- PutImage, GetImage */
+
+#define XYBitmap		0	/* depth 1, XYFormat */
+#define XYPixmap		1	/* depth == drawable depth */
+#define ZPixmap			2	/* depth == drawable depth */
+
+/*
+ * Data structure for retrieving info about pixmap formats.
+ */
+typedef struct {
+    int depth;
+    int bits_per_pixel;
+    int scanline_pad;
+} XPixmapFormatValues;
+
+/*
+ * Data structure for "image" data, used by image manipulation routines.
+ */
+typedef struct _XImage {
+    int width, height;		/* size of image */
+    int xoffset;		/* number of pixels offset in X direction */
+    int format;			/* XYBitmap, XYPixmap, ZPixmap */
+    char *data;			/* pointer to image data */
+    int byte_order;		/* data byte order, LSBFirst, MSBFirst */
+    int bitmap_unit;		/* quant. of scanline 8, 16, 32 */
+    int bitmap_bit_order;	/* LSBFirst, MSBFirst */
+    int bitmap_pad;		/* 8, 16, 32 either XY or ZPixmap */
+    int depth;			/* depth of image */
+    int bytes_per_line;		/* accelarator to next line */
+    int bits_per_pixel;		/* bits per pixel (ZPixmap) */
+    unsigned long red_mask;	/* bits in z arrangment */
+    unsigned long green_mask;
+    unsigned long blue_mask;
+  //  XPointer obdata;		/* hook for the object routines to hang on */
+    struct funcs {		/* image manipulation routines */
+#if  1 //NeedFunctionPrototypes
+	struct _XImage *(*create_image)(
+		Display* /* display */,
+		Visual*		/* visual */,
+		unsigned int	/* depth */,
+		int		/* format */,
+		int		/* offset */,
+		char*		/* data */,
+		unsigned int	/* width */,
+		unsigned int	/* height */,
+		int		/* bitmap_pad */,
+		int		/* bytes_per_line */);
+	int (*destroy_image)        (struct _XImage *);
+	unsigned long (*get_pixel)  (struct _XImage *,unsigned int, unsigned int);
+	int (*put_pixel)            (struct _XImage *,unsigned int, unsigned int, unsigned long);
+	struct _XImage *(*sub_image)(struct _XImage *,unsigned int, unsigned int, unsigned int, unsigned int);
+	int (*add_pixel)            (struct _XImage *, long);
+#else
+	struct _XImage *(*create_image)();
+	int (*destroy_image)();
+	unsigned long (*get_pixel)();
+	int (*put_pixel)();
+	struct _XImage *(*sub_image)();
+	int (*add_pixel)();
+#endif
+	} f;
+} XImage;
+
+/*
+ *  stubs..
+ */ 
+
+char* XKeysymToString(KeySym keysym);
+
+int XBell(Display *display, int percent);
+
+int XMapWindow(Display* display, Window w);
+
+int XMapRaised(Display* display, Window w);
+
+int XUnmapWindow(Display* display, Window w);
+
+char* XGetDefault(Display* display, _Xconst char* program, _Xconst char*);
+
+#define RootWindow( d, s )     fl_window
+#define DefaultRootWindow( d ) fl_window
+#define AllPlanes              ((unsigned long)~0L)
+
+int XQueryKeymap(Display* d, char s[32]);
+
+int XFlush(Display* display);
+
+int XKeysymToKeycode(Display* d, KeySym ks);
+
+/* Return values from XRectInRegion() */
+
+#define RectangleOut 0
+#define RectangleIn  1
+#define RectanglePart 2
+
+/*
+ * Bitmask returned by XParseGeometry().  Each bit tells if the corresponding
+ * value (x, y, width, height) was found in the parsed string.
+ */
+#define NoValue     0x0000
+#define XValue      0x0001
+#define YValue      0x0002
+#define WidthValue  0x0004
+#define HeightValue 0x0008
+#define AllValues   0x000F
+#define XNegative   0x0010
+#define YNegative   0x0020
+
+#define AllocNone   0 /* create map with no entries */
+#define AllocAll    1 /* allocate entire map writeable */
+
+
+/*
+ * Data structure used by color operations
+ */
+typedef struct {
+	long pixel;
+	unsigned short red, green, blue;
+	unsigned short alpha;
+	char flags;  /* do_red, do_green, do_blue */
+	char pad;
+} XColor;
+
+/* Used internally for the colormap */
+
+#define GR_PIXELVAL int
+#define GR_COLOR int
+
+typedef struct  {
+	GR_PIXELVAL     value;
+	int             ref;
+	unsigned short  r, g, b;
+} nxColorval;
+
+typedef struct _nxColormap {
+	int id;
+	int color_alloc;
+	int cur_color;
+	int saved_color;
+	DFBColor colors[256];
+	nxColorval *colorval;
+	struct _nxColormap *next;
+} nxColormap;
+
+extern Pixmap clip_mask;
+/*
+ * 
+ *  Region and rectange functions
+ * 
+ */
+int 
+XCopyArea(Display *display,Drawable src,Drawable dest,GC gc,
+    int src_x,int src_y,unsigned width,unsigned height,int dest_x,int dest_y);
+
+Region XRectangleRegion(int x, int y, int w, int h);
+
+Region XCreateRegion();
+
+int XDestroyRegion(Region r);
+
+int XRectInRegion(Region r,int x,int y,int w,int h);
+
+void XClipBox(Region r, XRectangle* rect);
+
+void XSetRegion(Display* display, GC gc, Region r, int set_clip=1);
+
+void XSetClipMask(Display* display, GC gc, Pixmap pixmap);
+
+int XIntersectRegion(Region r1, Region r2, Region newReg);
+
+int XSetClipOrigin(Display* display, GC gc, int clip_x_origin, int clip_y_origin);
+
+int XUnionRectWithRegion(XRectangle* rect, Region source, Region dest);
+
+int XUnionRectWithRegion( int x,int y,int w,int h, Region source, Region dest);
+
+int XParseGeometry(const char *parsestring, int *x, int *y, unsigned int *w, unsigned int *h);
+
+Status XParseColor(Display *display, Colormap colormap, const char *spec, XColor *exact_def_return);
+
+/*********************************************/
+void flip_updates( GC );
+
+void remove_updates( GC );
+
+void update_region( GC surface, DFBRegion* r );
+
+void update_region(GC surface,int x1,int y1,int x2,int y2);
+
+#define update_rect(s,x,y,w,h)\
+    update_region((s),DFB_REGION_VALS_FROM_RECTANGLE_VALS((x),(y),(w),(h)));
+
+/*********************************************/
+extern int gr_fillmode;
+
+void XDrawLine(Display* display,Drawable d,GC gc,int x1,int y1,int x2,int y2);
+
+void XDrawLines(Display* display,Drawable d,GC gc,Region points,int npoints,int mode);
+
+void XDrawRectangle(Display* display,Drawable d,GC gc,int x,int y,int width,int height);
+
+void XFillRectangle(Display* display,Drawable d,GC gc,int x,int y,int width,int height);
+
+#define draw_line_i(x1,y1,x2,y2)\
+  XDrawLine(fl_display,fl_window,fl_gc, (int)(x1+.5),(int)(y1+.5),(int)(x2+.5),(int)(y2+.5))
+
+#define draw_line_r(x1,y1,x2,y2)\
+  draw_smooth_line(fl_gc,x1,y1,x2,y2)
+
+void FillPoly(Drawable d,GC gc,int count, POINT_f *pointtable );
+
+void Arc(GC gc, short x0, short y0, short rx, short ry,    short ax, short ay, short bx, short by, int type);
+
+void ArcAngle(GC gc, int x,int y,int w,int h,double a1,double a2, int type );
+
+#ifdef SMOOTH_DRAWING
+/* experimental stuff */
+
+void SmoothPoly(GC gc, int count, POINT_f *pointtable);
+
+void draw_smooth_line(GC gc, double x1, double y1, double x2, double y2);
+
+void fl_filter_offscreen(GC offscreen, int x, int y, int w, int h, int );
+
+void drawrow(GC gc,int x1,int x2,int y);
+
+#endif /* SMOOTH_DRAWING */
+
+void set_dash_style(GC ctx, u32 mask, u32 count);
+
+void SetDashStyle( unsigned long mask);
+
+int SetClipRect (int x, int y, int w, int h);
+
+int SetClipRect (DFBRegion* r);
+
+/* _colormap.cxx*/
+nxColormap *_nxFindColormap(Colormap id);
+
+Colormap _nxDefaultColormap(Display* display);
+
+Colormap XCreateColormap(Display * display, Window w, Visual * visual, int alloc);
+
+inline Colormap XCreateColormap(Display *display ){
+  return XCreateColormap( display , 0, 0, 0 );
+}
+
+GR_COLOR GrGetColorByName(char *colorname, int *retr, int *retg, int *retb);
+
+int get_rgb_color( int xcolor, uchar& r, uchar& g, uchar& b );
+
+int get_index_color(uchar r,uchar g,uchar b);
+
+int XAllocColor( Display* display, Colormap colormap, XColor* in_out);
+
+int XQueryColor( Display* display, Colormap colormap, XColor * def);
+
+int XQueryColors( Display* display, Colormap colormap, XColor * def_in,int ncolors);
+
+int XFreeColors( Display* display, Colormap colormap, unsigned long pixels[],int npixels, unsigned long planes);
+
+int XFlushColormap( Display* display, Colormap colormap );
+
+void _nxPixel2RGB(Display* display, unsigned long color,
+  unsigned short *red, unsigned short *green, unsigned short *blue);
+
+/* _listfonts.cxx */
+extern char **_nxfontlist;
+
+extern int _nxfontcount;
+
+FILE* _nxLoadFontDir(char *str);
+
+void _nxSetDefaultFontDir(void);
+
+void _nxSetFontDir(char **directories, int ndirs);
+
+char** _nxGetFontDir(int *count);
+
+void _nxFreeFontDir(char **list);
+
+/* _loadfont.cxx*/
+char* _nxFindX11Font(const char *in_font);
+
+/*  */
+char** XListFonts( Display* display, const char *pattern, int maxnames, int *actual_count_return);
+
+XFont XLoadFont( Display* display, const char *fname );
+
+void XDestroyWindow( Display* display , Window window );
+
+int XFreeFont( Display* d, XFont font);
+
+int XFreeFontNames(char **list);
+
+int XIconifyWindow(Display* d, Window w, void* v);
+
+/*
+ *  image functions 
+ */
+int XPutImage(Display* display, Drawable d, GC gc, XImage * image,
+    int src_x, int src_y, int dest_x, int dest_y, unsigned int width,
+    unsigned int height);
+
+XImage* XCreateImage(Display* display, Visual* visual, unsigned int depth,
+    int format, int offset, char *data, unsigned int width,
+    unsigned int height, int bitmap_pad, int bytes_per_line);
+
+XImage* XGetImage(Display* display, Drawable d, int x, int y,
+    unsigned int width, unsigned int height,
+    unsigned long plane_mask, int format);
+
+int XDestroyImage(XImage *image);
+
+Pixmap XCreateBitmapFromData(Display* display, Drawable d, const char *data,
+    unsigned int width, unsigned int height);
+
+/* 
+ * cursors 
+ */
+
+void XFreeCursor( Display* display, Cursor xc );
+
+inline void XFreePixmap(Display* display, Pixmap p )
+{
+  if (ISGC(p))
+    release_gc( (GC)p );
+}
+
+int XSetForeground(Display* display, GC gc, int color_index);
+
+void XDefineCursor(Display* display, Window win, Cursor c);
+
+Cursor XCreatePixmapCursor( Display* display, Pixmap p, Pixmap m, XColor *col1, XColor *col2, unsigned hot_x, unsigned hot_y );
+
+Cursor XCreateFontCursor(Display *display, unsigned int shape);
+
+int XRecolorCursor(Display* display, Cursor cursor, XColor *fg_col, XColor *bg_col);
+
+/********************************************************************************/
+
+/*static inline int
+__sleep(int mssec){
+    struct timespec rqtp,rmtp;
+    rqtp.tv_sec  = mssec / 1000;
+    rqtp.tv_nsec = mssec * 1000000;
+    nanosleep(&rqtp, &rmtp);
+    return rmtp.tv_sec * 1000 + rmtp.tv_nsec / 1000000;
+}*/
+
+static const DirectFBPixelFormatNames(format_names);
+
+static inline const char* pixelformat_name( int format ) {
+    int i;
+    for (i=0; format_names[i].format != DSPF_UNKNOWN; i++) {
+        if (format_names[i].format == (DFBSurfacePixelFormat)format)
+        return format_names[i].name;
+  }
+  return "INVALID FORMAT";
+}
+
+void dump_surf_data(GC surf, int x, int y, int w, int h);
+
+/***************************************************************** 
+ * EVENT DEFINITIONS 
+ *****************************************************************/
+
+/* Input Event Masks. Used as event-mask window attribute and as arguments
+   to Grab requests.  Not to be confused with event names.  */
+
+#define NoEventMask              0L
+#define KeyPressMask            (1L<<0)
+#define KeyReleaseMask          (1L<<1)
+#define ButtonPressMask         (1L<<2)
+#define ButtonReleaseMask       (1L<<3)
+#define EnterWindowMask         (1L<<4)
+#define LeaveWindowMask         (1L<<5)
+#define PointerMotionMask       (1L<<6)
+#define PointerMotionHintMask   (1L<<7)
+#define Button1MotionMask       (1L<<8)
+#define Button2MotionMask       (1L<<9)
+#define Button3MotionMask       (1L<<10)
+#define Button4MotionMask       (1L<<11)
+#define Button5MotionMask       (1L<<12)
+#define ButtonMotionMask        (1L<<13)
+#define KeymapStateMask         (1L<<14)
+#define ExposureMask            (1L<<15)
+#define VisibilityChangeMask    (1L<<16)
+#define StructureNotifyMask     (1L<<17)
+#define ResizeRedirectMask      (1L<<18)
+#define SubstructureNotifyMask  (1L<<19)
+#define SubstructureRedirectMask (1L<<20)
+#define FocusChangeMask         (1L<<21)
+#define PropertyChangeMask      (1L<<22)
+#define ColormapChangeMask      (1L<<23)
+#define OwnerGrabButtonMask     (1L<<24)
+
+/* Event names.  Used in "type" field in XEvent structures.  Not to be
+confused with event masks above.  They start from 2 because 0 and 1
+are reserved in the protocol for errors and replies. */
+
+#define KeyPress         2
+#define KeyRelease       3
+#define ButtonPress      4
+#define ButtonRelease    5
+#define MotionNotify     6
+#define EnterNotify      7
+#define LeaveNotify      8
+#define FocusIn          9
+#define FocusOut         10
+#define KeymapNotify     11
+#define Expose           12
+#define GraphicsExpose   13
+#define NoExpose         14
+#define VisibilityNotify 15
+#define CreateNotify     16
+#define DestroyNotify    17
+#define UnmapNotify      18
+#define MapNotify        19
+#define MapRequest       20
+#define ReparentNotify   21
+#define ConfigureNotify  22
+#define ConfigureRequest 23
+#define GravityNotify    24
+#define ResizeRequest    25
+#define CirculateNotify  26
+#define CirculateRequest 27
+#define PropertyNotify   28
+#define SelectionClear   29
+#define SelectionRequest 30
+#define SelectionNotify  31
+#define ColormapNotify   32
+#define ClientMessage    33
+#define MappingNotify    34
+#define LASTEvent        35  /* must be bigger than any event # */
+
+/*
+ * Definitions of specific events.
+ */
+#if 0
+typedef struct {
+    int type;       /* of event */
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;   /* Display the event was read from */
+    Window window;          /* "event" window it is reported relative to */
+    Window root;            /* root window that the event occurred on */
+    Window subwindow;   /* child window */
+    Time time;      /* milliseconds */
+    int x, y;       /* pointer x, y coordinates in event window */
+    int x_root, y_root; /* coordinates relative to root */
+    unsigned int state; /* key or button mask */
+    unsigned int keycode;   /* detail */
+    Bool same_screen;   /* same screen flag */
+} XKeyEvent;
+
+typedef XKeyEvent XKeyPressedEvent;
+typedef XKeyEvent XKeyReleasedEvent;
+
+typedef struct {
+    int type;       /* of event */
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;   /* Display the event was read from */
+    Window window;          /* "event" window it is reported relative to */
+    Window root;            /* root window that the event occurred on */
+    Window subwindow;   /* child window */
+    Time time;      /* milliseconds */
+    int x, y;       /* pointer x, y coordinates in event window */
+    int x_root, y_root; /* coordinates relative to root */
+    unsigned int state; /* key or button mask */
+    unsigned int button;    /* detail */
+    Bool same_screen;   /* same screen flag */
+} XButtonEvent;
+typedef XButtonEvent XButtonPressedEvent;
+typedef XButtonEvent XButtonReleasedEvent;
+
+typedef struct {
+    int type;       /* of event */
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;   /* Display the event was read from */
+    Window window;          /* "event" window reported relative to */
+    Window root;            /* root window that the event occurred on */
+    Window subwindow;   /* child window */
+    Time time;      /* milliseconds */
+    int x, y;       /* pointer x, y coordinates in event window */
+    int x_root, y_root; /* coordinates relative to root */
+    unsigned int state; /* key or button mask */
+    char is_hint;       /* detail */
+    Bool same_screen;   /* same screen flag */
+} XMotionEvent;
+typedef XMotionEvent XPointerMovedEvent;
+
+#endif //#if 0
+
+typedef struct {
+    int type;
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;   /* Display the event was read from */
+    Window window;
+    int x, y;
+    int width, height;
+    int count;      /* if non-zero, at least this many more */
+} XExposeEvent;
+
+typedef struct {
+    int type;
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;   /* Display the event was read from */
+    Drawable drawable;
+    int x, y;
+    int width, height;
+    int count;      /* if non-zero, at least this many more */
+    int major_code;     /* core is CopyArea or CopyPlane */
+    int minor_code;     /* not defined in the core */
+} XGraphicsExposeEvent;
+
+typedef struct {
+    int type;
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;   /* Display the event was read from */
+    Drawable drawable;
+    int major_code;     /* core is CopyArea or CopyPlane */
+    int minor_code;     /* not defined in the core */
+} XNoExposeEvent;
+
+typedef struct {
+    int type;
+    unsigned long serial;   /* # of last request processed by server */
+    bool send_event;    /* true if this came from a SendEvent request */
+    Display *display;/* Display the event was read from */
+    Window window;  /* window on which event was requested in event mask */
+} XAnyEvent;
+
+/*
+ * this union is defined so Xlib can always use the same sized
+ * event structure internally, to avoid memory fragmentation.
+ */
+typedef union _XEvent {
+        int type;       /* must not be changed; first element */
+    XAnyEvent xany;
+//    XKeyEvent xkey;
+//    XButtonEvent xbutton;
+//    XMotionEvent xmotion;
+    XExposeEvent xexpose;
+    XGraphicsExposeEvent xgraphicsexpose;
+    XNoExposeEvent xnoexpose;
+    long pad[24];
+} XEvent;
+
+int
+XWindowEvent(Display* display, Window w, long event_mask, XEvent * ev);
+
+#define PIXEL_RGB332(r,g,b)    ( (((r)&0xE0)     ) | \
+                                 (((g)&0xE0) >> 3) | \
+                                 (((b)&0xC0) >> 6) )
+
+#define PIXEL_RGB16(r,g,b)     ( (((r)&0xF8) << 8) | \
+                                 (((g)&0xFC) << 3) | \
+                                 (((b)&0xF8) >> 3) )
+
+#define RGB16_RED(p)           (((p)&0xF800 ) >> 8 )
+
+#define RGB16_GREEN(p)         (((p)&0x07E0 ) >> 3 )
+
+#define RGB16_BLUE(p)          (((p)&0x001F ) << 3 )
+
+#define PIXEL_RGB32(r,g,b)     ( ((r) << 16) | \
+                                 ((g) <<  8) | \
+                                  (b) )
+
+#define PIXEL_ARGB(a,r,g,b)    ( ((a) << 24) | \
+                                 ((r) << 16) | \
+                                 ((g) << 8)  | \
+                                  (b) )
+
+#define PIXEL_ARGB4444(a,r,g,b)( (((a)&0xF0) << 8) | \
+                                 (((r)&0xF0) << 4) | \
+                                 (((g)&0xF0)     ) | \
+                                 (((b)&0xF0) >> 4) )
+
+
+#define ARGB_ALPHA(pixelval) ((pixelval & 0xFF000000) >> 24)
+
+#define ARGB_RED(pixelval)   ((pixelval & 0x00FF0000) >> 16)
+
+#define ARGB_GREEN(pixelval) ((pixelval & 0x0000FF00) >> 8)
+
+#define ARGB_BLUE(pixelval)  (pixelval & 0x000000FF)
+
+#define RGB32_RED(pixelval)  ((pixelval & 0x00FF0000) >> 16)
+
+#define RGB32_GREEN(pixelval) ((pixelval & 0x0000FF00) >> 8)
+
+#define RGB32_BLUE(pixelval) (pixelval & 0x000000FF)
+
+/* more fast macroses - operate with addresses */
+
+#define LOAD_U16_VO( addr )        *((u16*)(addr))
+
+#define STORE_U16_VO( addr, val )  *((u16*)(addr)) = (val)
+
+#define LOAD_U32_VO( addr )        *((u32*)(addr))
+
+#define STORE_U32_VO( addr, val)   *((u32*)(addr)) = (val)
+
+#ifdef WORDS_BIGENDIAN
+#  if WORDS_BIGENDIAN == 0
+#    undef WORDS_BIGENDIAN
+#  endif
+#endif
+
+#ifdef WORDS_BIGENDIAN
+
+/* architecture dependent macroses. objects to change */
+
+#ifdef REVERSE_BYTES /* e.g. 32 bits BGRA pixel format */
+
+#include <linux/config.h>
+
+#undef LOAD_U16_VO
+#define LOAD_U16_VO( addr )        load_le16( (u16*)(addr) )
+
+#undef STORE_U16_VO
+#define STORE_U16_VO( addr, val )  store_le16( (u16*)(addr), (val) )
+
+#undef LOAD_U32_VO
+#define LOAD_U32_VO( addr )        load_le32( (u32*)(addr) )
+
+#undef STORE_U32_VO
+#define STORE_U32_VO( addr, val)   store_le32( (u32*)addr, (val) )
+
+#if defined( CONFIG_PPC ) || defined( CONFIG_POWERPC ) /* PowerPC architecture */
+
+/*
+ * 16 and 32 bit, big and little endian I/O operations.
+ */
+
+static inline u16 load_le16(const u16 *addr) {
+    u16 ret;
+    __asm__ __volatile__("lhbrx %0,0,%1;\n"
+                  : "=r" (ret) :
+                  "r" (addr), "m" (*addr));
+    return ret;
+}
+
+static inline void store_le16( u16 *addr, u16 val) {
+    __asm__ __volatile__("sthbrx %1,0,%2;\n" : "=m" (*addr) :
+                  "r" (val), "r" (addr));
+}
+
+static inline u32 load_le32(const u32 *addr) {
+    u32 ret;
+    __asm__ __volatile__("lwbrx %0,0,%1;\n"
+                 : "=r" (ret) :
+                 "r" (addr), "m" (*addr));
+    return ret;
+}
+
+static inline void store_le32( u32 *addr, u32 val) {
+    __asm__ __volatile__("stwbrx %1,0,%2;\n" : "=m" (*addr) :
+                 "r" (val), "r" (addr));
+}
+
+#else /* not PowerPC architecture */
+
+/* */
+static inline u16 load_le16( u16* p ) {
+    return ( *p << 8) | ( *p >> 8 );
+}
+
+static inline u32 load_le32( u32* p ) {
+    u32 val = (*p & 0x00FF00FF) << 8 | (*p & 0xFF00FF00) >> 8;
+    return (val & 0x0000FFFF) << 16| (val & 0xFFFF0000) >> 16;
+}
+
+static inline void store_u16( u16* p, u16 val ) {
+    *p = ( val << 8) | ( val >> 8 );
+}
+
+static inline void store_u32( u32* p, u32 val ) {
+        val = (val & 0x00FF00FF) << 8 | (val & 0xFF00FF00) >> 8;
+        *p  = (val & 0x0000FFFF) << 16| (val & 0xFFFF0000) >> 16;
+}
+
+#endif /* of PowerPC architecture */
+
+static inline u16 reverse_u16( u16 val ) {
+    return load_le16( &val );
+}
+
+static inline u32 reverse_u32( u32 val ) {
+    return load_le32( &val );
+}
+
+#endif //REVERSE COLORS
+#endif //WORDS_BIGENDIAN
+
+
+/* it's very helpful function */
+static inline u32 swap_bytes(u32 u) {
+#if defined( CONFIG_PPC ) || defined( CONFIG_POWERPC )
+    __asm__ __volatile__("lwbrx %0,0,%1;\n"
+                    : "=r" (u) :
+                    "r" (&u), "m" (u));
+    return u;
+#else
+    u = (u & 0x00FF00FF) << 8 | (u & 0xFF00FF00) >> 8;
+    return (u & 0x0000FFFF) << 16| (u & 0xFFFF0000) >> 16;
+#endif
+}
+
+#endif /* _XUTILS_H_*/
diff -Nwrup -x.git fltk-1.1.9/fltk.spec FLTK_1.x-DirectFB/fltk.spec
--- fltk-1.1.9/fltk.spec	2008-04-27 04:28:19.000000000 -0400
+++ FLTK_1.x-DirectFB/fltk.spec	2009-11-28 15:48:05.901155245 -0500
@@ -25,7 +25,7 @@
 #      http://www.fltk.org/str.php
 #
 
-%define version @FL_MAJOR_VERSION@.@FL_MINOR_VERSION@.@FL_PATCH_VERSION@
+%define version 1.1.9
 %define release 1
 %define prefix /usr
 
@@ -35,7 +35,7 @@ Version: %{version}
 Release: %{release}
 License: LGPL
 Group: System Environment/Libraries
-Source: ftp://ftp.easysw.com/pub/fltk/1.1.9/fltk-1.1.9-source.tar.bz2
+Source: ftp://ftp.fltk.org/pub/fltk/%{version}/fltk-%{version}-source.tar.gz
 URL: http://www.fltk.org/
 Packager: FLTK Developer <fltk@fltk.org>
 # use BuildRoot so as not to disturb the version already installed
diff -Nwrup -x.git fltk-1.1.9/README.dfb FLTK_1.x-DirectFB/README.dfb
--- fltk-1.1.9/README.dfb	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/README.dfb	2009-11-28 15:48:05.856153881 -0500
@@ -0,0 +1,99 @@
+README.dfb - Building FLTK under DirectFB  (http://www.directfb.org)
+Ported by Nikita Egorov (nikego@gmail.com)
+---------------------------------------------------------------------------------------
+
+Current FLTK version - 1.1.9.
+Tested DirectFB versions - 1.0.0, 1.3.0
+Supported architectures - x86, PowerPC.
+Supported pixel formats (tested): ARGB, RGB32, RGB16, RGB332, ARGB4444, LUT8 (with USE_COLORMAP=1 only).
+
+-----------------------------------------------------------------------------------------
+
+You can configure FLTK with corresponding options. For example:
+
+./autoconf
+./configure 
+  --enable-directfb=yes 
+  --with-archflags="-I /path/to/directfb/include"
+  --enable-gl=no
+
+You must have the DirectFB's libraries within accessible paths to link them with FLTK.
+Be sure that the macroses X11_FONT_DIR1(2) in FL/xutils.h point at correct path with your fonts.
+
+-------------------------------------------------------------------------------------------
+
+Many functions are based on source codes from "microwindow" and "nxlib" libraries (http://www.microwindows.org).
+I adjusted them to use through DirectFB.
+
+Some features of the current version :
+
+- GL, "Drag and Drop", Visuals list are not implemented. 
+- As DirectFB's windows are buffered, the Fl_Double_Window and Fl_Window are the same.
+- The RGB image is an ancestor of the GIF image. 
+- The Child window is a part of the parent window. I use a subsurface of the main window surface.
+- Cap, join and width are not supported for line styles. Lines can have five slyles only: FL_SOLID..FL_DASHDOTDOT.
+  This realization requires improvement.
+- All drawing functions are working with rectangle regions only. (DirectFB's feature)
+- The cursor's functions require improvement too 
+
+----------------------------------------------------------------------------------------------
+It's a list of files which were added into the library:
+
+FL/DirectFB.H - main header file 
+FL/xutils.h   - contains prototypes of X-like functions 
+
+src/_colormap.cxx  - colors
+src/_arcpoly.cxx   - arc and polygon
+src/_draw.cxx  	   - drawing
+src/_image.cxx     - work with images
+src/_listfonts.cxx - creating list of fonts
+src/_loadfont.cxx  - loading fonts
+
+src/xutils.cxx - contains all the previous files and some functions too. It must be added into Makefile to compile
+src/Fl_directfb.cxx - main file like Fl_x.cxx
+src/fl_font_directfb.cxx - font functions
+
+It's a list of changed FLTK's files:
+
+FL/x.H
+FL/Fl_GIF_Image.H
+
+src/Fl.cxx
+src/Fl_grab.cxx	
+src/fl_cursor.cxx
+src/Fl_Bitmap.cxx
+src/Fl_own_colormap.cxx
+src/fl_dnd_x.cxx
+src/Fl_Double_Window.cxx
+src/Fl_visual.cxx
+src/fl_draw_image.cxx
+src/Fl_Font.H
+src/Fl_x.cxx
+src/fl_font.cxx
+src/Fl_GIF_Image.cxx
+src/Fl_Image.cxx
+src/fl_line_style.cxx
+src/Fl_JPEG_Image.cxx
+src/fl_overlay.cxx
+src/Fl_Light_Button.cxx
+src/fl_read_image.cxx
+src/fl_rect.cxx
+src/Fl_Window_fullscreen.cxx 
+src/fl_vertex.cxx
+src/Fl_arg.cxx
+src/fl_arci.cxx
+src/Fl_get_system_colors.cxx
+src/fl_color.cxx
+src/Makefile
+
+test/color_chooser.cxx
+test/image.cxx
+test/list_visual.cxx
+test/sudoku.cxx
+test/tiled_image.cxx
+
+-------------------------------------------------------------------------------------------------------------
+
+Have fun !
+
+PS Please, inform me about possible mistakes.
\ No newline at end of file
diff -Nwrup -x.git fltk-1.1.9/src/_arcpoly.cxx FLTK_1.x-DirectFB/src/_arcpoly.cxx
--- fltk-1.1.9/src/_arcpoly.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/_arcpoly.cxx	2009-11-28 15:48:05.983155774 -0500
@@ -0,0 +1,910 @@
+//
+// "$Id: _arcpoly.cxx,v 1.2 2006-12-06 11:37:23 nikego Exp $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains arc drawing code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+//
+// This file was taken from  Microwindows (Nano-X Window System) projects
+//  http://www.microwindows.org
+//  Edited by Nikita Egorov (nikego@gmail.com)  
+//
+//
+// Copyright (c) 2000-2001 Greg Haerr <greg@censoft.com>
+// Portions Copyright (c) 2002 by Koninklijke Philips Electronics N.V.
+//
+// Device-independent arc, pie and ellipse routines.
+// GdArc is integer only and requires start/end points.
+// GdArcAngle requires floating point and uses angles.
+// GdArcAngle uses qsin() and qcos() instead of sin() / cos() 
+// so no math lib needed.
+//
+// Portions Copyright (c) 1991 David I. Bell
+//
+// Arc line clipping and integer qsin/qcos routines used by permission:
+// Copyright (C) 1997-1998 by Eero Tamminen
+// Bugfixed by Greg Haerr
+ 
+
+/* NIKITA: FIXME DirectFB does not need clipping */
+#define NOCLIPPING 1
+
+/* NIKITA: FIXME FLTK has only solid fill */
+#define ONLYSOLIDFILL 1
+
+typedef GC PSD; //short name for surface's class
+
+/* variables for Nano X */
+
+int gr_fillmode;
+
+void drawpoint(GC gc, int x, int y)
+{
+  gc->surface->DrawLine(gc->surface, x, y, x, y);
+}
+
+void drawrow(GC gc, int x1, int x2, int y)
+{
+  gc->surface->DrawLine(gc->surface, x1, y, x2, y);
+}
+
+#define GdLine(psd, _x1, _y1, _x2, _y2, _b) fl_line(_x1, _y1, _x2, _y2) 
+//stubs 
+inline int GdFixCursor(GC)
+{
+  return 0;
+}
+inline int GdSetDash(unsigned long*, int*)
+{
+  return 0;
+}
+
+#ifdef HAVEFLOAT
+
+#include <math.h>
+#define qcos	QCOS
+#define qsin	QSIN
+typedef double FLOAT;
+
+FLOAT QCOS(FLOAT a) {
+  return cos(a * M_PI / 180.);
+}
+
+FLOAT QSIN(FLOAT a) {
+  return sin(a * M_PI / 180.);
+}
+#endif /* HAVEFLOAT*/
+
+/**
+ * Draw an arc or pie, angles are specified in 64th's of a degree.
+ * This function requires floating point, use GdArc for integer only.
+ *
+ * @param psd Destination surface.
+ * @param x0 Center of arc (X co-ordinate).
+ * @param y0 Center of arc (Y co-ordinate).
+ * @param rx Radius of arc in X direction.
+ * @param ry Radius of arc in Y direction.
+ * @param angle1 Start of arc.  In 64ths of a degree, anticlockwise from
+ * the +x axis.
+ * @param angle2 End of arc.  In 64ths of a degree, anticlockwise from
+ * the +x axis.
+ * @param type Type of arc:
+ * ARC is a curved line.
+ * ARCOUTLINE is a curved line plus straight lines joining the ends
+ * to the center of the arc.
+ * PIE is a filled shape, like a section of a pie chart.
+ */
+#if 0 //nikita 
+void
+GdArcAngle(PSD psd, short x0, short y0, short rx, short ry,
+    short angle1, short angle2, int type)
+{
+#if HAVEFLOAT
+  short ax, ay, bx, by;
+  FLOAT a, b;
+
+  /* calculate pie edge offsets from center to the ellipse rim */
+  ax = qcos(angle1/64.) * rx;
+  bx = qcos(angle2/64.) * rx;
+
+  a = -qsin(angle1/64.);
+  b = -qsin(angle2/64.);
+  ay = a * ry;
+  by = b * ry;
+
+  /* fix nxlib error with very small angles becoming whole circle*/
+  if (ax == bx && ay == by && angle1 != angle2)
+  return;
+
+  /* call integer routine*/
+  GdArc(psd, x0, y0, rx, ry, ax, ay, bx, by, type);
+#endif /*HAVEFLOAT*/
+}
+#endif
+/* argument holder for pie, arc and ellipse functions*/
+typedef struct
+{
+  PSD psd;
+  short x0, y0;
+  short rx, ry;
+  short ax, ay;
+  short bx, by;
+  int adir, bdir;
+  int type;
+} SLICE;
+
+/*
+ * Clip a line segment for arc or pie drawing.
+ * Returns 0 if line is clipped or on acceptable side, 1 if it's vertically
+ * on other side, otherwise 3.
+ */
+static int clip_line(SLICE *slice, short xe, short ye, int dir, short y,
+    short *x0, short *x1)
+{
+#if 0
+  /*
+   * kluge: handle 180 degree case
+   */
+  if (y >= 0 && ye == 0) {
+    /* bottom 180*/
+    if (slice->adir < 0) {
+      if (slice->ay || slice->by)
+      return 1;
+      if (slice->ax == -slice->bx)
+      return 0;
+    }
+    return 3;
+  }
+#endif
+  /* hline on the same vertical side with the given edge? */
+  if ((y >= 0 && ye >= 0) || (y < 0 && ye < 0)) {
+    short x;
+
+    if (ye == 0)
+      x = xe;
+    else
+      x = (short)(long)xe * y / ye;
+
+    if (x >= *x0 && x <= *x1) {
+      if (dir > 0)
+        *x0 = x;
+      else
+        *x1 = x;
+      return 0;
+    } else {
+      if (dir > 0) {
+        if (x <= *x0)
+          return 0;
+      } else {
+        if (x >= *x1)
+          return 0;
+      }
+    }
+    return 3;
+  }
+  return 1;
+}
+
+/* relative offsets, direction from left to right. */
+/* Mode indicates if we are in filil mode (1) or line mode (0) */
+
+static void draw_line(SLICE *slice, short x0, short y, short x1, int mode)
+{
+  int dbl = (slice->adir > 0 && slice->bdir < 0);
+  int discard, ret;
+  short x2 = x0, x3 = x1;
+
+  if (y == 0) {
+    if (slice->type != PIE) {
+      goto label_1;
+      /*FIXME 
+       if we doing the "return" command we have'nt two points on X axis */
+      /*return;*/
+    }
+    /* edges on different sides */
+    if ((slice->ay <= 0 && slice->by >= 0)
+        || (slice->ay >= 0 && slice->by <= 0)) {
+      if (slice->adir < 0) {
+        if (x1 > 0)
+          x1 = 0;
+      }
+      if (slice->bdir > 0) {
+        if (x0 < 0)
+          x0 = 0;
+      }
+    } else {
+      if (!dbl) {
+        /* FIXME leaving in draws dot in center*/
+#ifndef ONLYSOLIDFILL
+        if (gr_fillmode != FILL_SOLID && mode)
+        ts_drawpoint(slice->psd, slice->x0, slice->y0);
+        else
+#endif
+        drawpoint(slice->psd, slice->x0, slice->y0);
+        return;
+      }
+    }
+#ifndef ONLYSOLIDFILL
+    if (gr_fillmode != FILL_SOLID && mode)
+    ts_drawrow(slice->psd, slice->x0 + x0, slice->x0 + x1, slice->y0);
+    else
+#endif
+    drawrow(slice->psd, slice->x0 + x0, slice->x0 + x1, slice->y0);
+    return;
+  }
+  label_1:
+  /* clip left edge / line */
+  ret = clip_line(slice, slice->ax, slice->ay, slice->adir, y, &x0, &x1);
+
+  if (dbl) {
+    if (!ret) {
+      /* edges separate line to two parts */
+#ifndef ONLYSOLIDFILL
+      if (gr_fillmode != FILL_SOLID && mode)
+      ts_drawrow(slice->psd, slice->x0 + x0, slice->x0 + x1,
+          slice->y0 + y);
+      else
+#endif
+      drawrow(slice->psd, slice->x0 + x0, slice->x0 + x1, slice->y0 + y);
+
+      x0 = x2;
+      x1 = x3;
+    }
+  } else {
+    if (ret > 1) {
+      return;
+    }
+  }
+
+  discard = ret;
+  ret = clip_line(slice, slice->bx, slice->by, slice->bdir, y, &x0, &x1);
+
+  discard += ret;
+  if (discard > 2 && !(dbl && ret == 0 && discard == 3)) {
+    return;
+  }
+  if (discard == 2) {
+    /* line on other side than slice */
+    if (slice->adir < 0 || slice->bdir> 0){ 
+    return;
+  }
+}
+#ifndef ONLYSOLIDFILL
+if (gr_fillmode != FILL_SOLID && mode)
+  ts_drawrow(slice->psd, slice->x0 + x0, slice->x0 + x1, slice->y0 + y);
+else
+#endif
+  drawrow(slice->psd, slice->x0 + x0, slice->x0 + x1, slice->y0 + y);
+}
+
+/*
+ * draw one line segment or set of points, called from drawarc routine
+ *
+ * Note that this is called for all rows in one quadrant of the ellipse.
+ * It mirrors vertically & horizontally to get the entire ellipse.
+ *
+ * It passes on co-ordinates for the *entire* ellipse - for pie and
+ * arc, clipping is done later to ensure that only the requested angle
+ * gets drawn.
+ */
+static void drawarcsegment(SLICE *slice, short xp, short yp, int drawon)
+{
+  unsigned long dm = 0;
+  int dc = 0;
+
+  switch (slice->type) {
+  case ELLIPSEFILL:
+    /* draw ellipse fill segment*/
+    /* First, save the dash settings, because we don't want to use them here */
+#ifndef ONLYSOLIDFILL
+    if (gr_fillmode != FILL_SOLID) {
+      ts_drawrow(slice->psd, slice->x0-xp, slice->x0+xp, slice->y0-yp);
+      ts_drawrow(slice->psd, slice->x0-xp, slice->x0+xp, slice->y0+yp);
+    }
+    else
+#endif
+  {
+    GdSetDash(&dm, &dc); /* Must turn off the dash settings because of drawrow() */
+    drawrow(slice->psd, slice->x0-xp, slice->x0+xp, slice->y0-yp);
+    drawrow(slice->psd, slice->x0-xp, slice->x0+xp, slice->y0+yp);
+    GdSetDash(&dm, &dc);
+  }
+
+    return;
+
+  case ELLIPSE:
+    if (!drawon)
+      return;
+    /* set four points symmetrically situated around a point*/
+    drawpoint(slice->psd, slice->x0 + xp, slice->y0 + yp);
+    drawpoint(slice->psd, slice->x0 - xp, slice->y0 + yp);
+    drawpoint(slice->psd, slice->x0 + xp, slice->y0 - yp);
+    drawpoint(slice->psd, slice->x0 - xp, slice->y0 - yp);
+    return;
+
+  case PIE:
+    /* draw top and bottom halfs of pie*/
+    if (gr_fillmode == FILL_SOLID)
+      GdSetDash(&dm, &dc);
+    draw_line(slice, -xp, -yp, +xp, 1);
+    draw_line(slice, -xp, +yp, +xp, 1);
+    if (gr_fillmode == FILL_SOLID)
+      GdSetDash(&dm, &dc);
+    return;
+
+  default: /* ARC, ARCOUTLINE*/
+    /* set four points symmetrically around a point and clip*/
+    draw_line(slice, +xp, +yp, +xp, 0);
+    draw_line(slice, -xp, +yp, -xp, 0);
+    draw_line(slice, +xp, -yp, +xp, 0);
+    draw_line(slice, -xp, -yp, -xp, 0);
+    return;
+  }
+}
+
+/* General routine to plot points on an arc.  Used by arc, pie and ellipse*/
+static void drawarc(SLICE *slice)
+{
+  short xp, yp; /* current point (based on center) */
+  short rx, ry;
+  long Asquared; /* square of x semi axis */
+  long TwoAsquared;
+  long Bsquared; /* square of y semi axis */
+  long TwoBsquared;
+  long d;
+  long dx, dy;
+
+  int bit = 0;
+  int drawon = 1;
+
+  rx = slice->rx;
+  ry = slice->ry;
+
+  xp = 0;
+  yp = ry;
+  Asquared = rx * rx;
+  TwoAsquared = 2 * Asquared;
+  Bsquared = ry * ry;
+  TwoBsquared = 2 * Bsquared;
+  d = Bsquared - Asquared * ry + (Asquared >> 2);
+  dx = 0;
+  dy = TwoAsquared * ry;
+#ifndef ONLYSOLIDFILL
+  if (gr_fillmode != FILL_SOLID)
+  set_ts_origin(slice->x0 - rx, slice->y0 - ry);
+#endif
+  while (dx < dy) {
+
+    /*
+     * Only draw if one of the following conditions holds:
+     * - We're drawing an outline - i.e. slice->type is
+     *   not PIE or ELLIPSEFILL
+     * - We're about to move on to the next Y co-ordinate
+     *   (i.e. we're drawing a filled shape and we're at
+     *   the widest point for this Y co-ordinate).
+     *   This is the case if d (the error term) is >0
+     * Otherwise, we draw multiple times, which messes up
+     * with SRC_OVER or XOR modes.
+     */
+    if ((d > 0) || ((slice->type != PIE) && (slice->type != ELLIPSEFILL))) {
+      if (slice->psd->dashcount) {
+        drawon = (slice->psd->dashmask & (1 << bit)) ? 1 : 0;
+        bit = (bit + 1) % slice->psd->dashcount;
+      } else
+        drawon = 1;
+
+      drawarcsegment(slice, xp, yp, drawon);
+    }
+
+    if (d > 0) {
+      yp--;
+      dy -= TwoAsquared;
+      d -= dy;
+    }
+    xp++;
+    dx += TwoBsquared;
+    d += (Bsquared + dx);
+  }
+
+  d += ((3L * (Asquared - Bsquared) / 2L - (dx + dy)) >> 1);
+
+  while (yp >= 0) {
+    if (slice->psd->dashcount) {
+      drawon = (slice->psd->dashmask & (1 << bit)) ? 1 : 0;
+      bit = (bit + 1) % slice->psd->dashcount;
+    } else
+      drawon = 1;
+
+    drawarcsegment(slice, xp, yp, drawon);
+    if (d < 0) {
+      xp++;
+      dx += TwoBsquared;
+      d += dx;
+    }
+    yp--;
+    dy -= TwoAsquared;
+    d += (Asquared - dy);
+  }
+
+}
+
+/**
+ * Draw an arc or pie using start/end points.
+ * Integer only routine.  To specify start/end angles,
+ * use GdArcAngle, which requires floating point.
+ *
+ * @param psd Destination surface.
+ * @param x0 Center of arc (X co-ordinate).
+ * @param y0 Center of arc (Y co-ordinate).
+ * @param rx Radius of arc in X direction.
+ * @param ry Radius of arc in Y direction.
+ * @param ax Start of arc (X co-ordinate).
+ * @param ay Start of arc (Y co-ordinate).
+ * @param bx End of arc (X co-ordinate).
+ * @param by End of arc (Y co-ordinate).
+ * @param type Type of arc:
+ * ARC is a curved line.
+ * ARCOUTLINE is a curved line plus straight lines joining the ends
+ * to the center of the arc.
+ * PIE is a filled shape, like a section of a pie chart.
+ */
+void Arc(GC gc, short x0, short y0, short rx, short ry, short ax, short ay,
+    short bx, short by, int type)
+{
+  PSD psd = gc;
+  short adir, bdir;
+  SLICE slice;
+
+  if (rx < 0 || ry < 0)
+    return;
+
+  update_region(psd, x0-rx, y0-ry, x0+rx, y0+ry);
+
+  if (rx==0) {
+    gc->surface->DrawLine(gc->surface, x0, y0-ry, x0, y0+ry);
+    return;
+  }
+  if (ry==0) {
+    gc->surface->DrawLine(gc->surface, x0-rx, y0, x0+rx, y0);
+    return;
+  }
+
+  /*
+   * Calculate right/left side clipping, based on quadrant.
+   * dir is positive when right side is filled and negative when
+   * left side is to be filled.
+   *
+   * >= 0 is bottom half
+   */
+  if (ay >= 0)
+    adir = 1;
+  else
+    adir = -1;
+
+  if (by >= 0)
+    bdir = -1;
+  else
+    bdir = 1;
+
+  /*
+   * The clip_line routine has problems around the 0 and
+   * 180 degree axes.
+   * This <fix> is required to make the clip_line algorithm
+   * work.  Getting these routines to work for all angles is
+   * a bitch.  And they're still buggy.  Doing this causes
+   * half circles to be outlined with a slightly bent line
+   * on the x axis. FIXME
+   */
+  if (ay == 0)
+    ++ay;
+  if (by == 0)
+    ++by;
+
+  /* swap rightmost edge first */
+  if (bx > ax) {
+    short swap;
+
+    swap = ax;
+    ax = bx;
+    bx = swap;
+
+    swap = ay;
+    ay = by;
+    by = swap;
+
+    swap = adir;
+    adir = bdir;
+    bdir = swap;
+  }
+#ifndef NOCLIPPING
+  /* check for entire area clipped, draw with per-point clipping*/
+  if (GdClipArea(psd, x0-rx, y0-ry, x0+rx, y0+ry) == CLIP_INVISIBLE)
+  return;
+#endif
+  slice.psd = psd;
+  slice.x0 = x0;
+  slice.y0 = y0;
+  slice.rx = rx;
+  slice.ry = ry;
+  slice.ax = ax;
+  slice.ay = ay;
+  slice.bx = bx;
+  slice.by = by;
+  slice.adir = adir;
+  slice.bdir = bdir;
+  slice.type = type;
+
+  drawarc(&slice);
+
+  if (type & OUTLINE) {
+    /* draw two lines from rx,ry to arc endpoints*/
+    GdLine(psd, x0, y0, x0+ax, y0+ay, TRUE);
+    GdLine(psd, x0, y0, x0+bx, y0+by, TRUE);
+  }
+  GdFixCursor(psd);
+}
+
+/**
+ * Draw an ellipse using the current clipping region and foreground color.
+ * This draws in the outline of the ellipse, or fills it.
+ * Integer only routine.
+ *
+ * @param psd Destination surface.
+ * @param x Center of ellipse (X co-ordinate).
+ * @param y Center of ellipse (Y co-ordinate).
+ * @param rx Radius of ellipse in X direction.
+ * @param ry Radius of ellipse in Y direction.
+ * @param fill Nonzero for a filled ellipse, zero for an outline.
+ */
+void GdEllipse(GC gc, short x, short y, short rx, short ry, bool fill)
+{
+  PSD psd = gc;
+  SLICE slice;
+
+  if (rx < 0 || ry < 0)
+    return;
+
+  /* Check if the ellipse bounding box is either totally visible
+   * or totally invisible.  Draw with per-point clipping.
+   */
+#ifndef NOCLIPPING
+  switch (GdClipArea(psd, x - rx, y - ry, x + rx, y + ry)) {
+    case CLIP_VISIBLE:
+    /*
+     * For size considerations, there's no low-level ellipse
+     * draw, so we've got to draw all ellipses
+     * with per-point clipping for the time being
+     psd->DrawEllipse(psd, x, y, rx, ry, fill, gr_foreground);
+     GdFixCursor(psd);
+     return;
+     */
+    break;
+
+    case CLIP_INVISIBLE:
+    return;
+  }
+#endif
+  slice.psd = psd;
+  slice.x0 = x;
+  slice.y0 = y;
+  slice.rx = rx;
+  slice.ry = ry;
+  slice.type = fill ? ELLIPSEFILL : ELLIPSE;
+  /* other elements unused*/
+
+  drawarc(&slice);
+
+  GdFixCursor(psd);
+}
+/************************************************************************/
+#define max_columns 64
+#define max_lines   2048
+
+typedef struct column_item
+{
+  DFBSpan* list;
+  int first_y;
+  int last_y;
+} column_item_t;
+
+static column_item spanslist[max_columns] = { { 0 } };
+
+/*
+ * flush the spans list to the screen
+ */
+static int flush_spans(GC gc)
+{
+  // flash all spans list and release memory
+  int i = 0;
+  column_item* item = spanslist;
+  for (; i < max_columns; i++) {
+    if (item->list) {
+      int s = item->first_y, j;// 's' points to first span
+      for (j = item->first_y; j <= item->last_y; j++) {
+        if (item->list[j].w == 0)//it's empty chunk
+        {
+          if (j - s)// have we a number of spans to flush?
+            gc->surface->FillSpans(gc->surface, s, item->list + s, j - s);
+          s = j + 1;// shift our 's' to next non empty span
+        }
+      }
+      if (j - s) // after ending of cycle test for remaining spans
+        gc->surface->FillSpans(gc->surface, s, item->list+s, j-s);
+
+      Xfree(item->list);
+      item->list = 0;
+      item++; //next list
+      continue;
+    }
+    break;
+  }
+  return 0;
+}
+
+//add new horz line into lists of spans
+static int add_span(GC gc, int y, int x, int w)
+{
+  if (y < 0 || y > max_lines)return -1;
+  column_item* item = spanslist;
+  int i = 0;
+  do {
+    if (item->list == 0)
+    {
+      item->list = (DFBSpan*)Xcalloc(sizeof(DFBSpan), max_lines);
+      item->first_y = 10000; //init min and max values of 'y'
+      item->last_y =-10000;
+    }
+    if (item->list[y].w == 0)//empty span with our 'y'
+    {
+      item->list[y].x = x; //put 'x' and width
+      item->list[y].w = w;
+      if (item->first_y> y) //if it's necessary correct min and max values of 'y'
+      item->first_y = y;
+      if (item->last_y < y)
+      item->last_y = y;
+      return 0; //success exit
+    }
+    item++;//step to next list
+  }while (++i < max_columns);
+  //oh-oh! something is wrong
+  return -1;
+}
+
+#if EDGEPOLYFILL    /* irregular polygon fill, uses edge table, malloc, qsort*/
+
+/************************************************************/
+
+/*
+ * Fill a polygon in the foreground color, applying clipping if necessary.
+ * The last point may be a duplicate of the first point, but this is
+ * not required.
+ * Note: this routine correctly draws convex, concave, regular, 
+ * and irregular polygons.
+ */
+
+typedef struct {
+  int x1, y1, x2, y2;
+#if HAVEFLOAT
+  double x, m;
+#else
+  int cx, fn, mn, d;
+#endif
+}edge_t;
+
+static inline int
+edge_cmp(edge_t *lp, edge_t *rp)
+{
+  /* if the minimum y values are different, sort on minimum y */
+  if (lp->y1 != rp->y1)
+  return (lp->y1> rp->y1);
+
+  /* if the current x values are different, sort on current x */
+  return (lp->x> rp->x);
+}
+
+static inline void
+swap_edges(edge_t* a, edge_t* b) {
+  edge_t t = *a;
+  *a = *b;
+  *b = t;
+}
+
+/*
+ * code of these sort functions was taken from "Programming Pearls"
+ * http://netlib.bell-labs.com/cm/cs/pearls/sort.cpp
+ */
+
+static inline void
+isort3(edge_t *x, int n)
+{ int i, j;
+  edge_t t;
+  for (i = 1; i < n; i++) {
+    t = x[i];
+    for (j = i; j> 0 && edge_cmp(x+j-1,&t); j--)
+    x[j] = x[j-1];
+    x[j] = t;
+  }
+}
+/* qsort3 + randomization + isort small subarrays + swap inline */
+static int cutoff = 50;
+
+static void qsort4(edge_t *x, int l, int u)
+{ int i, j;
+  edge_t t, temp;
+  if (u - l < cutoff)
+  return;
+  //swap_edges(x+l, x+randint(l, u));//FIXME - it hangs up...
+  t = x[l];
+  i = l;
+  j = u+1;
+  for (;;) {
+    do i++; while (i <= u && edge_cmp(&t,x+i));
+    do j--; while (edge_cmp(x+j,&t));
+    if (i> j)
+    break;
+    temp = x[i]; x[i] = x[j]; x[j] = temp;
+  }
+  swap_edges(x+l, x+j);
+  qsort4(x,l, j-1);
+  qsort4(x,j+1, u);
+}
+
+/* for big polygons (where egdes number > cutoff) we are using quick sort */
+#define SORT1(ptr,n) qsort4(ptr,0,n-1);isort3(ptr,n)
+
+/* otherwise,  insertion sort works faster */
+#define SORT2(ptr,n) isort3(ptr,n)
+
+/**
+ * Draw a filled polygon.
+ *
+ * @param psd Drawing surface.
+ * @param count Number of points in polygon.
+ * @param pointtable The array of points.
+ */
+void
+FillPoly(Drawable d, GC gc, int count, POINT_f* pointtable) {
+
+  Surface surface = ISGC(d);
+  if (!surface)
+  surface = gc;
+
+  edge_t *get; /* global edge table */
+  int nge = 0; /* num global edges */
+  int cge = 0; /* cur global edge */
+
+  edge_t *aet; /* active edge table */
+  int nae = 0; /* num active edges */
+
+  int i, y;
+
+  if (count < 3) {
+    /* error, polygons require at least three edges (a triangle) */
+    return;
+  }
+  get = (edge_t *) calloc(count, sizeof(edge_t));
+  aet = (edge_t *) calloc(count, sizeof(edge_t));
+
+  if ((get == 0) || (aet == 0)) {
+    /* error, couldn't allocate one or both of the needed tables */
+    if (get)
+    free(get);
+    if (aet)
+    free(aet);
+    return;
+  }
+  /* setup the global edge table */
+  for (i = 0; i < count; ++i) {
+    get[nge].x1 = (int)(pointtable[i].x+.5);
+    get[nge].y1 = (int)(pointtable[i].y+.5);
+    get[nge].x2 = (int)(pointtable[(i + 1) % count].x+.5);
+    get[nge].y2 = (int)(pointtable[(i + 1) % count].y+.5);
+    if (get[nge].y1 != get[nge].y2) {
+      if (get[nge].y1> get[nge].y2) {
+        swap(get[nge].x1, get[nge].x2);
+        swap(get[nge].y1, get[nge].y2);
+      }
+#if HAVEFLOAT
+      get[nge].x = get[nge].x1;
+      get[nge].m = get[nge].x2 - get[nge].x1;
+      get[nge].m /= get[nge].y2 - get[nge].y1;
+#else
+      get[nge].cx = get[nge].x1;
+      get[nge].mn = get[nge].x2 - get[nge].x1;
+      get[nge].d = get[nge].y2 - get[nge].y1;
+      get[nge].fn = get[nge].mn / 2;
+#endif
+      ++nge;
+    }
+  }
+
+  SORT1(get,nge);
+
+  /* start with the lowest y in the table */
+  y = get[0].y1;
+
+  do {
+    /* add edges to the active table from the global table */
+    while ((nge> 0) && (get[cge].y1 == y)) {
+      aet[nae] = get[cge++];
+      --nge;
+      aet[nae++].y1 = 0;
+    }
+    SORT2(aet,nae);
+    /* using odd parity, render alternating line segments */
+    for (i = 1; i < nae; i += 2) {
+#if HAVEFLOAT
+      int l = (int)(aet[i - 1].x + 0.5);//+0.5 - Nikita
+      int r = (int)(aet[i].x + 0.5);//+0.5 - Nikita
+#else
+      int l = (int)aet[i - 1].cx;
+      int r = (int)aet[i].cx;
+#endif
+      if (r> l) {
+        add_span(surface, y, l, r-l);
+      }
+    }
+
+    /* prepare for the next scan line */
+    ++y;
+
+    /* remove inactive edges from the active edge table */
+    /* or update the current x position of active edges */
+    for (i = 0; i < nae; ++i) {
+      if (aet[i].y2 == y)
+      aet[i--] = aet[--nae];
+      else {
+#if HAVEFLOAT
+        aet[i].x += aet[i].m;
+#else
+        aet[i].fn += aet[i].mn;
+        if (aet[i].fn < 0) {
+          aet[i].cx += aet[i].fn / aet[i].d - 1;
+          aet[i].fn %= aet[i].d;
+          aet[i].fn += aet[i].d;
+        }
+        if (aet[i].fn >= aet[i].d) {
+          aet[i].cx += aet[i].fn / aet[i].d;
+          aet[i].fn %= aet[i].d;
+        }
+#endif
+      }
+    }
+    /* keep doing this while there are any edges left */
+  }while ((nae> 0) || (nge> 0));
+
+  flush_spans(surface);
+  /* all done, free the edge tables */
+  free(get);
+  free(aet);
+
+  GdFixCursor(surface);
+  
+  //update_region(surf,minx,miny,maxx,maxy);
+}
+
+#endif /* EDGEPOLYFILL*/
+
diff -Nwrup -x.git fltk-1.1.9/src/_colormap.cxx FLTK_1.x-DirectFB/src/_colormap.cxx
--- fltk-1.1.9/src/_colormap.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/_colormap.cxx	2009-11-28 15:48:05.984155335 -0500
@@ -0,0 +1,876 @@
+//
+// "$Id: _colormap.cxx,v 1.2 2006-10-31 09:31:14 nikego Exp $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains colormap-specific code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+//
+// This file was taken from  Microwindows (Nano-X Window System) projects
+// http://www.microwindows.org
+// Edited by Nikita Egorov (nikego@gmail.com)
+
+#include <stdlib.h>
+#include <string.h>
+#include <FL/Fl.H>
+#include <FL/x.H>
+
+
+#define COLORVAL ulong
+ 
+#define ARGB(a,r,g,b)	((COLORVAL)(((unsigned char)(r)|\
+				(((unsigned)(unsigned char)(g))<<8))|\
+				(((unsigned long)(unsigned char)(b))<<16)|\
+				(((unsigned long)(unsigned char)(a))<<24)))
+#define RGB(r,g,b)	ARGB(255,(r),(g),(b))		/* rgb full alpha*/
+#define iRGB(r,g,b)	ARGB(0,(r),(g),(b))		/* rgb no alpha*/
+#define GR_RGB(r,g,b)	RGB(r,g,b)
+
+#define DoRed			(1<<0)
+#define DoGreen			(1<<1)
+#define DoBlue			(1<<2)
+
+const u32 BG_COLOR_RGB32 = PIXEL_RGB32(255, 0, 255);
+
+/*
+ * Conversion from RGB to PIXELVAL
+ */
+#if 0
+/* create 24 bit 8/8/8 format pixel (0x00RRGGBB) from RGB triplet*/
+#define RGB2PIXEL888(r,g,b)	\
+	(((r) << 16) | ((g) << 8) | (b))
+
+/* create 16 bit 5/6/5 format pixel from RGB triplet */
+#define RGB2PIXEL565(r,g,b)	\
+	((((r) & 0xf8) << 8) | (((g) & 0xfc) << 3) | (((b) & 0xf8) >> 3))
+
+/* create 16 bit 5/5/5 format pixel from RGB triplet */
+#define RGB2PIXEL555(r,g,b)	\
+	((((r) & 0xf8) << 7) | (((g) & 0xf8) << 2) | (((b) & 0xf8) >> 3))
+
+/* create 8 bit 3/3/2 format pixel from RGB triplet*/
+#define RGB2PIXEL332(r,g,b)	\
+	(((r) & 0xe0) | (((g) & 0xe0) >> 3) | (((b) & 0xc0) >> 6))
+
+#endif
+
+/* pixel packing was taken from directfb's /src/gfx/convert.h */
+
+#define PIXEL_RGB332(r,g,b)    ( (((r)&0xE0)     ) | \
+                                 (((g)&0xE0) >> 3) | \
+                                 (((b)&0xC0) >> 6) )
+
+#define PIXEL_ARGB1555(a,r,g,b)( (((a)&0x80) << 8) | \
+                                 (((r)&0xF8) << 7) | \
+                                 (((g)&0xF8) << 2) | \
+                                 (((b)&0xF8) >> 3) )
+
+#define PIXEL_RGB555(r,g,b)  ( (((r)&0xF8) << 7) | \
+                                 (((g)&0xF8) << 2) | \
+                                 (((b)&0xF8) >> 3) )
+
+#define PIXEL_ARGB2554(a,r,g,b)( (((a)&0xC0) << 8) | \
+                                 (((r)&0xF8) << 6) | \
+                                 (((g)&0xF8) << 1) | \
+                                 (((b)&0xF0) >> 4) )
+
+#define PIXEL_ARGB4444(a,r,g,b)( (((a)&0xF0) << 8) | \
+                                 (((r)&0xF0) << 4) | \
+                                 (((g)&0xF0)     ) | \
+                                 (((b)&0xF0) >> 4) )
+
+#define PIXEL_RGB444(r,g,b)  ( (((r)&0xF0) << 4) | \
+                                 (((g)&0xF0)     ) | \
+                                 (((b)&0xF0) >> 4) )
+
+#define PIXEL_RGB16(r,g,b)     ( (((r)&0xF8) << 8) | \
+                                 (((g)&0xFC) << 3) | \
+                                 (((b)&0xF8) >> 3) )
+
+#define PIXEL_RGB18(r,g,b)     ( (((r)&0xFC) << 10) | \
+                                 (((g)&0xFC) <<  4) | \
+                                 (((b)&0xFC) >>  2) )
+
+#define PIXEL_RGB32(r,g,b)     ( ((r) << 16) | \
+                                 ((g) <<  8) | \
+                                  (b) )
+
+#define PIXEL_ARGB(a,r,g,b)    ( ((a) << 24) | \
+                                 ((r) << 16) | \
+                                 ((g) << 8)  | \
+                                  (b) )
+
+#define PIXEL_ARGB1666(a,r,g,b) ( (((a)&0x80) << 11) | \
+                                  (((r)&0xFC) << 10) | \
+                                  (((g)&0xFC) <<  4) | \
+                                  (((b)&0xFC) >>  2) )
+
+#define PIXEL_ARGB6666(a,r,g,b) ( (((a)&0xFC) << 16) | \
+                                  (((r)&0xFC) << 10) | \
+                                  (((g)&0xFC) <<  4) | \
+                                  (((b)&0xFC) >>  2) )
+
+/*
+ * Conversion from PIXELVAL to red, green or blue components
+ */
+/* return 8/8/8 bit r, g or b component of 24 bit pixelval*/
+#define PIXEL888RED(pixelval)		(((pixelval) >> 16) & 0xff)
+#define PIXEL888GREEN(pixelval)		(((pixelval) >> 8) & 0xff)
+#define PIXEL888BLUE(pixelval)		((pixelval) & 0xff)
+
+/* return 5/6/5 bit r, g or b component of 16 bit pixelval*/
+#define PIXEL565RED(pixelval)		(((pixelval) >> 11) & 0x1f)
+#define PIXEL565GREEN(pixelval)		(((pixelval) >> 5) & 0x3f)
+#define PIXEL565BLUE(pixelval)		((pixelval) & 0x1f)
+
+/* return 5/5/5 bit r, g or b component of 16 bit pixelval*/
+#define PIXEL555RED(pixelval)		(((pixelval) >> 10) & 0x1f)
+#define PIXEL555GREEN(pixelval)		(((pixelval) >> 5) & 0x1f)
+#define PIXEL555BLUE(pixelval)		((pixelval) & 0x1f)
+
+/* return 3/3/2 bit r, g or b component of 8 bit pixelval*/
+#define PIXEL332RED(pixelval)		(((pixelval) >> 5) & 0x07)
+#define PIXEL332GREEN(pixelval)		(((pixelval) >> 2) & 0x07)
+#define PIXEL332BLUE(pixelval)		((pixelval) & 0x03)
+
+/* return a pixel value's component r, g, b parts*/
+void _nxPixel2RGB(Display* display, unsigned long color,
+	   unsigned short *red, unsigned short *green, unsigned short *blue)
+{
+	/* the PIXELxxx macros below only return the actual color bits
+	 * in the pixelval.  Thus, they need left shifting
+	 * in order to become a normal r,g,b value.  In addition,
+	 * they need to be shifted left another 8 bits to become
+	 * X11 compatible colors.
+	 */
+/* nikita added - using palette  !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! */
+	int pix_f = pixel_format();
+	if ((pix_f == DSPF_LUT8) || (pix_f == DSPF_ALUT44) )
+	 {
+		*blue   = PIXEL888RED(color)   << (8 + 0);
+		*green  = PIXEL888GREEN(color) << (8 + 0);
+		*red    = PIXEL888BLUE(color)  << (8 + 0);
+	}
+	else
+	{ /*old code follow */
+		switch (pix_f) {
+		case DSPF_RGB332:
+			*red    = PIXEL332RED(color)  << (8 + 5);
+			*green  = PIXEL332GREEN(color)<< (8 + 5);
+			*blue   = PIXEL332BLUE(color) << (8 + 6);
+			break;
+		case DSPF_ARGB1555:
+			*red    = PIXEL555RED(color)  << (8 + 3);
+			*green  = PIXEL555GREEN(color)<< (8 + 3);
+			*blue   = PIXEL555BLUE(color) << (8 + 3);
+			break;
+		case DSPF_RGB16:
+			*red    = PIXEL565RED(color)  << (8 + 3);
+			*green  = PIXEL565GREEN(color)<< (8 + 2);
+			*blue   = PIXEL565BLUE(color) << (8 + 3);;
+			break;
+		case DSPF_ARGB:  	
+		case DSPF_RGB24:
+		case DSPF_RGB32:  
+			*red    = PIXEL888RED(color)  << (8 + 0);
+			*green  = PIXEL888GREEN(color)<< (8 + 0);
+			*blue   = PIXEL888BLUE(color) << (8 + 0);
+ 			break;
+		default:
+			break;		
+		}
+	}
+}
+
+int 
+get_rgb_color(int xcolor, uchar& r, uchar& g, uchar& b){
+  XColor xcol={0};
+  xcol.pixel = xcolor;
+  XQueryColor(fl_display, _nxDefaultColormap(fl_display), &xcol);
+  r = xcol.red    >> 8;
+  g = xcol.green  >> 8;
+  b = xcol.blue   >> 8;
+  return 0;	
+}
+
+int get_index_color(uchar r,uchar g,uchar b)
+{
+	XColor xcol;
+	xcol.red    = r << 8;
+	xcol.green  = g << 8;
+	xcol.blue   = b << 8;
+	XAllocColor(fl_display,_nxDefaultColormap(fl_display),&xcol);
+	return xcol.pixel;
+}
+
+int XSetForeground(Display* display, GC gc, int color_index)
+{
+	if (gc) {
+		//int pix_f = pixel_format();
+		//if (pix_f == DSPF_LUT8){  		
+		//	set_color(surface, color_index);
+	 	//} else {
+	 		uchar r,g,b;
+	 		get_rgb_color(color_index, r, g ,b);
+			set_color(gc,r,g,b,255);
+	 	//}
+	}
+	return 0;
+}
+
+int XFreeColors(Display* display, Colormap colormap, unsigned long pixels[],
+	    int npixels, unsigned long planes)
+{
+	int n;
+	nxColormap *local = _nxFindColormap(colormap);
+
+	if (!local)
+		return 0;
+
+	/* FIXME:  We should be smart and pack the array, blah, blah blah.... */
+	/* I just stick this in so it will be easier later                    */
+
+	for (n = 0; n < npixels; n++) {
+		unsigned long index = pixels[n];
+
+		if ((long)index >= local->cur_color || local->colorval[index].ref==0)
+			continue;
+		--local->colorval[index].ref;
+	}
+
+	return 1;
+}
+
+
+typedef struct hash_node{
+	unsigned long rgb;
+	int index;
+	hash_node* next;
+}hash_node_;
+
+#define hash_ar_size 16384
+
+#define mul_k 10368889
+
+hash_node** hash_array = 0; 
+#define hash_func(r, g, b) ((((r<<8)|g)<<8)|b)% 1001)
+#define hash_func_2(rgb) ((ulong)(rgb*mul_k) >> 18)
+#define hash_func_3(rgb) (rgb % 1001)
+
+#define SQR(a) sqr(a)
+
+// DirectFB's palette function SetEntries() is very slow (sometimes)
+// we upload current colormap to the palette if it need
+
+int
+XFlushColormap(Display* display, Colormap colormap)
+{
+	if (!display || !fl_screen)
+		return 0;
+	int pix_f = pixel_format();
+	if ((pix_f != DSPF_LUT8)&& (pix_f != DSPF_ALUT44)	)
+		return 0;
+		 
+	nxColormap* local = _nxFindColormap(colormap);
+	if (!local)
+		return 0;
+		
+	int to_save = local->cur_color - local->saved_color; 
+	if (to_save == 0)
+		return 0;
+		
+	IDirectFBPalette* pal;
+	get_palette(fl_screen, &pal);
+	
+	pal->SetEntries(pal, &local->colors[local->saved_color], to_save, local->saved_color); 
+	pal->Release(pal);
+	
+	local->saved_color = local->cur_color;
+	return to_save;
+}
+/*
+ * Convert a color from RGB to pixel format.  If hw is non-palette
+ * this routine will never allocate a colormap entry.  (FIXME?)
+ * This works for now since we special case XPutImage for truecolor
+ * hardware.
+ */
+int
+XAllocColor(Display* display, Colormap colormap, XColor * in_out)
+{
+  if (!display || !fl_screen)
+    return 0;
+
+  int i;
+  nxColormap * local;
+  u32 rgb;
+  u32 r = in_out->red   >> 8;
+  u32 g = in_out->green >> 8;
+  u32 b = in_out->blue  >> 8;
+
+  int pix_f = pixel_format();
+  if ((pix_f != DSPF_LUT8) && (pix_f != DSPF_ALUT44)){ //check for non-palette
+    switch (pix_f){
+      case DSPF_RGB332:
+        in_out->pixel = PIXEL_RGB332( r, g, b );
+        break;
+      case DSPF_ARGB1555:
+        in_out->pixel = PIXEL_ARGB1555( 0, r, g, b );
+        break;
+      //case DSPF_RGB555:
+      //  in_out->pixel = PIXEL_RGB555( r, g, b );
+      //  break;
+      case DSPF_ARGB2554:
+        in_out->pixel = PIXEL_ARGB2554( 0, r, g, b );
+        break;
+      case DSPF_ARGB4444:
+        in_out->pixel = PIXEL_ARGB4444( 0, r, g, b );
+        break;
+      //case DSPF_RGB444:
+      //  in_out->pixel = PIXEL_RGB444( r, g, b );
+      //  break;
+      case DSPF_RGB16:
+        in_out->pixel = PIXEL_RGB16( r, g, b );
+        break;
+      case DSPF_RGB18:
+      case DSPF_ARGB1666:
+      case DSPF_ARGB6666:
+        in_out->pixel = PIXEL_RGB18( r, g, b );
+        break;
+      case DSPF_RGB24:
+      case DSPF_RGB32:
+      case DSPF_ARGB:
+      case DSPF_AiRGB:
+        in_out->pixel = PIXEL_RGB32( r, g, b );
+        break;
+      default:
+        in_out->pixel = 0;
+    }
+    return 1;
+  }
+  /* not truecolor hardware, allocate a colormap index*/
+  rgb = GR_RGB(r, g, b);
+
+  local = _nxFindColormap(colormap);
+  if (!local)
+    return 0;
+
+  if (hash_array == 0){
+    hash_array = (hash_node**)malloc(hash_ar_size* sizeof(hash_node*));
+    memset(hash_array, 0, hash_ar_size* sizeof(hash_node*));
+  }
+  int hash_key = hash_func_2(rgb);
+  hash_node* node = hash_array[hash_key],*tmp;
+  while (node){
+    if (node->rgb == rgb){
+      i = node->index;
+      local->colorval[i].ref++;
+      in_out->pixel = i;
+      return 1;
+    }
+    node = node->next;
+  }
+  tmp       = (hash_node*)malloc(sizeof(hash_node));
+  tmp->rgb  = rgb;
+  tmp->next = hash_array[hash_key];
+  hash_array[hash_key]  = tmp;
+  nxColorval* colors    = local->colorval;
+  colors[local->cur_color].value = (long)rgb; // save the value in last position
+  nxColorval min_color_val;
+  int min_dist_color  = 10000000;
+  int min_dist_idx    = -1,col_dist;
+  for (i = 0; ;i++){
+    if (colors->value == (long)rgb) {break;}
+    // FindBestMatch() working very slow...
+    // because we calculate a distinction between colors
+    col_dist = SQR(colors->r - r) + SQR(colors->g - g) + SQR(colors->b - b);
+    if (col_dist < min_dist_color){
+      min_dist_color = col_dist; // save minimal distinction
+      min_dist_idx = i;
+    }
+    colors++;
+  }
+  if (i < local->cur_color){ //if 'i' is not last value then we find the 'rgb'
+    local->colorval[i].ref++;
+    tmp->index = in_out->pixel = i;
+    return 1;
+  }
+  if (local->cur_color >= 256){
+    if (min_dist_idx == -1)//it's impossible...
+      return 0;
+    min_color_val = local->colorval[ min_dist_idx ];
+    in_out->red = min_color_val.r << 8;
+    in_out->green = min_color_val.g << 8;
+    in_out->blue = min_color_val.b << 8;
+
+    tmp->index = in_out->pixel = min_dist_idx;
+    return 1;
+  }
+  /* Otherwise allocate a new item */
+  if (i >= local->color_alloc){
+    nxColorval *cv = (nxColorval *)Xrealloc(local->colorval,
+      (local->color_alloc + 32) * sizeof(nxColorval));
+    if (!cv)
+      return 0;
+
+    local->colorval = cv;
+    local->color_alloc += 32;
+  }
+  tmp->index = in_out->pixel = local->cur_color;
+  i = local->cur_color++;
+  local->colorval[i].value = rgb;
+  local->colorval[i].r = local->colors[i].r = r;
+  local->colorval[i].g = local->colors[i].g = g;
+  local->colorval[i].b = local->colors[i].b = b;
+  local->colorval[i].ref = 1;
+  if (PIXEL_RGB32(r, g, b) == (BG_COLOR_RGB32 & 0xFFFFFF)){
+    local->colors[i].a = 0;
+  }else
+    local->colors[i].a = 255;
+
+  //save the colormap to hardware will be done via calling XFlushColormap()
+  return 1;
+}
+/*
+ * Local colormap functions to emulate X11 colormap scheme
+ */
+
+static nxColormap *colormap_hash[32];
+static int colormap_id = 1;
+static Colormap _defaultColormap = 0;
+
+static Colormap createColormap(int color_count)
+{
+	int val = (colormap_id - 1) % 32;
+	nxColormap *local = (nxColormap *)Xcalloc(sizeof(nxColormap), 1);
+
+	if (!local)
+		return 0;
+	local->id = colormap_id++;
+
+	if (color_count) {
+		/* The initial count of colors is simply a good suggestion.
+		 * It can grow / shrink
+		 */
+		local->colorval =
+			(nxColorval *)Xmalloc(color_count *
+						sizeof(nxColorval));
+
+		if (local->colorval) {
+			local->color_alloc = color_count;
+			local->cur_color = 0;
+			local->saved_color= 0;
+			memset(local->colors, 0, sizeof(local->colors));
+		}
+	}
+
+	if (!colormap_hash[val])
+		colormap_hash[val] = local;
+	else {
+		nxColormap *t = colormap_hash[val];
+		while (t->next)
+			t = t->next;
+		t->next = local;
+	}
+
+	return local->id;
+}
+
+#if LATER
+static void
+destroyColormap(Colormap id)
+{
+	int val = id % 32;
+	nxColormap *ptr, *prev;
+
+	for (ptr = colormap_hash[val], prev = 0; ptr;
+	     prev = ptr, ptr = ptr->next) {
+		if (ptr->id == id) {
+			if (prev)
+				prev->next = ptr->next;
+			else
+				colormap_hash[val] = ptr->next;
+
+			if (ptr->colorval)
+				Xfree(ptr->colorval);
+			Xfree(ptr);
+			return;
+		}
+	}
+}
+#endif
+
+nxColormap * _nxFindColormap(Colormap id)
+{
+	int val = (id - 1) % 32;
+	nxColormap *ptr = colormap_hash[val];
+
+	if (id == 0)
+		return 0;
+
+	for (ptr = colormap_hash[val]; ptr; ptr = ptr->next)
+		if (ptr->id == (long)id)
+			return ptr;
+
+	return 0;
+}
+
+/* Populate the colormap with the 32 system colors */
+Colormap _nxDefaultColormap(Display* display)
+{
+	XColor t;
+	Colormap cm;
+
+	if (_defaultColormap)
+		return _defaultColormap;
+
+/* nikita: add loading palette*/
+
+	cm = createColormap(256 + 1);
+#if 0	
+	IDirectFBPalette* pal;
+	surface->GetPalette(surface, &pal);
+	unsigned pal_size;
+	pal->GetSize(pal, &pal_size);
+	DFBColor col[256];
+	pal->GetEntries(pal, col, pal_size < 256 ? pal_size : 256 , 0);
+	pal->Release(pal);
+	int k = 0;
+	for (k = 0; k < pal_size; k++)
+	{
+		t.red = col[k].r << 8;
+		t.blue = col[k].b << 8;
+		t.green = col[k].g << 8; 
+		t.pixel = k;
+		if (k < 32)
+			printf("%d = (%x,%x,%x)\n", k, t.red, t.green, t.blue);
+		XAllocColor(surface, cm, &t);
+		if (k < 32)
+			printf("%d = (%x,%x,%x)\n", k, t.red, t.green, t.blue);
+	}
+#endif
+	/*
+	 * Note the following won't allocate a colormap entry
+	 * on truecolor hardware...
+	 */
+
+	/* Create the 0th index to have black */
+  	t.red = t.blue = t.green = 0 << 8; 
+	XAllocColor(display, cm, &t);
+
+	/* Create the 1st index to have white */
+	t.red = t.blue = t.green = 255 << 8;
+	XAllocColor(display, cm, &t);
+
+	_defaultColormap = cm;
+	
+	return cm;
+}
+
+/*
+ * Create a colormap.  We always use the default colormap
+ * for the time being.  Non-default visuals aren't supported either.
+ */
+Colormap XCreateColormap(Display * display, Window w, Visual * visual, int alloc)
+{
+	return _nxDefaultColormap(display);
+#if 0 // FIXME?
+	switch (visual->class) {
+	case DirectColor:
+		return createColormap(0);
+
+	case GrayScale:
+	case PseudoColor:
+		return createColormap(visual->map_entries);
+
+	case StaticGray:
+	case StaticColor:
+	case TrueColor:
+		if (alloc == AllocAll)
+			return 0;
+		return createColormap(visual->map_entries);
+	}
+
+	return 0;
+#endif
+}
+
+int XFreeColormap(GC gc, Colormap colormap)
+{
+#if 0 // FIXME?
+	destroyColormap(colormap);
+#endif
+	/*for(int i = 0; i< hash_ar_size;i++){ 
+				hash_node* node = hash_array[i],*tmp;
+    			if (node){
+    				do{
+    					tmp = node->next;
+    					free(node);
+    					node = 0;
+    					node = tmp;
+    				}while(node);
+    			}
+			}
+			free(hash_array);
+			hash_array = 0;*/
+	return 1;
+}
+
+/* convert an X11 pixelval to Microwindows colorval*/
+GR_COLOR _nxColorvalFromPixelval(Display* display, unsigned long pixelval)
+{
+	XColor c;
+
+	/* convert pixelval to colorval*/
+	c.pixel = pixelval;
+	XQueryColor(display, _nxDefaultColormap(display), &c);
+
+	return GR_RGB(c.red >> 8, c.green >> 8, c.blue >> 8);
+}
+
+static int
+queryColor(Display * display, nxColormap * local, XColor * def)
+{
+	if (def->pixel >= local->cur_color)
+		return 0;
+
+	_nxPixel2RGB(display, local->colorval[def->pixel].value, &def->red,
+		   &def->green, &def->blue);
+
+	def->flags |= (DoRed | DoGreen | DoBlue);
+	return 1;
+}
+
+int XQueryColor(Display* display, Colormap colormap, XColor * def)
+{
+	nxColormap *local;
+	int pix_f = pixel_format();
+	
+	if ((pix_f != DSPF_LUT8) && (pix_f != DSPF_ALUT44)) {
+		_nxPixel2RGB(display, def->pixel, &def->red, &def->green,
+			   &def->blue);
+		return 1;
+	}
+
+	if (!(local = _nxFindColormap(colormap)))
+		return 0;
+
+	return queryColor(display, local, def);
+}
+
+int XQueryColors(Display* display, Colormap colormap, XColor * def_in,
+	     int ncolors)
+{
+	nxColormap *local;
+	int i;
+	int pix_f = pixel_format();
+	
+	if ((pix_f != DSPF_LUT8) && (pix_f != DSPF_ALUT44)) {
+		for (i = 0; i < ncolors; i++)
+			_nxPixel2RGB(display, def_in[i].pixel, &def_in[i].red,
+				   &def_in[i].green, &def_in[i].blue);
+
+		return 1;
+	}
+
+	if (!(local = _nxFindColormap(colormap)))
+		return 0;
+
+	for (i = 0; i < ncolors; i++)
+		queryColor(display, local, &def_in[i]);
+
+	return 1;
+}
+
+#define ISBLANK(c)	((c) == ' ' || (c) == '\t')
+#define ISDIGIT(c)	((c) >= '0' && (c) <= '9')
+#define ISEOL(c)	((c) == '\r' || (c) == '\n')
+
+/* get next int from buffer, return next buf position*/
+static char *
+strInt(int *retint, char *buf)
+{
+	char *	q;
+	char	tmp[256];
+
+	while (ISBLANK(*buf))
+		++buf;
+	q = tmp;
+	while (ISDIGIT(*buf))
+		*q++ = *buf++;
+	*q = 0;
+	*retint = atoi(tmp);
+	return buf;
+}
+
+/* return string to end of line from buffer*/
+static void
+strEol(char *retbuf, char *buf)
+{
+	while (ISBLANK(*buf))
+		++buf;
+	while (!ISEOL(*buf))
+		*retbuf++ = *buf++;
+	*retbuf = 0;
+}
+
+GR_COLOR
+GrGetColorByName(char *colorname, int *retr, int *retg, int *retb)
+{
+	FILE *fp;
+	int r = 0, g = 0, b = 0;
+	char buf[256];
+
+	fp = fopen(X11_RGBTXT, "r");
+	if (!fp)
+		return 0;
+
+	while (fgets(buf, 256, fp) != NULL) {
+		if (buf[0] != '!') {
+			char *p;
+			char name[256];
+	
+			p = strInt(&r, buf);
+			p = strInt(&g, p);
+			p = strInt(&b, p);
+			strEol(name, p);
+
+			if (strcasecmp(name, colorname) == 0) {
+				if (retr)
+					*retr = r;
+				if (retg)
+					*retg = g;
+				if (retb)
+					*retb = b;
+				return GR_RGB(r, g, b);
+			}
+		}
+	}
+	fclose(fp);
+
+	return 0;
+}
+
+
+/* Parse colors of format:
+ * #RGB #RRGGBB #RRRGGGBBB  #RRRRGGGGBBBB
+ */
+static int
+_parseColorStr(_Xconst char **str, int size)
+{
+	char parse[5];
+	unsigned long val;
+
+	strncpy(parse, *str, size);
+	parse[size + 1] = '\0';
+	val = strtol(parse, 0, 16);
+	*str += size;
+	return (val);
+}
+
+Status
+XParseColor(Display * display, Colormap colormap, _Xconst char *spec,
+	XColor *exact)
+{
+	int r, g, b;
+
+	/* This is the new and preferred way */
+	if (strncmp(spec, "rgb:", 4) == 0) {
+		sscanf(spec + 4, "%x/%x/%x", &r, &g, &b);
+	} else {
+		if (spec[0] != '#') {
+			/* try to parse the color name */
+			if (GrGetColorByName((char *) spec, &r, &g, &b) == 0) {
+				printf("XParseColor: bad parse on %s\n", spec);
+				return 0;
+			}
+		} else {
+			_Xconst char *p = spec + 1;
+			unsigned long val;
+
+			switch (strlen(p)) {
+			case 3:
+				r = _parseColorStr(&p, 1);
+				g = _parseColorStr(&p, 1);
+				b = _parseColorStr(&p, 1);
+				break;
+
+			case 6:
+				val = strtol(p, 0, 16);
+				r = (val >> 16) & 0xFF;
+				g = (val >> 8) & 0xFF;
+				b = (val & 0xFF);
+				break;
+
+			case 12:	/* #RRRGGGBBB */
+				r = _parseColorStr(&p, 3);
+				g = _parseColorStr(&p, 3);
+				b = _parseColorStr(&p, 3);
+
+				if (r > 0xFF)
+					r >>= 4;
+				if (g > 0xFF)
+					g >>= 4;
+				if (b > 0xFF)
+					b >>= 4;
+
+				break;
+
+			default:
+				printf("XParseColor: invalid size %d on %s\n",
+				       (int)strlen(p), p);
+				return 0;
+			}
+		}
+	}
+
+	exact->red = r << 8;
+	exact->green = g << 8;
+	exact->blue = b << 8;
+	exact->flags |= (DoRed | DoGreen | DoBlue);
+
+	return 1;
+}
+
+Status
+XLookupColor(Display * display, Colormap colormap, _Xconst char *spec,
+	     XColor * exact, XColor * screen)
+{
+	Status stat = XParseColor(display, colormap, spec, exact);
+
+	if (!stat)
+		return stat;
+
+	/* FIXME:  Should do a system look up for the right color */
+	/* This will come back and haunt you on palettized machines */
+
+	screen->red = exact->red;
+	screen->green = exact->green;
+	screen->blue = exact->blue;
+
+	screen->flags |= (DoRed | DoGreen | DoBlue);
+
+	return stat;
+}
+
diff -Nwrup -x.git fltk-1.1.9/src/_draw.cxx FLTK_1.x-DirectFB/src/_draw.cxx
--- fltk-1.1.9/src/_draw.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/_draw.cxx	2009-11-28 15:48:05.984155335 -0500
@@ -0,0 +1,1592 @@
+//
+// "$Id: _draw.cxx,v 1.1 2006-11-02 08:53:35 nikego Exp $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+// Written by Nikita Egorov (nikego@gmail.com)
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains drawing code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+// 
+
+/*********************************************************************/
+/* those functions are defined in DirectFB's folder src/gfx/clip.h   */
+/* be careful - they are internal functions...                       */
+
+typedef enum {
+     DFEF_NONE      = 0x00000000,
+
+     DFEF_LEFT      = 0x00000001,
+     DFEF_RIGHT     = 0x00000002,
+     DFEF_TOP       = 0x00000004,
+     DFEF_BOTTOM    = 0x00000008,
+
+     DFEF_ALL       = 0x0000000F
+} DFBEdgeFlags;
+
+extern "C" DFBEdgeFlags dfb_clip_edges(const DFBRegion* clip, DFBRectangle* rect);
+
+extern "C" DFBBoolean   dfb_clip_line(const DFBRegion* clip, DFBRegion* line);
+
+/* DirectFB's folder src/gfx/convert.h   */
+
+#if (DIRECTFB_MAJOR_VERSION >= 1 && DIRECTFB_MINOR_VERSION >= 2)
+
+extern "C" unsigned long         dfb_pixel_from_color( DFBSurfacePixelFormat  format,
+                                            const DFBColor        *color );
+
+static u32 dfb_color_to_pixel( DFBSurfacePixelFormat format, u8 r, u8 g, u8 b )
+{
+     const DFBColor color = { 0, r, g, b };
+
+     return dfb_pixel_from_color( format, &color );
+}
+#else // VERSION 1.1.0
+
+extern "C" u32 dfb_color_to_pixel( DFBSurfacePixelFormat format, u8 r, u8 g, u8 b );
+
+#endif
+
+/*********************************************************************/
+/*
+ * A simple class to draw some stuff directly in memory  
+ */
+
+class direct_draw{
+    GC mgc;
+    uchar* mbuf,*mbm;
+    int mpixf;
+    int mpitch,mcolor,mw,mh,mbmw,mbpp;
+public: 
+    direct_draw(GC gc);
+    direct_draw(GC gc,uchar* bm);
+    virtual ~direct_draw();
+    void begin_draw(GC gc); 
+    void end_draw();
+    int getpixel(int,int) const;
+    void setpixel(int,int);
+    void setpixel(int x,int y,int color);
+    void setpixel(int x,int y,double br);
+    void setcolor(u8,u8,u8,u8);
+    void setrgb(int,int,int);
+    void setrow(int x,int y,int w);
+    void fillrow( int& left, int& right,int y,ulong border_color);
+    void fillrow(int& left, int& right,int y);
+    void setcol(int x,int y,int h);
+    void setbit(int x,int y);
+    int getbit(int x,int y);
+private:
+    void _setbit(int x,int y);
+    int _getbit(int x,int y);
+};
+
+//**************************************************************************
+void draw_line(GC ctx, DFBRegion *line);
+
+int
+dash(GC ctx)
+{
+  if(!ctx)
+    return 0;
+  int on = (ctx->dashmask & (1 << ctx->bit)) ? 1 : 0;
+  ctx->bit = (ctx->bit + 1) % ctx->dashcount;
+  return on;
+}
+
+void
+set_dash_style(GC ctx, u32 mask, u32 count)
+{
+  if (ctx)
+  {
+    ctx->dashmask  = mask;
+    ctx->dashcount = count;
+  }
+}
+
+void
+reset_dash(GC ctx)
+{
+  if (ctx)
+    ctx->bit = 0;
+}
+
+/******************************************************************
+ * overrided drawing functions
+ */
+void
+XDrawLine(Display* display, Drawable d, GC gc, int x1, int y1, int x2, int y2)
+{
+  GC ctx = ISGC(d);
+  if (!ctx)
+    ctx = gc;
+
+  if (ctx->dashmask != 0xFFFFFFFF && ctx->dashmask != 0){
+    DFBRegion line = {x1:x1, y1:y1, x2:x2, y2:y2};
+    draw_line(ctx, &line);
+  }else{
+    DFBCHECK(ctx->surface->DrawLine(ctx->surface, x1, y1, x2, y2));
+  }
+  update_region(ctx, x1, y1, x2, y2);
+}
+
+void 
+XDrawLines(Display* display, Drawable d, GC gc, Region points, int npoints, int mode)
+{
+  GC ctx = ISGC(d);
+  if (!ctx)
+    ctx = gc;
+  
+  int i;
+  DFBRegion* reg = points;
+  if (ctx->dashmask != 0xFFFFFFFF && ctx->dashmask != 0){
+    for (i = 0; i < npoints; i++){
+      draw_line(ctx, reg);
+      reg++;
+    }
+  }else{
+    DFBCHECK(ctx->surface->DrawLines(ctx->surface, points, npoints));
+  }
+  reg = points;
+  for (i = 0; i < npoints; i++)
+    update_region(ctx, reg++);
+}
+
+void
+XDrawRectangle(Display* display, Drawable d, GC gc, int x, int y, int width, int height)
+{
+  GC ctx = ISGC(d);
+  if (!ctx)
+    ctx = gc;
+
+  if (ctx->dashmask != 0xFFFFFFFF && ctx->dashmask != 0) {
+    direct_draw dd(ctx);
+    DFBRegion   clip;
+    reset_dash(ctx);
+    DFBRectangle rect = {x, y, width, height};
+    get_clip(ctx, &clip);
+    if (clip.x2 > clip.x1)
+      clip.x2--;//FIXME
+    if (clip.y2 > clip.y1)
+      clip.y2--;//FIXME
+
+    DFBEdgeFlags edge_flags = dfb_clip_edges(&clip, &rect);
+    if (edge_flags & DFEF_TOP)
+      dd.setrow(rect.x, rect.y, rect.w);
+
+    if (edge_flags & DFEF_RIGHT)
+      dd.setcol(rect.x + rect.w - 1, rect.y, rect.h);
+
+    if (edge_flags & DFEF_BOTTOM)
+      dd.setrow(rect.x + rect.w - 1, rect.y + rect.h, -rect.w);
+
+    if (edge_flags & DFEF_LEFT)
+      dd.setcol(rect.x, rect.y + rect.h - 1, -(rect.h));
+
+    dd.end_draw();
+    update_region(ctx, DFB_REGION_VALS_FROM_RECTANGLE(&rect));
+  }else{
+    DFBCHECK(ctx->surface->DrawRectangle(ctx->surface, x, y, ++width, ++height));
+    update_rect(ctx, x, y, width, height);
+  }
+}
+
+void
+XFillRectangle(Display* display, Drawable d, GC gc, int x, int y, int width, int height)
+{
+  GC ctx = ISGC(d);
+  if (!ctx)
+    ctx = gc;
+
+  DFBCHECK(ctx->surface->FillRectangle(ctx->surface, x, y, width, height));
+  update_rect(ctx, x, y, width, height);
+}
+
+//************************************************************************
+
+// fl_encoding variable defined in fl_font_directfb.cxx
+extern const char* fl_encoding;
+
+// I know 4 (four) incompatible encoding tables of cyrillic symbols...
+// The tables were taken from "unicode.org"
+
+static uint16_t cp1251_to_uni[256] ={\
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,\
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,\
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,\
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,\
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,\
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,\
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,\
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,\
+0x0402,0x0403,0x201A,0x0453,0x201E,0x2026,0x2020,0x2021,0x20AC,0x2030,0x0409,0x2039,0x040A,0x040C,0x040B,0x040F,\
+0x0452,0x2018,0x2019,0x201C,0x201D,0x2022,0x2013,0x2014,0x0000,0x2122,0x0459,0x203A,0x045A,0x045C,0x045B,0x045F,\
+0x00A0,0x040E,0x045E,0x0408,0x00A4,0x0490,0x00A6,0x00A7,0x0401,0x00A9,0x0404,0x00AB,0x00AC,0x00AD,0x00AE,0x0407,\
+0x00B0,0x00B1,0x0406,0x0456,0x0491,0x00B5,0x00B6,0x00B7,0x0451,0x2116,0x0454,0x00BB,0x0458,0x0405,0x0455,0x0457,\
+0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,\
+0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,\
+0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,\
+0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F};
+
+static uint16_t koi8r_to_uni[256] = {\
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,\
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,\
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,\
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,\
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,\
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,\
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,\
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,\
+0x2500,0x2502,0x250C,0x2510,0x2514,0x2518,0x251C,0x2524,0x252C,0x2534,0x253C,0x2580,0x2584,0x2588,0x258C,0x2590,\
+0x2591,0x2592,0x2593,0x2320,0x25A0,0x2219,0x221A,0x2248,0x2264,0x2265,0x00A0,0x2321,0x00B0,0x00B2,0x00B7,0x00F7,\
+0x2550,0x2551,0x2552,0x0451,0x2553,0x2554,0x2555,0x2556,0x2557,0x2558,0x2559,0x255A,0x255B,0x255C,0x255D,0x255E,\
+0x255F,0x2560,0x2561,0x0401,0x2562,0x2563,0x2564,0x2565,0x2566,0x2567,0x2568,0x2569,0x256A,0x256B,0x256C,0x00A9,\
+0x044E,0x0430,0x0431,0x0446,0x0434,0x0435,0x0444,0x0433,0x0445,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,\
+0x043F,0x044F,0x0440,0x0441,0x0442,0x0443,0x0436,0x0432,0x044C,0x044B,0x0437,0x0448,0x044D,0x0449,0x0447,0x044A,\
+0x042E,0x0410,0x0411,0x0426,0x0414,0x0415,0x0424,0x0413,0x0425,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,\
+0x041F,0x042F,0x0420,0x0421,0x0422,0x0423,0x0416,0x0412,0x042C,0x042B,0x0417,0x0428,0x042D,0x0429,0x0427,0x042A};
+
+static uint16_t iso88595_to_uni[256] = {\
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000A,0x000B,0x000C,0x000D,0x000E,0x000F,\
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001A,0x001B,0x001C,0x001D,0x001E,0x001F,\
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002A,0x002B,0x002C,0x002D,0x002E,0x002F,\
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003A,0x003B,0x003C,0x003D,0x003E,0x003F,\
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004A,0x004B,0x004C,0x004D,0x004E,0x004F,\
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005A,0x005B,0x005C,0x005D,0x005E,0x005F,\
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006A,0x006B,0x006C,0x006D,0x006E,0x006F,\
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007A,0x007B,0x007C,0x007D,0x007E,0x007F,\
+0x0080,0x0081,0x0082,0x0083,0x0084,0x0085,0x0086,0x0087,0x0088,0x0089,0x008A,0x008B,0x008C,0x008D,0x008E,0x008F,\
+0x0090,0x0091,0x0092,0x0093,0x0094,0x0095,0x0096,0x0097,0x0098,0x0099,0x009A,0x009B,0x009C,0x009D,0x009E,0x009F,\
+0x00A0,0x0401,0x0402,0x0403,0x0404,0x0405,0x0406,0x0407,0x0408,0x0409,0x040A,0x040B,0x040C,0x00AD,0x040E,0x040F,\
+0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041A,0x041B,0x041C,0x041D,0x041E,0x041F,\
+0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042A,0x042B,0x042C,0x042D,0x042E,0x042F,\
+0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043A,0x043B,0x043C,0x043D,0x043E,0x043F,\
+0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044A,0x044B,0x044C,0x044D,0x044E,0x044F,\
+0x2116,0x0451,0x0452,0x0453,0x0454,0x0455,0x0456,0x0457,0x0458,0x0459,0x045A,0x045B,0x045C,0x00A7,0x045E,0x045F};
+
+static uint16_t cp866_to_uni[256] = {\
+0x0000,0x0001,0x0002,0x0003,0x0004,0x0005,0x0006,0x0007,0x0008,0x0009,0x000a,0x000b,0x000c,0x000d,0x000e,0x000f,\
+0x0010,0x0011,0x0012,0x0013,0x0014,0x0015,0x0016,0x0017,0x0018,0x0019,0x001a,0x001b,0x001c,0x001d,0x001e,0x001f,\
+0x0020,0x0021,0x0022,0x0023,0x0024,0x0025,0x0026,0x0027,0x0028,0x0029,0x002a,0x002b,0x002c,0x002d,0x002e,0x002f,\
+0x0030,0x0031,0x0032,0x0033,0x0034,0x0035,0x0036,0x0037,0x0038,0x0039,0x003a,0x003b,0x003c,0x003d,0x003e,0x003f,\
+0x0040,0x0041,0x0042,0x0043,0x0044,0x0045,0x0046,0x0047,0x0048,0x0049,0x004a,0x004b,0x004c,0x004d,0x004e,0x004f,\
+0x0050,0x0051,0x0052,0x0053,0x0054,0x0055,0x0056,0x0057,0x0058,0x0059,0x005a,0x005b,0x005c,0x005d,0x005e,0x005f,\
+0x0060,0x0061,0x0062,0x0063,0x0064,0x0065,0x0066,0x0067,0x0068,0x0069,0x006a,0x006b,0x006c,0x006d,0x006e,0x006f,\
+0x0070,0x0071,0x0072,0x0073,0x0074,0x0075,0x0076,0x0077,0x0078,0x0079,0x007a,0x007b,0x007c,0x007d,0x007e,0x007f,\
+0x0410,0x0411,0x0412,0x0413,0x0414,0x0415,0x0416,0x0417,0x0418,0x0419,0x041a,0x041b,0x041c,0x041d,0x041e,0x041f,\
+0x0420,0x0421,0x0422,0x0423,0x0424,0x0425,0x0426,0x0427,0x0428,0x0429,0x042a,0x042b,0x042c,0x042d,0x042e,0x042f,\
+0x0430,0x0431,0x0432,0x0433,0x0434,0x0435,0x0436,0x0437,0x0438,0x0439,0x043a,0x043b,0x043c,0x043d,0x043e,0x043f,\
+0x2591,0x2592,0x2593,0x2502,0x2524,0x2561,0x2562,0x2556,0x2555,0x2563,0x2551,0x2557,0x255d,0x255c,0x255b,0x2510,\
+0x2514,0x2534,0x252c,0x251c,0x2500,0x253c,0x255e,0x255f,0x255a,0x2554,0x2569,0x2566,0x2560,0x2550,0x256c,0x2567,\
+0x2568,0x2564,0x2565,0x2559,0x2558,0x2552,0x2553,0x256b,0x256a,0x2518,0x250c,0x2588,0x2584,0x258c,0x2590,0x2580,\
+0x0440,0x0441,0x0442,0x0443,0x0444,0x0445,0x0446,0x0447,0x0448,0x0449,0x044a,0x044b,0x044c,0x044d,0x044e,0x044f,\
+0x0401,0x0451,0x0404,0x0454,0x0407,0x0457,0x040e,0x045e,0x00b0,0x2219,0x00b7,0x221a,0x2116,0x00a4,0x25a0,0x00a0};
+
+static inline uint16_t*
+get_charmap(const char* encoding)
+{
+  uint16_t* charmap = 0;
+  if (strcmp("koi8-r", encoding) == 0)
+    charmap = koi8r_to_uni;
+  else if (strcmp("cp1251", encoding) == 0)
+    charmap = cp1251_to_uni;
+  else if (strcmp("iso8859-5", encoding) == 0)
+    charmap = iso88595_to_uni;
+  else if (strcmp("cp866", encoding) == 0)
+    charmap = cp866_to_uni;
+
+  return charmap;
+}
+
+void draw_string(GC gc, const char* str, int n, int x, int y, DFBSurfaceTextFlags flags)
+{
+  uint16_t* charmap = get_charmap(fl_encoding);
+  if (!charmap) {
+    gc->surface->DrawString(gc->surface, str, n, x, y, flags);
+    return;
+  }
+  const char *ch = str;
+  int adv,p = n,_x = x;
+  IDirectFBFont *font = get_surface_font(gc);
+  for (ch = str; *ch && p--; ch++) {
+    unsigned int uni = charmap[(int)*ch];
+    gc->surface->DrawGlyph(gc->surface, uni, _x, y, DSTF_LEFT); 
+    font->GetGlyphExtents(font, uni, 0, &adv);
+    _x += adv;
+  }
+  font->Release(font);
+}
+
+void _GetStringExtents(IDirectFBFont*, const char*, int, DFBRectangle*, DFBRectangle*);
+
+#include <FL/fl_draw.H>
+
+//FIXME: unfortunelly, freetype library does not print cyrillic encodings
+//then I convert chars to UNICODE and draw the string glyph by glyph   
+
+void _GetStringExtents(IDirectFBFont *font, const char* text,int bytes,
+  DFBRectangle*   ret_logical_rect,
+  DFBRectangle*   ret_ink_rect)
+{
+  uint16_t* charmap = get_charmap(fl_encoding);
+  if (!charmap) {
+    font->GetStringExtents(font, text, bytes, ret_logical_rect, ret_ink_rect);
+    return;
+  }
+  const char *ch = text;
+  int w = 0, adv = 0, p = bytes, y2 = 0;
+  DFBRectangle rect;
+  DFBRectangle sum_rect = {0, 0, 0, 0};
+  for (ch = text; *ch && p--; ch++){
+    font->GetGlyphExtents(font, charmap[(int)*ch], &rect, &adv);
+    if (rect.h && (sum_rect.y > rect.y))
+      sum_rect.y = rect.y;
+    if (y2 < rect.y + rect.h)
+      y2 = rect.y + rect.h;
+    w += adv;
+  }
+  sum_rect.w = w;
+  sum_rect.h = y2 - sum_rect.y;
+  if (ret_ink_rect)
+    memcpy(ret_ink_rect, &sum_rect, sizeof(DFBRectangle));
+}
+
+void get_string_width(IDirectFBFont* font, const char* s, int n, int* width)
+{
+  if (!width)
+    return;
+  uint16_t* charmap = get_charmap(fl_encoding);
+  if (charmap){
+    const char *ch = s;
+    int w = 0,adv = 0;
+    for (ch = s; *ch && n--; ch++){
+      font->GetGlyphExtents(font, charmap[(int)*ch], 0, &adv);
+      w += adv;
+    }
+    *width = w;
+  }else
+    font->GetStringWidth(font, s, n, width);
+}
+
+/***********************************************************************************/
+
+//make mixed color 
+ulong
+average(ulong rgb1,ulong rgb2,double weight)
+{
+  ulong r = (uchar)(((uchar)(rgb1 >> 16)) * weight + ((uchar)(rgb2 >> 16)) * (1 - weight));
+  ulong g = (uchar)(((uchar)(rgb1 >>  8)) * weight + ((uchar)(rgb2 >>  8)) * (1 - weight));
+  ulong b = (uchar)(((uchar)(rgb1 >>  0)) * weight + ((uchar)(rgb2 >>  0)) * (1 - weight));
+  return (r << 16) | (g << 8) | b;
+}
+//make mixed color 
+ushort
+average(ushort rgb1, ushort rgb2, double weight)
+{
+  ushort r = (ushort)(RGB16_RED  (rgb1) * weight + RGB16_RED  (rgb2) * (1 - weight) + .5);
+  ushort g = (ushort)(RGB16_GREEN(rgb1) * weight + RGB16_GREEN(rgb2) * (1 - weight) + .5);
+  ushort b = (ushort)(RGB16_BLUE (rgb1) * weight + RGB16_BLUE (rgb2) * (1 - weight) + .5);
+  return PIXEL_RGB16(r, g ,b);
+}
+
+uchar
+average(uchar c1, uchar c2,double weight)
+{
+  uchar r1, r2, g1, g2, b1, b2;
+  get_rgb_color(c1, r1, g1, b1);
+  get_rgb_color(c2, r2, g2, b2);
+  ulong r = (uchar)(r1 * weight + r2 * (1 - weight));
+  ulong g = (uchar)(g1 * weight + g2 * (1 - weight));
+  ulong b = (uchar)(b1 * weight + b2 * (1 - weight));
+  return get_index_color(r, g, b);
+}
+
+/////////////////////////////////////////////////////////////////////////////////
+//implementation of class 'direct_draw'
+
+direct_draw::direct_draw(GC gc)
+{
+  begin_draw(gc);
+}
+
+direct_draw::direct_draw(GC gc, uchar* bm)
+{
+  begin_draw(gc);
+  mbm = bm;
+  mbmw = (mw + 7) / 8;
+}
+
+void direct_draw::begin_draw(GC gc)
+{
+  mgc = gc;
+  if (mgc){
+    mpixf = get_pixel_format(mgc);
+    mbpp = DFB_BYTES_PER_PIXEL(mpixf);
+    mbuf = (uchar*)lock_surface(mgc, DSLF_WRITE, &mpitch);
+    get_size(mgc, &mw, &mh);
+    mcolor = dfb_color_to_pixel((DFBSurfacePixelFormat)mpixf,mgc->r,mgc->g,mgc->b);
+  }
+  mbm=0;
+}
+
+void direct_draw::end_draw()
+{
+  if (mgc){
+    mgc->surface->Unlock(mgc->surface);
+      mgc=0;
+  }
+}
+
+direct_draw::~direct_draw()
+{
+  end_draw();
+}
+
+void direct_draw::setcolor(u8 r, u8 g, u8 b, u8 a)
+{
+  mcolor = dfb_color_to_pixel((DFBSurfacePixelFormat)mpixf, r, g, b);
+}
+
+int direct_draw::getpixel(int x, int y) const
+{
+  if (x >= 0 && y >= 0 &&  x <= mw && y <= mh){
+    switch (mbpp) {
+    case 1:
+      return ((uchar*)mbuf)[y * mpitch + x];
+        case 2:
+            return ((u16*)mbuf)[y * mpitch / 2 + x];
+    case 4:
+      return ((ulong*)mbuf)[y * mpitch / 4 + x];
+    }
+  }
+  return -1;
+}
+
+void direct_draw::setbit(int x,int y){
+  if (mbm){
+    uchar *pos=mbm + y*mbmw + x/8;
+    *pos |= 1<<(x&7);
+  }
+}
+
+int direct_draw::getbit(int x,int y){
+  if (mbm){
+    uchar *pos=mbm+y*mbmw + x/8;
+    return (*pos & (1<<(x&7)))!=0;
+  }
+  return 0;
+}
+
+void direct_draw::setpixel(int x, int y, double br)
+{
+  if (x >= 0 && y >= 0 && x <= mw && y <= mh){
+    switch (mbpp){
+    case 1: {
+      uchar *pos=mbuf+y*mpitch+x;
+      if (dash(mgc) /*&& PixInReg(mgc, x ,y)*/){
+        uchar col = average(mcolor, *pos, br);
+        *pos = col;
+        setbit(x,y);
+      }
+      break;
+    }
+    case 2: {
+      u16 *pos = &((u16*)mbuf)[y*mpitch/2 + x];
+      if (dash(mgc) /*&& PixInReg(mgc, x ,y)*/){
+        u16 col = average(mcolor, LOAD_U16_VO(pos), br);
+        STORE_U16_VO(pos, col);
+        setbit(x,y);
+      }
+      break;
+    }
+    case 4: {
+      ulong *pos = &((ulong*)mbuf)[y*mpitch/4 + x];
+      if (dash(mgc) /*&& PixInReg(mgc, x ,y)*/){
+        ulong col = average(mcolor, (ulong)LOAD_U32_VO(pos), br);
+        STORE_U32_VO(pos, col);
+        setbit(x,y);
+      }
+      break;
+    }
+    }
+  }
+}
+
+void direct_draw::setpixel(int x, int y)
+{
+  if (x >= 0 && y >= 0 &&  x <= mw && y <= mh) {
+    if (dash(mgc) /*&& PixInReg(mgc, x , y)*/) {
+      switch (mbpp) {
+      case 1: {
+        uchar *pos = &((uchar*)mbuf)[y*mpitch + x];
+        *pos = mcolor;
+        setbit(x,y);
+        break;
+      }
+      case 2: {
+        u16 *pos = &((u16*)mbuf)[y*mpitch/2 + x];
+        STORE_U16_VO(pos, mcolor);
+        setbit(x,y);
+        break;
+      }
+      case 4: {
+        ulong *pos = &((ulong*)mbuf)[y*mpitch/4 + x];//FIXME pitch measures in bytes or in pixels ?
+        STORE_U32_VO(pos, mcolor);
+        setbit(x,y);
+        break;
+      }
+      }
+    }
+  }
+}
+
+void direct_draw::setpixel(int x, int y, int color){
+  if (x >= 0 && y >= 0 &&  x <= mw && y <= mh){
+    if (dash(mgc) /*&& PixInReg(mgc, x , y)*/){
+      switch (mbpp) {
+      case 1: {
+        uchar *pos = &((uchar*)mbuf)[y*mpitch + x];
+        *pos = (uchar)color;
+        setbit(x,y);
+        break;
+      }
+      case 2:{
+        u16 *pos = &((u16*)mbuf)[y*mpitch/2 + x];
+        STORE_U16_VO(pos, color);
+        setbit(x,y);
+        break;
+      }
+      case 4:{
+        ulong *pos = &((ulong*)mbuf)[y*mpitch/4 + x];
+        STORE_U32_VO(pos, color);
+        setbit(x,y);
+        break;
+      }
+      }
+    }
+  }
+}
+/*
+void direct_draw::setrow_x2(int _x1, int _x2, int y){
+  
+  int x1=_x1, y1=y, x2=_x2, y2=y, d=1,x;
+  if (x1 > x2){
+    x2 = _x1;
+    x1 = _x2;
+    d=-1;
+  }
+    
+  if (d<0) x = x2;
+    else x = x1;
+    
+  int w = x2-x1+1;
+  if (mbpp==1) {  
+    uchar *pos = &((uchar*)mbuf)[y*mpitch + x];
+    for (int i = 0; i < w; i++){
+      if (dash())
+        *pos = mcolor;
+      pos+=d;
+    }
+  }else if (mbpp==4){
+    ulong *pos = &((ulong*)mbuf)[y*mpitch/4 + x];//FIXME pitch ?
+    for (int i = 0; i < w; i++){
+      if (dash())
+        *pos = mcolor;
+      pos+=d;
+    }
+  }
+}
+*/
+//fill row limited pixels with border_color
+void direct_draw::fillrow(int& left, int& right,int y,ulong border_color)
+{
+  if (mbpp==1){
+    uchar *pos = &((uchar*)mbuf)[y*mpitch+right];
+    uchar *pos2=pos;
+    do
+      *pos++ = mcolor;
+    while((*pos!=border_color)&&(++right<mw));
+    
+    while((*--pos2!=border_color)&&(--left>=0))
+      *pos2 = mcolor;
+  }else if (mbpp == 4){
+    ulong *pos = &((ulong*)mbuf)[y * mpitch / 4 + right];
+    ulong *pos2=pos;
+    do  *pos++ = mcolor; while((*pos != border_color)&&(++right<mw));
+    
+    while((*--pos2!=border_color)&&(--left>=0))  *pos2 = mcolor;
+  }
+}
+
+//fill row using bitmap 
+void direct_draw::fillrow(int& left, int& right, int y){//left==right !!!
+  if (!mbm)//it need bitmap
+    return;
+  uchar *bmpos=mbm+y*mbmw + right/8;
+  uchar *bmpos2=bmpos;
+  if (mbpp==1){  
+    uchar *pos = &((uchar*)mbuf)[y*mpitch + right];
+    uchar *pos2=pos;
+    do{
+      if (((right&7)==0)&&(*bmpos==0)&&(right+8<mw)){
+        memset(pos,mcolor,8);
+        *bmpos++=255;
+        right+=8;
+        pos+=8;
+        continue;
+      }else{
+        *pos++ = mcolor;
+        *bmpos |= 1<<(right&7);
+        if ((right&7)==7) bmpos++;
+        right++;
+      }
+    }while(!(*bmpos & (1<<(right&7)))&&right<mw);
+    
+    while(1){
+      if ((--left&7)==7){
+        bmpos2--;
+        if (*bmpos2==0 && left>=8){
+          *bmpos2 = 255;
+          left-=7;
+          pos2-=8;
+          memset(pos2,mcolor,8);
+          continue;
+        }
+      }
+      if (!(*bmpos2 & (1<<(left&7)))&&(left>=0)){
+        *(--pos2) = mcolor;
+        *bmpos2 |= 1<<(left&7);
+      }else
+        break;
+    }
+  }else if (mbpp==4){
+    ulong *pos = &((ulong*)mbuf)[y*mpitch/4 + right];
+    ulong *pos2=pos;
+    int i;
+    do{
+      if (((right&7)==0)&&(*bmpos==0)&&(right+8<mw)){
+        for (i=0;i<8;i++)*pos++=mcolor;
+        *bmpos++=255;
+        right+=8;
+        continue;
+      }else{
+        *pos++=mcolor;
+        *bmpos |= 1<<(right&7);
+        if ((right&7)==7) bmpos++;
+        right++;
+      }
+    }while(!(*bmpos & (1<<(right&7)))&&right<mw);
+    
+    while(1){
+      if ((--left&7)==7){
+        bmpos2--;
+        if (*bmpos2==0 && left>=8){
+          *bmpos2 = 255;
+          left-=7;
+          for (i=0;i<8;i++)*(--pos2)=mcolor;
+          continue;
+        }
+      }
+      if (!(*bmpos2 & (1<<(left&7)))&&(left>=0)){
+        *(--pos2) = mcolor;
+        *bmpos2 |= 1<<(left&7);
+      }else
+        break;
+    }
+  }
+}
+  
+void direct_draw::setrow(int x, int y, int w){
+      
+  int x1=x,x2=x+w+((w<0)?1:-1),/* y2=y, y1=y,*/ d=1;
+        
+  if (x2 > x1){
+    w=x2-x1+1;
+  }else{
+    w=x1-x2+1;
+    d=-1;
+  }
+  x = x1;
+  switch (mbpp){
+        case 1:{  
+      uchar *pos = &((uchar*)mbuf)[y*mpitch+x];
+      for (int i = 0; i < w; i++){
+        if (dash(mgc))
+          *pos = mcolor;
+        pos+=d;
+      }
+            break;
+        }
+        case 2:{
+            u16 *pos = &((u16*)mbuf)[y*mpitch/2 + x];
+            for (int i = 0; i < w; i++){
+                if (dash(mgc))
+                    STORE_U16_VO(pos, mcolor);
+                pos+=d;
+            }
+            break;
+        }
+        
+        case 4:{
+      ulong *pos = &((ulong*)mbuf)[y*mpitch/4 + x];
+      for (int i = 0; i < w; i++){
+        if (dash(mgc))
+          STORE_U32_VO(pos, mcolor);
+        pos+=d;
+      }
+            break;
+    }
+    }
+}
+
+void direct_draw::setcol(int x, int y, int h){
+  int /*x1=x,x2=x,*/ y1=y,  y2=y+h+((h<0)?1:-1),d=1;
+        
+  if (y2 > y1){
+    h=y2-y1+1;
+  }else{
+    h=y1-y2+1;
+    d=-1;
+  }
+  y=y1;
+  switch (mbpp) {
+       case 1:{  
+      uchar *pos = &((uchar*)mbuf)[y*mpitch + x];
+      int pitch = mpitch*d;
+      for (int i = 0; i<h; i++){
+        if (dash(mgc)) *pos = mcolor;
+        pos+=pitch;
+      }
+            break;
+    }
+        case 2:{
+            int pitch = mpitch/2;
+            u16 *pos = &((u16*)mbuf)[y*pitch + x];
+            pitch *= d;
+            for (int i = 0; i<h; i++){
+                if (dash(mgc))
+                    STORE_U16_VO(pos, mcolor);
+                pos+=pitch;
+            }
+            break;
+        }   
+        case 4:{
+      int pitch = mpitch/4;
+      ulong *pos = &((ulong*)mbuf)[y*pitch + x];
+      pitch *= d;
+      for (int i = 0; i<h; i++){
+        if (dash(mgc)) 
+                    STORE_U32_VO(pos, mcolor);
+        pos+=pitch;
+      }
+            break;
+    }  
+    }
+}
+
+//////////////////////////////////////////////////////////
+// draw simple line using the direct_draw class
+
+void draw_line(GC gc, DFBRegion *line){
+    int x,y,dx,dy,sx = 1,sy = 1,z,e,i;
+    bool ch;
+    
+    DFBRegion clip;
+    get_clip(gc, &clip);
+    if (!dfb_clip_line(&clip, line))
+        return;
+    
+    x = line->x1;
+    y = line->y1;
+    dx = line->x2 - line->x1;
+    dy = line->y2 - line->y1;
+    
+    if (dx < 0){
+        dx = -dx;sx = -1;
+    }
+    if (dy < 0){
+        dy = -dy;sy = -1;
+    }
+    direct_draw dd(gc);
+          
+    if (dx==0 && dy==0){//only one point
+        dd.setpixel(x, y);
+        dd.end_draw();
+        return;
+    }
+    if (dy == 0){//horizontal line
+     dd.setrow(sx>0 ? x :line->x2, y, dx);
+     dd.end_draw();
+     return;
+    }     
+    if (dx == 0){//vertical line
+     dd.setcol(x , sy>0 ? y :line->y2, dy);
+     dd.end_draw();
+     return;
+    }
+    if (dy>dx){
+        z = dx;dx = dy;dy = z;
+        ch = true;
+    } else{
+        ch = false;
+    }
+    e = 2*dy-dx;
+    i = 1;
+    do{
+        dd.setpixel(x, y);
+        while(e>=0){
+            if (ch){
+                x = x+sx;
+            }else{
+                y = y+sy;
+            }
+            e = e-2*dx;
+        }
+        if (ch){
+            y = y+sy;
+        }else{
+            x = x+sx;
+        }
+        e = e+2*dy;
+        i = i+1;
+    }
+    while(i<=dx);
+    dd.setpixel(x, y);
+    dd.end_draw();
+}
+
+#ifdef SMOOTH_DRAWING
+
+///////////////////////////////////////////////////////////////////////////
+// smooth and filter functions
+// objects to change....
+
+// masks for filtering 
+static int
+   Mask0[]= {1,1, 1,1 },  // 2 X 2
+   Mask1[]= {1,1,1, 1,1,1, 1,1,1 },//3 X 3
+   Mask2[]= {1,1,1, 1,2,1, 1,1,1 },//3 X 3
+   Mask3[]= {1,2,1, 2,4,2, 1,2,1 },//3 X 3
+   Mask4[]= {0,2,0, 2,4,2, 0,2,0 },//3 X 3
+   Mask5[]= {1,1,1,1,
+             1,1,1,1,
+             1,1,1,1,
+             1,1,1,1 },//4 X 4
+   Mask6[]= {1,2, 3, 4, 3,2,1,
+             2,4, 6, 8, 6,4,2,
+             3,6, 9,12, 9,6,5,
+             4,8,12,16,12,8,4,
+             3,6, 9,12, 9,6,5,
+             2,4, 6, 8, 6,4,2,
+             1,2, 3, 4, 3,2,1 },//7 X 7
+   Mask_ln[]= {2, 3, 3, 3, 3, 4, 7},    /* size of mask   */
+   Mask_vl[]= {4, 9,10,16,12,16,256},   /* sum of all items */
+   *Mask_bg[]={                         /* mask by index  */
+      Mask0,Mask1,Mask2,Mask3,Mask4,Mask5,Mask6
+   };
+
+
+#include <math.h>
+
+static double myfrac(double x){
+    return x-floor(x);
+}
+
+// draw smooth line
+void draw_smooth_line(GC gc, double x1, double y1, double x2, double y2){
+    double grad, xd, yd,xgap,xend,yend,yf,brightness1,brightness2;
+    int x;
+    int ix1;
+    int ix2;
+    int iy1;
+    int iy2;
+    bool wasexchange,invert=0;
+    double tmpreal;
+   
+    xd = x2-x1;
+    yd = y2-y1;
+    if (xd==0&&yd==0){
+        return;
+    }
+    if (fabs(xd)>fabs(yd)){
+        wasexchange = false;
+    }else{
+        wasexchange = true;
+        tmpreal = x1;x1 = y1;y1 = tmpreal;
+        tmpreal = x2;x2 = y2;y2 = tmpreal;
+        tmpreal = xd;xd = yd;yd = tmpreal;
+    }
+    if (x1>x2){
+        invert=1;
+        tmpreal = x1;x1 = x2;x2 = tmpreal;
+        tmpreal = y1;y1 = y2;y2 = tmpreal;
+        xd = x2-x1;
+        yd = y2-y1;
+    }
+    grad = yd/xd;
+    xend = floor(x1+0.5);
+    yend = y1+grad*(xend-x1);
+    xgap = 1-myfrac(x1+0.5);
+    ix1 = (int)floor(x1+0.5);
+    iy1 = (int)floor(yend);
+    brightness1 = (1-myfrac(yend))*xgap;
+    brightness2 = myfrac(yend)*xgap;
+    
+    direct_draw dd(gc);
+          
+    if (wasexchange){
+        dd.setpixel(iy1, ix1, brightness1);
+        dd.setpixel(iy1+1, ix1, brightness2);
+    }else{
+        dd.setpixel(ix1, iy1, brightness1);
+        dd.setpixel(ix1, iy1+1, brightness2);
+    }
+    yf = yend+grad;
+    xend = floor(x2+0.5);
+    yend = y2+grad*(xend-x2);
+    xgap = 1-myfrac(x2/*-0.5*/);
+    ix2 = (int)floor(x2+0.5);
+    iy2 = (int)floor(yend);
+    brightness1 = (1-myfrac(yend))*xgap;
+    brightness2 = myfrac(yend)*xgap;
+    if (wasexchange){
+        dd.setpixel(iy2, ix2, brightness1);
+        dd.setpixel(iy2+1, ix2, brightness2);
+    }else{
+        dd.setpixel(ix2, iy2, brightness1);
+        dd.setpixel(ix2, iy2+1, brightness2);
+    }
+    for (x = ix1+1; x <= ix2-1; x++){
+        brightness1 = 1-myfrac(yf);
+        brightness2 = myfrac(yf);
+        if (wasexchange){
+            dd.setpixel((int)floor(yf), x, brightness1);
+            dd.setpixel((int)floor(yf)+1, x, brightness2);
+        }else{
+            dd.setpixel(x, (int)floor(yf), brightness1);
+            dd.setpixel(x, (int)floor(yf)+1, brightness2);
+        }
+        yf = yf+grad;
+    }
+    dd.end_draw();
+}
+
+// draw smooth edge
+void draw_edge_(GC gc, double x1, double y1, double x2, double y2,uchar* bm,int fill){
+    double grad, xd, yd,xgap,xend,yend,yf,brightness1,brightness2;
+    int x,ix1,ix2,iy1,iy2;
+    bool wasexchange;
+    double tmpreal,vx1=x1,vy1=y1;
+    
+    static double prev_x2=0,prev_y2=0;
+    bool is_vertex=false;
+    
+  if ((x1 == prev_x2)&&(y1 == prev_y2))
+    is_vertex=true;
+  
+  prev_x2=x2;prev_y2=y2;
+     
+    xd = x2-x1;
+    yd = y2-y1;
+    if (xd==0&&yd==0){
+        return;
+    }
+    
+    if (fabs(xd)>fabs(yd)){
+        wasexchange = false;
+    }else{
+        wasexchange = true;
+        tmpreal = x1; x1 = y1;  y1 = tmpreal;
+        tmpreal = x2; x2 = y2;  y2 = tmpreal;
+        tmpreal = xd; xd = yd;  yd = tmpreal;
+  }
+  bool invert=false;
+  if (x1>x2){
+      tmpreal = x1;x1 = x2;x2 = tmpreal;
+        tmpreal = y1;y1 = y2;y2 = tmpreal;
+        xd = x2-x1;
+        yd = y2-y1;
+    }else{
+      invert=true;
+  }
+  if (!wasexchange)
+    invert = !invert;
+    
+    grad = yd/xd;
+    xend = floor(x1+.5);
+    yend = y1+grad*(xend-x1);
+    xgap = 1-myfrac(x1+.5);
+    ix1 = (int)floor(x1+.5);
+    iy1 = (int)floor(yend);
+
+     brightness1 = (1-myfrac(yend))*xgap;
+  brightness2 = myfrac(yend)*xgap;
+    
+  _TRACE("x1 %.2lf y1 %.2lf x2 %.2lf y2 %.2lf xd %.2lf yd %.2lf xend %.2lf yend %.2lf ix1 %d iy1 %d\n",x1,y1,x2,y2,xd,yd,xend,yend,ix1,iy1); 
+    direct_draw dd(gc,bm);
+    
+    if (wasexchange){
+      if (!invert)
+          dd.setpixel(iy1, ix1, brightness1);
+         if (invert)
+          dd.setpixel(iy1+1, ix1, brightness2);
+    }else{
+      if (!invert)
+          dd.setpixel(ix1, iy1, brightness1);
+        if (invert)  
+          dd.setpixel(ix1, iy1+1, brightness2);
+    }
+    //FIXME I put bit to stop a hole when it's needed
+    if (is_vertex){
+        int _x=(int)vx1,_y=(int)(vy1+.5);
+       if (vx1 > x1)
+         _x=(int)(vx1+1);
+       _TRACE(" _x %d, _y %d\n", _x,_y);  
+       if (!dd.getbit(_x-1,_y))
+         if (!dd.getbit(_x+1,_y))
+           if (!dd.getbit(_x,_y-1))
+             if (!dd.getbit(_x,_y+1))
+               dd.setbit(_x,_y);
+  }
+    yf = yend+grad;
+    xend = floor(x2+.5);
+    yend = y2+grad*(xend-x2);
+    xgap = 1-myfrac(x2-.5);
+    ix2 = (int)floor(x2+.5);
+    iy2 = (int)floor(yend);
+    brightness1 = (1-myfrac(yend))*xgap;
+    brightness2 = myfrac(yend)*xgap;
+    if (wasexchange){
+      if (!invert)
+          dd.setpixel(iy2, ix2, brightness1);
+        if (invert)  
+          dd.setpixel(iy2+1, ix2, brightness2);
+    }else{
+      if (!invert)
+          dd.setpixel(ix2, iy2, brightness1);
+        if (invert)
+          dd.setpixel(ix2, iy2+1, brightness2);
+    }
+    for (x = ix1+1; x<=ix2-1; x++){
+        brightness1 = 1-myfrac(yf);
+        brightness2 = myfrac(yf);
+        if (wasexchange){
+          if (!invert)
+              dd.setpixel((int)floor(yf),x,brightness1);
+            else  
+              dd.setpixel((int)floor(yf)+1, x, brightness2);
+        }else{
+          if (!invert)
+              dd.setpixel(x,(int)floor(yf),brightness1);
+            else  
+              dd.setpixel(x, (int)floor(yf)+1, brightness2);
+        }
+        yf = yf+grad;
+    }
+  dd.end_draw();
+}
+
+#if 0
+
+#define Pix_C 64
+//#define Pix_V 64 
+
+#define my_int(f)(f<.0)?(int)(f-.5):(int)(f+.5)
+
+// old function which takes an integer co-ordinates 
+void draw_edge(GC gc,float x1,float y1,float x2,float y2,uchar* bm,int fill){
+   float dx, dy;
+   int sx, sy,swap;
+   float incr1=0, incr2=0;
+   float E, kl;              /* current error  */
+   float Emax;          /* max error     */
+   float color_tek;      /* current color  */
+   int  xt;
+   if ((x1<x2 && y1<y2)||(x1>x2 && y1>y2)){
+       float tmp=x1;x1=x2;x2=tmp;
+       tmp=y1;y1=y2;y2=tmp;
+   }
+/* calc deltas and steps */
+  sx= 0;
+  if ((dx= (x2-x1))<0){dx=-dx;--sx;} else if (dx>0) ++sx;
+  sy= 0;
+  if ((dy= (y2-y1))<0){dy=-dy;--sy;} else if (dy>0) ++sy;
+/* check sloping */
+  swap= 0;
+  if ((kl=dx)<(E=dy)){dx=E; dy=kl; kl=E; ++swap;}
+    
+    float t= 0;
+    if (dx)
+     t= dy/dx;
+            
+  Emax= 1-t;
+    
+    E= 0.5-((1-myfrac(y1)) - t*myfrac(x1)); /* set error */
+    _TRACE("%.2lf %.2lf \n", myfrac(x1),myfrac(y1));
+                             
+//  s_max=incr2-incr1;    
+      
+  direct_draw dd(gc, bm);
+  color_tek = 1;         
+  if (dx)
+    color_tek=(dy/dx)/2;
+     
+  int xn=(int)(x1),yn=(int)(y1),xk=(int)(x2+.5),yk=(int)(y2+.5);
+    _TRACE("xn %d yn %d xk %d yk %d t %.4f E %.4f Emax %.4f\n",xn,yn,xk,yk,t,E,Emax);
+  dd.setpixel(xn, yn,color_tek);      /* first pixel */
+  if (swap && fill){
+    xt=xn;
+    if (xn < xk){
+         while(++xt <= xk) dd.setpixel(xt,yn,1.0);
+       }else{
+      while(--xt >= xk) dd.setpixel(xt,yn,1.0);
+      }
+   }
+    while(--kl >= 0){
+      if (E >= Emax) {
+         if (swap){
+            xn+= sx;
+            yn+= sy;
+        }else{
+            if (fill){ 
+             xt=xn;
+          if (xn < xk){while(++xt <= xk)dd.setpixel(xt,yn,1.0);}
+          else{while(--xt >= xk)dd.setpixel(xt,yn,1.0);}
+           }
+             yn+= sy;
+            xn+= sx;
+         }
+         E -= Emax;
+      }else{
+          if (swap)
+            yn+= sy;
+          else
+            xn+= sx;
+          
+          E += t;
+      }
+     //     color_tek= 1;
+          
+    //      if (dx) 
+         color_tek = E;
+                
+      if (swap)
+      dd.setpixel(xn,yn,1-color_tek);     /* current pixel */
+      else{
+      dd.setpixel(xn,yn,color_tek);     /* current pixel */
+        _TRACE("(%d %d) %.3f\n",xn,yn,E);
+      }
+    /* filling */
+     if (swap&&fill){
+             xt=xn;
+         if (xn < xk) {while(++xt <= xk) dd.setpixel(xt,yn,1.0);}
+         else {while(--xt >= xk) dd.setpixel(xt,yn,1.0);}
+        }
+   }
+}  /* draw_edge */
+
+void draw_edge(float x1,float y1,float x2,float y2){
+    draw_edge(fl_gc,x1,y1,x2,y2,0,1);
+}
+
+int _smooth = 0;
+
+void drawrow(GC gc,double x1,double x2,double y){
+  if (_smooth){
+     draw_smooth_line(gc,x1,y,x2,y);
+  }else{
+    gc->DrawLine(gc,(int)(x1+.5),(int)(y+.5),(int)(x2+.5),(int)(y+.5));
+  }
+}
+#endif
+
+void fl_filter_widget(Fl_Widget *wdg,int mask){
+  fl_filter_offscreen(fl_gc, wdg->x(), wdg->y(), wdg->w(), wdg->h(),mask);
+}
+
+/*-------------------------- fl_filter_offscreen */
+
+void fl_filter_offscreen(GC gc,int x,int y,int w,int h,int mask)
+{
+  
+   int  *pi;            
+   int  pixel;          
+   int  *cur_mask,         
+        mask_h,mask_w,  
+        x_center,y_center,
+        Mask_sum,Xk,Yk,             
+        s, sr, sg, sb,ii, jj,
+       Xt, Yt;
+       
+    if (!mask) return; // zero mask - do nothing
+    if (!gc) // if offscreen is NULL use current surface
+      gc=fl_gc;
+   cur_mask=  Mask_bg[--mask];            
+  mask_h= mask_w= Mask_ln[mask];    
+  x_center= mask_w / 2;
+  y_center= mask_h / 2;
+  Mask_sum= Mask_vl[mask];
+  //makes a small RGB surface 
+  GC surface = create_mem_gc(w,h,DSPF_RGB32);
+  DFBRectangle rect_d;
+  rect_d.x = x;rect_d.y = y;
+  rect_d.w = w;rect_d.h = h;
+  //copy the image and convert it to RGB if needed
+  blit(surface,gc,&rect_d,0,0); 
+  int pitch_d;
+  uchar *buffer = (uchar*)lock_surface(surface, DFBSurfaceLockFlags(DSLF_WRITE|DSLF_READ),&pitch_d);
+  uchar *src = (uchar*)Xmalloc(pitch_d*h); 
+  memcpy(src, buffer, pitch_d*h);
+
+/* maximal positions */
+  Xk= w-mask_w;
+  Yk= h-mask_h;
+
+  ulong *ppix = 0;
+  int ppix_inc = (pitch_d/4-mask_w);
+  for (Yt=0 /*y1_src*/; Yt<=Yk; ++Yt) {
+    for (Xt=0/*x1_src*/; Xt<=Xk; ++Xt) {
+      pi= cur_mask; sr=0; sg=0; sb=0;   /* RGB*/
+      ppix = &((ulong*)src)[Xt+Yt*pitch_d/4];
+      for (ii=0; ii<mask_h; ++ii){
+        for (jj=0; jj<mask_w; ++jj) {
+          pixel= *ppix++;
+                   s= *pi++; 
+                sr+= (s*((pixel>>16)&255));  
+                   sg+= (s*((pixel>>8)&255));   
+                   sb+= (s*((pixel)&255));      
+              }
+              ppix+=ppix_inc;
+           }
+           sr /= Mask_sum; sg /= Mask_sum; sb /= Mask_sum;
+      ii= PIXEL_RGB32(sr,sg,sb);
+      ((ulong*)buffer)[(/*x1_dst+*/(Xt/*-x1_src*/)+x_center) + (/*y1_dst+*/(Yt/*-y1_src*/)+y_center)*pitch_d/4]=ii;
+     }
+  }
+    unlock_surface(surface);
+     Xfree(src);
+  rect_d.x=rect_d.y=0;
+   blit(gc,surface,&rect_d,x,y);
+   release_gc(surface);
+}  /* V_fltr0 */
+
+/*----------------------------------------------------- V_FAST */
+
+#define MAX_GOR 2048  /* resolution by X */
+#define MAX_VER 2048  /* resolution by Y */
+#define MAX_STK 8192  /* size of stack */
+
+static int gor_max= MAX_GOR;
+static int ver_max= MAX_VER;
+static int stk_max= MAX_STK;
+static int *pi_stk, *pn_stk;   
+static int xtek, ytek;
+static int stklen;
+
+static direct_draw* _dd=0;
+
+/***********************************************************/
+static uchar *_bm=0;  //bitmap 
+static int _bm_w=0;    //width of bitmap in bytes
+
+inline bool getbit(int x,int y){
+  return  (bool)(*(_bm + y*_bm_w +x/8) & (1<<(x&7)));
+}
+
+inline void setbit(int x,int y){
+  *(_bm+y*_bm_w + x/8) |= (1<<(x&7));
+}
+
+inline void clearbit(int x,int y){
+    *(_bm+y*_bm_w + x/8) &= ~(1<<(x&7));
+}
+
+inline uchar getbyte(int x,int y){
+  return *(_bm+y*_bm_w+x/8);
+}
+
+inline void setbyte(int x,int y){
+  *(_bm+y*_bm_w+x/8)=255;
+}
+/************************************************************/
+
+/*---------------------------------------------------- Pop_Stk */
+static int  Pop_Stk (){
+  int  ret;
+  ret= 0;
+  if (pi_stk <= pn_stk) ++ret; else {
+    ytek= *--pi_stk;  xtek= *--pi_stk;
+  }
+  _TRACE("pop %d %d\n",xtek,ytek);
+  return (ret);
+}  /* Pop_Stk */
+
+/*--------------------------------------------------- Push_Stk */
+static int  Push_Stk (int x,int y){
+  int glu;
+  _TRACE("push %d %d\n",x,y);
+  if ((glu= pi_stk - pn_stk) >= stk_max) x= -1; else {
+    *pi_stk++= x;  *pi_stk++= y; x= 0;
+    if (glu > stklen) stklen= glu;
+  }
+  return (x);
+}  /* Push_Stk */
+
+static int Search (int yt,int left,int right,int border_color,int fill_color){
+  int x, ret,pix;
+  _TRACE(" search y=%d  left=%d, l= %d\n",yt,left,right-left);
+  ret= 0;
+    if (yt>=ver_max || yt<0)
+        return 0;
+  if (right>gor_max) right=gor_max;
+  while (left <= right) {
+    x=left;
+  /* find right pixel */
+    if (!_bm){
+      while((pix=_dd->getpixel(x,yt))!=border_color && pix!=fill_color && x<right)
+        ++x;
+      if (x != left) {          /* found */
+        ++ret;
+        if (x != right || pix == border_color || pix == fill_color) --x;
+        Push_Stk(x, yt);
+      }
+    }else{
+      while(!getbit(x,yt) && x<right){
+        while(((x&7)==0) && !getbyte(x,yt) && ((x+8)<right)) 
+          x+=8;  
+        x++;
+      }
+        if (x!=left){          /* found */
+        ++ret;
+        if (x!=right||getbit(x,yt))--x;
+        Push_Stk (x, yt);
+      }
+    }
+  /* continue scan line */
+    left=x;
+    if (!_bm){
+         while(((pix=_dd->getpixel(x,yt))==border_color||pix==fill_color) && x<right)
+             ++x;
+    }else{
+      while(getbit(x,yt) && x<right){
+        while(((x&7)==0) && (getbyte(x,yt)==255) && (x+8)<right) 
+          x+=8;
+         ++x;
+      }
+    }
+    if (x==left)++x;
+    left=x;
+  }
+  return (ret);
+}  /* Search */
+
+// forward declaration 
+int fill_(GC gc,int border_color,int fill_color,int x_isx,int y_isx,uchar* bm);
+
+// filling a figure limited with border_color 
+int fill(GC gc,int border_color,int fill_color,int start_x,int start_y){
+  return fill_(gc,border_color,fill_color,start_x,start_y,0);
+}
+//filling a figure using bitmask 
+int fill(GC gc,int fill_color,int start_x,int start_y,uchar* bm){
+  return fill_(gc,fill_color,fill_color,start_x,start_y,bm);
+}
+// main function of filling   
+int fill_(GC gc,int border_color,int fill_color,int x_isx,int y_isx,uchar* bm){
+  int  left,right,w,h;
+  int  ret=0;
+  
+     _bm=bm;
+  get_size(gc,&w,&h);
+     _bm_w=(w+7)/8;
+     
+  gor_max=w;
+  ver_max=h;
+       
+  ret= 0;
+/* stack init */
+  if ((pn_stk=(int *)Xmalloc(stk_max+1)) == NULL) {
+    --ret;  goto all;
+  }
+  pi_stk= pn_stk;
+
+  Push_Stk (x_isx, y_isx);     /*    */
+  _dd = new direct_draw(gc,bm);
+  _dd->setcolor(fill_color>>16, fill_color>>8, fill_color, fill_color>>24); 
+  
+/* cycle while stack is not empty */
+  while (pi_stk > pn_stk){
+
+/* load next position */
+    if (Pop_Stk ()) {ret=2; break; }
+    if ((xtek<0)||(xtek>w)||ytek<0||ytek>h)
+      break;
+      
+    left=right=xtek;   /* start position */
+    _TRACE("start x %d y %d\t", xtek,ytek);
+    if (!_bm)
+      _dd->fillrow(left,right,ytek,border_color);  
+        else
+      _dd->fillrow(left,right,ytek);
+          
+        _TRACE("left %d right %d\n",left,right);
+        --right;  
+    ++left;
+
+    /*search in next line*/
+    Search (++ytek, left, right, border_color, fill_color);
+
+      ytek-=2;
+      /*search in prev line*/
+    Search (ytek, left, right, border_color, fill_color);
+     }
+     Xfree (pn_stk);
+all:
+  _dd->end_draw();
+  delete _dd;
+  _dd=0;
+     return (ret);
+} /*end of fill_*/
+
+// for debug only
+void print_bitmap(uchar* bm,int w,int h){
+  int bw = (w+7)/8;
+    for (int i=0;i<h;i++){
+    for (int j=0;j<bw;j++){
+      uchar b=bm[i*bw+j];  
+      for (int l=0;l<8;l++)
+      if (b&(1<<l))TRACE("X");
+      else TRACE(" ");
+    }
+    TRACE("\n");
+  }
+}
+
+#include <FL/fl_draw.H>
+
+/* draw SIMPLE polygon with smooth edges 
+   outside edge lays on left hand side
+   it's needed to discribe points in clockwise direction
+   
+ 1          2
+  *--->-----* 
+  |######### \
+  |########## \
+  ^########### V
+  |############ \
+  |############# \
+  *-------<-------* 
+ 0                 3
+ 
+*/
+
+void SmoothPoly(GC gc, int count, POINT_f *pt){
+//    return;
+    int i,min_x=10000,min_y=10000,max_x=0,max_y=0,sw,sh,size,x,y;
+/* find borders of the polygon */
+    for (i=0; i<count;i++){
+      if (pt[i].x>max_x) max_x=(int)(pt[i].x+.5);
+      if (pt[i].x<min_x) min_x=(int)(pt[i].x);
+      if (pt[i].y>max_y) max_y=(int)(pt[i].y+.5);
+      if (pt[i].y<min_y) min_y=(int)(pt[i].y);
+    }
+    DFBRectangle rect;
+    rect.x=min_x;rect.y=min_y;rect.w=max_x-min_x+2;rect.h=max_y-min_y+2;
+    GC subs=0;
+/* clip the surface */
+  subs = create_gc(gc, &rect);
+    if (!subs) 
+        return;
+  get_size(subs,&sw,&sh);
+  size = sh*((sw+7)/8);
+/* allocate an empty bitmask */
+  uchar* bm = (uchar*)Xcalloc(size,1);
+/* draw the borders of polygon and create bitmask */
+    for (i=0; i<count;i++){
+        pt[i].x-=min_x;
+        pt[i].y-=min_y;
+        _TRACE("x %.1f y %.1f \n",pt[i].x,pt[i].y);
+    }
+  for (i=1;i<count;i++){
+      draw_edge_(subs,pt[i-1].x,pt[i-1].y,pt[i].x,pt[i].y,bm,0);
+  }
+/* draw border from last point to first one */
+  draw_edge_(subs,pt[i-1].x,pt[i-1].y,pt[0].x,pt[0].y,bm,0);
+    
+//     print_bitmap(bm,sw,sh);    
+    _bm = bm;
+    _bm_w=(sw+7)/8;
+    int in = 0,prev_bit=0,bit;
+    direct_draw dd(subs);
+/* scan bitmap and fill inner space of polygon*/
+    for (y=0;y<sh;y++){
+        in=0;prev_bit=0;
+        for (x=0;x<sw;x++){ 
+            bit=getbit(x,y);
+            if (bit!=prev_bit){
+                if (!bit){
+                    if (in&1)
+                       in++;
+                    else{    
+                        int _x;
+                        for (_x=x+1;_x<sw;_x++){
+                            if (_x&7==0){ 
+                                if (!getbyte(_x,y)){
+                                    _x+=7;
+                                    continue;
+                                }else{
+                                    in++;
+                                    break;
+                                }
+                            }
+                            if (getbit(_x,y)){ 
+                                in++;
+                                break;
+                            }
+                        }
+                    }
+                }
+            }
+            if (in&1){
+                if (!bit){
+                  //  if (y && getbit(x,y-1)){
+                        dd.setpixel(x,y);
+                        setbit(x,y);
+//                    }else
+//                        in--;
+                }
+                /*else clearbit(x,y);*/
+            }/*else clearbit(x,y);*/
+            prev_bit=bit;
+        }
+    }
+    dd.end_draw();
+//    print_bitmap(bm,sw,sh); 
+    _TRACE("XOR w %d h %d\n",sw,sh);     
+
+/* release bitmask and subsurface*/
+    Xfree(bm);
+  release_gc(subs);
+}
+
+#endif /* SMOOTH_DRAWING */
diff -Nwrup -x.git fltk-1.1.9/src/fl_arc.cxx FLTK_1.x-DirectFB/src/fl_arc.cxx
--- fltk-1.1.9/src/fl_arc.cxx	2006-08-23 10:43:07.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_arc.cxx	2009-11-28 15:48:05.987154275 -0500
@@ -39,7 +39,8 @@ static double _fl_hypot(double x, double
 }
 
 
-void fl_arc(double x, double y, double r, double start, double end) {
+void fl_arc(double x, double y, double r, double start, double end)
+{
 
   // draw start point accurately:
   
@@ -50,16 +51,19 @@ void fl_arc(double x, double y, double r
 
   // Maximum arc length to approximate with chord with error <= 0.125
   
-  double epsilon; {
+  double epsilon;
+  {
     double r1 = _fl_hypot(fl_transform_dx(r,0), // Horizontal "radius"
 		          fl_transform_dy(r,0));
     double r2 = _fl_hypot(fl_transform_dx(0,r), // Vertical "radius"
 		          fl_transform_dy(0,r));
 		      
-    if (r1 > r2) r1 = r2;		// r1 = minimum "radius"
-    if (r1 < 2.) r1 = 2.;		// radius for circa 9 chords/circle
+    if (r1 > r2)
+      r1 = r2; // r1 = minimum "radius"
+    if (r1 < 2.)
+      r1 = 2.; // radius for circa 9 chords/circle
     
-    epsilon = 2*acos(1.0 - 0.125/r1);	// Maximum arc angle
+    epsilon = 2*acos(1.0 - 0.125/16/r1); // Maximum arc angle
   }
   A = end*(M_PI/180) - A;		// Displacement angle (radians)
   int i = int(ceil(fabs(A)/epsilon));	// Segments in approximation
diff -Nwrup -x.git fltk-1.1.9/src/fl_arci.cxx FLTK_1.x-DirectFB/src/fl_arci.cxx
--- fltk-1.1.9/src/fl_arci.cxx	2006-10-10 21:23:52.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_arci.cxx	2009-11-28 15:48:05.987154275 -0500
@@ -43,6 +43,24 @@
 #ifdef __APPLE__
 #  include <config.h>
 #endif
+#ifdef DIRECTFB
+#include <FL/math.h>
+
+/*convert FLTK parameters to center, radius and begin/end coordinates */
+void ArcAngle(GC gc, int x,int y,int w,int h,double a1,double a2, int type ){
+  if ( a1 == a2 ) return;
+  int rx = w/2;
+  int ry = h/2;
+  int cx = x + rx;
+  int cy = y + ry;
+  int ax = (int)(w*cos(a1/180.0*M_PI))/2;
+  int ay = -(int)(h*sin(a1/180.0*M_PI))/2;
+  int bx = (int)(w*cos(a2/180.0*M_PI))/2;
+  int by = -(int)(h*sin(a2/180.0*M_PI))/2;
+  Arc(gc, cx, cy, rx, ry, ax, ay, bx, by, type);
+}
+#endif
+
 
 void fl_arc(int x,int y,int w,int h,double a1,double a2) {
   if (w <= 0 || h <= 0) return;
@@ -73,6 +91,8 @@ void fl_arc(int x,int y,int w,int h,doub
     CGContextAddArc(fl_gc, cx, cy, r, a1, a2, 1);
   }
   CGContextStrokePath(fl_gc);
+#elif defined ( DIRECTFB )
+  ArcAngle( fl_gc, x, y,w-1,h-1,a1,a2, ARC );
 #else
   XDrawArc(fl_display, fl_window, fl_gc, x,y,w-1,h-1, int(a1*64),int((a2-a1)*64));
 #endif
@@ -116,6 +136,8 @@ void fl_pie(int x,int y,int w,int h,doub
     CGContextClosePath(fl_gc);
   }
   CGContextFillPath(fl_gc);
+#elif defined ( DIRECTFB )
+  ArcAngle( fl_gc,x,y,w-1,h-1,a1,a2, PIE );
 #else
   XFillArc(fl_display, fl_window, fl_gc, x,y,w-1,h-1, int(a1*64),int((a2-a1)*64));
 #endif
diff -Nwrup -x.git fltk-1.1.9/src/Fl_arg.cxx FLTK_1.x-DirectFB/src/Fl_arg.cxx
--- fltk-1.1.9/src/Fl_arg.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_arg.cxx	2009-11-28 15:48:05.977154246 -0500
@@ -182,7 +182,7 @@ void Fl_Window::show(int argc, char **ar
 
   Fl::get_system_colors();
 
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
   // Get defaults for drag-n-drop and focus...
   const char *key = 0, *val;
 
@@ -204,7 +204,6 @@ void Fl_Window::show(int argc, char **ar
                              strcasecmp(val, "on") == 0 ||
                              strcasecmp(val, "yes") == 0);
 #endif // !WIN32 && !__APPLE__
-
   // set colors first, so background_pixel is correct:
   static char beenhere;
   if (!beenhere) {
@@ -226,7 +225,6 @@ void Fl_Window::show(int argc, char **ar
       resizable(r);
     }
   }
-
   // set the class, which is used by X version of get_system_colors:
   if (name) {xclass(name); name = 0;}
   else if (!xclass()) xclass(fl_filename_name(argv[0]));
@@ -242,7 +240,7 @@ void Fl_Window::show(int argc, char **ar
   // Show the window AFTER we have set the colors and scheme.
   show();
 
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
   // set the command string, used by state-saving window managers:
   int j;
   int n=0; for (j=0; j<argc; j++) n += strlen(argv[j])+1;
diff -Nwrup -x.git fltk-1.1.9/src/Fl_Bitmap.cxx FLTK_1.x-DirectFB/src/Fl_Bitmap.cxx
--- fltk-1.1.9/src/Fl_Bitmap.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_Bitmap.cxx	2009-11-28 15:48:05.959154914 -0500
@@ -218,12 +218,28 @@ Fl_Bitmask fl_create_bitmask(int w, int 
 void fl_delete_bitmask(Fl_Bitmask bm) {
   DeleteObject((HGDIOBJ)bm);
 }
+
+#elif defined (DIRECTFB)
+
+D_DEBUG_DOMAIN(FL_BITMAP_CXX, "FLTK/Fl_Bitmap", "FLTK Main");
+
+Fl_Bitmask fl_create_bitmask(int w, int h, const uchar *data) {
+  D_DEBUG_AT(FL_BITMAP_CXX, "%s(%d,%d)\n", __FUNCTION__, w, h);
+  return (Fl_Bitmask)XCreateBitmapFromData(fl_display, fl_window, (char *)data,
+                               (w+7)&-8, h);
+}
+void fl_delete_bitmask(Fl_Bitmask bm) {
+  D_DEBUG_AT(FL_BITMAP_CXX, "%s()\n", __FUNCTION__);
+	release_gc(((GC)bm)); 
+}
+	
 #else // X11 bitmask functions
+
 Fl_Bitmask fl_create_bitmask(int w, int h, const uchar *data) {
   return XCreateBitmapFromData(fl_display, fl_window, (const char *)data,
                                (w+7)&-8, h);
-}
 
+}
 void fl_delete_bitmask(Fl_Bitmask bm) {
   fl_delete_offscreen((Fl_Offscreen)bm);
 }
@@ -277,7 +293,7 @@ Fl_Bitmask fl_create_alphamask(int w, in
   SetPort(savePort);
   return gw;               /* tell caller we succeeded! */
 }
-#else
+#elif !defined(DIRECTFB)
 // Create a 1-bit mask used for alpha blending
 Fl_Bitmask fl_create_alphamask(int w, int h, int d, int ld, const uchar *array) {
   Fl_Bitmask mask;
@@ -352,6 +368,7 @@ Fl_Bitmask fl_create_alphamask(int w, in
 }
 #endif // __APPLE__
 
+
 void Fl_Bitmap::draw(int XP, int YP, int WP, int HP, int cx, int cy) {
   if (!array) {
     draw_empty(XP, YP);
@@ -401,6 +418,25 @@ void Fl_Bitmap::draw(int XP, int YP, int
     CGContextDrawImage(fl_gc, rect, (CGImageRef)id);
     Fl_X::q_end_image();
   }
+#elif defined(DIRECTFB)
+  if ( !id )
+    id = fl_create_bitmask( w(), h(), array );
+  // printf( "XP %d YP %d WP %d HP %d X %d Y %d W %d H %d cx %d cy %d\n",XP,YP,WP,HP,X,Y,W,H,cx,cy);
+  // int ox = X-cx; if (ox < 0) ox += w();
+  // int oy = Y-cy; if (oy < 0) oy += h();
+  DFBRectangle rect;
+  rect.x = cx;rect.y=cy;rect.w=W;rect.h=H;
+  uchar r,g,b;
+  get_rgb_color( fl_xpixel(fl_color()), r, g, b );
+
+  set_color( fl_gc, r, g, b, 255 );
+  set_blitting_flags( fl_gc, DSBLIT_COLORIZE | DSBLIT_BLEND_ALPHACHANNEL );
+  set_src_blend_function( (GC)id, DSBF_SRCALPHA );
+  set_dst_blend_function( fl_gc, DSBF_INVSRCALPHA );
+
+  blit( fl_gc, (GC)id, &rect, X, Y );
+  set_blitting_flags( fl_gc, DSBLIT_NOFX );
+        
 #else
   if (!id) id = fl_create_bitmask(w(), h(), array);
 
diff -Nwrup -x.git fltk-1.1.9/src/fl_color.cxx FLTK_1.x-DirectFB/src/fl_color.cxx
--- fltk-1.1.9/src/fl_color.cxx	2007-05-16 07:46:07.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_color.cxx	2009-11-28 15:48:05.988154291 -0500
@@ -26,6 +26,7 @@
 //
 
 // Implementation of fl_color(i), fl_color(r,g,b).
+#include <config.h>
 
 #ifdef WIN32
 #  include "fl_color_win32.cxx"
@@ -33,6 +34,8 @@
 #  include "fl_color_mac.cxx"
 #else
 
+#include <stdio.h>
+
 // Also code to look at the X visual and figure out the best way to turn
 // a color into a pixel value.
 
@@ -53,8 +56,10 @@ uchar fl_redmask, fl_greenmask, fl_bluem
 int fl_redshift, fl_greenshift, fl_blueshift, fl_extrashift;
 static uchar beenhere;
 
+
 static void figure_out_visual() {
   beenhere = 1;
+ 
   if (!fl_visual->red_mask || !fl_visual->green_mask || !fl_visual->blue_mask){
 #  if USE_COLORMAP
     fl_redmask = 0;
@@ -104,10 +109,19 @@ Colormap fl_overlay_colormap;
 XVisualInfo* fl_overlay_visual;
 ulong fl_transparent_pixel;
 #  else
-Fl_XColor fl_xmap[1][256];
+Fl_XColor fl_xmap[1][256]={{{0}}};
 #    define fl_overlay 0
 #  endif
 
+#ifdef DIRECTFB   
+void init_xcolormap(){
+  for( int i = 0; i< 56; i++ ){
+   fl_xpixel( (Fl_Color)i );
+  }
+}
+#endif   
+
+
 ////////////////////////////////////////////////////////////////
 // Get an rgb color.  This is easy for a truecolor visual.  For
 // colormapped it picks the closest color out of the cube in the
@@ -122,7 +136,9 @@ ulong fl_xpixel(uchar r,uchar g,uchar b)
     // find closest entry in the colormap:
     Fl_Color i =
       fl_color_cube(r*FL_NUM_RED/256,g*FL_NUM_GREEN/256,b*FL_NUM_BLUE/256);
+
     Fl_XColor &xmap = fl_xmap[fl_overlay][i];
+
     if (xmap.mapped) return xmap.pixel;
     // if not black or white, change the entry to be an exact match:
     if (i != FL_COLOR_CUBE && i != 0xFF)
@@ -139,7 +155,11 @@ ulong fl_xpixel(uchar r,uchar g,uchar b)
 
 void fl_color(uchar r,uchar g,uchar b) {
   fl_color_ = fl_rgb_color(r, g, b);
+#ifdef DIRECTFB
+  set_color(fl_gc, r, g, b, 255);
+#else
   XSetForeground(fl_display, fl_gc, fl_xpixel(r,g,b));
+#endif
 }
 
 ////////////////////////////////////////////////////////////////
@@ -223,7 +243,6 @@ ulong fl_xpixel(Fl_Color i) {
       xmap.b = xcol.blue>>8;
       return xmap.pixel = xcol.pixel;
     }
-
     // I only read the colormap once.  Again this is due to the slowness
     // of round-trips to the X server, even though other programs may alter
     // the colormap after this and make decisions here wrong.
@@ -244,6 +263,7 @@ ulong fl_xpixel(Fl_Color i) {
     if (fl_overlay && n == fl_transparent_pixel) continue;
 #    endif
     XColor &a = allcolors[n];
+
     int d, t;
     t = int(r)-int(a.red>>8); d = t*t;
     t = int(g)-int(a.green>>8); d += t*t;
@@ -338,7 +358,15 @@ void Fl::get_color(Fl_Color i, uchar &re
   green = uchar(c>>16);
   blue  = uchar(c>>8);
 }
-
+#ifdef DIRECTFB 
+Fl_Color get_color( ulong pixel ){
+  for( int i = 0; i< 255; i++ ) {
+    if ( fl_xmap[0][i].mapped && fl_xmap[0][i].pixel == pixel )
+      return (Fl_Color)i;
+  }
+  return (Fl_Color)0;
+}
+#endif
 Fl_Color fl_color_average(Fl_Color color1, Fl_Color color2, float weight) {
   unsigned rgb1;
   unsigned rgb2;
@@ -384,6 +412,8 @@ Fl_Color fl_contrast(Fl_Color fg, Fl_Col
   else return FL_WHITE;
 }
 
+
+
 //
 // End of "$Id: fl_color.cxx 5835 2007-05-16 11:46:07Z matt $".
 //
diff -Nwrup -x.git fltk-1.1.9/src/fl_cursor.cxx FLTK_1.x-DirectFB/src/fl_cursor.cxx
--- fltk-1.1.9/src/fl_cursor.cxx	2007-02-02 08:52:37.000000000 -0500
+++ FLTK_1.x-DirectFB/src/fl_cursor.cxx	2009-11-28 15:48:05.989153677 -0500
@@ -34,7 +34,7 @@
 #include <FL/Fl.H>
 #include <FL/Fl_Window.H>
 #include <FL/x.H>
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
 #  include <X11/cursorfont.h>
 #endif
 #include <FL/fl_draw.H>
@@ -44,7 +44,7 @@ void fl_cursor(Fl_Cursor c, Fl_Color fg,
 }
 
 void Fl_Window::default_cursor(Fl_Cursor c, Fl_Color fg, Fl_Color bg) {
-//  if (c == FL_CURSOR_DEFAULT) c = FL_CURSOR_ARROW;
+  if (c == FL_CURSOR_DEFAULT) c = FL_CURSOR_ARROW;
 
   cursor_default = c;
   cursor_fg      = fg;
@@ -238,6 +238,7 @@ void Fl_Window::cursor(Fl_Cursor c, Fl_C
 
 #else
 
+
 // I like the MSWindows resize cursors, so I duplicate them here:
 
 #define CURSORSIZE 16
@@ -284,14 +285,13 @@ static struct TableEntry {
 
 void Fl_Window::cursor(Fl_Cursor c, Fl_Color fg, Fl_Color bg) {
   if (!shown()) return;
-  Cursor xc;
+   Cursor xc= None;
   int deleteit = 0;
   if (c == FL_CURSOR_DEFAULT) {
     c  = cursor_default;
     fg = cursor_fg;
     bg = cursor_bg;
   }
-
   if (!c) {
     xc = None;
   } else {
@@ -324,6 +324,7 @@ void Fl_Window::cursor(Fl_Cursor c, Fl_C
     bgc.red = r<<8; bgc.green = g<<8; bgc.blue = b<<8;
     XRecolorCursor(fl_display, xc, &fgc, &bgc);
   }
+   	
   XDefineCursor(fl_display, fl_xid(this), xc);
   if (deleteit) XFreeCursor(fl_display, xc);
 }
diff -Nwrup -x.git fltk-1.1.9/src/Fl.cxx FLTK_1.x-DirectFB/src/Fl.cxx
--- fltk-1.1.9/src/Fl.cxx	2007-02-02 08:52:37.000000000 -0500
+++ FLTK_1.x-DirectFB/src/Fl.cxx	2009-11-28 15:48:05.958155693 -0500
@@ -378,6 +378,9 @@ double Fl::wait(double time_to_wait) {
 
 int Fl::run() {
   while (Fl_X::first) wait(FOREVER);
+#ifdef DIRECTFB
+	Fl_X::release();  
+#endif
   return 0;
 }
 
@@ -397,7 +400,6 @@ static Fl_Win32_At_Exit win32_at_exit;
 #endif
 
 
-
 int Fl::wait() {
   if (!Fl_X::first) return 0;
   wait(FOREVER);
@@ -659,6 +661,7 @@ extern Fl_Widget *fl_selection_requestor
 // FL_LEAVE or FL_UNFOCUS events to the widget.  This appears to not be
 // desirable behavior and caused flwm to crash.
 
+
 void fl_throw_focus(Fl_Widget *o) {
 #ifdef DEBUG
   printf("fl_throw_focus(o=%p)\n", o);
@@ -728,9 +731,12 @@ int Fl::handle(int e, Fl_Window* window)
 #ifdef DEBUG
     printf("Fl::handle(e=%d, window=%p);\n", e, window);
 #endif // DEBUG
-
     if (grab()) wi = grab();
-    else if (modal() && wi != modal()) return 0;
+    else if (modal() && wi != modal()
+#ifdef DIRECTFB
+	&& wi->parent() != modal()
+#endif    
+    ) return 0;
     pushed_ = wi;
     Fl_Tooltip::current(wi);
     if (send(e, wi, window)) return 1;
@@ -795,7 +801,6 @@ int Fl::handle(int e, Fl_Window* window)
     fl_xfocus = window;
     fl_fix_focus();
     return 1;
-
   case FL_KEYUP:
     // Send the key-up to the current focus. This is not 
     // always the same widget that received the corresponding
@@ -814,7 +819,6 @@ int Fl::handle(int e, Fl_Window* window)
 #ifdef DEBUG
     printf("Fl::handle(e=%d, window=%p);\n", e, window);
 #endif // DEBUG
-
     Fl_Tooltip::enter((Fl_Widget*)0);
 
     fl_xfocus = window; // this should not happen!  But maybe it does:
@@ -830,6 +834,7 @@ int Fl::handle(int e, Fl_Window* window)
     // changing the text and falling through to FL_SHORTCUT case:
     {unsigned char* c = (unsigned char*)event_text(); // cast away const
     if (!isalpha(*c)) return 0;
+		
     *c = isupper(*c) ? tolower(*c) : toupper(*c);}
     e_number = e = FL_SHORTCUT;
 
@@ -858,15 +863,14 @@ int Fl::handle(int e, Fl_Window* window)
       wi->do_callback();
       return 1;
     }
-
     return 0;
 
   case FL_ENTER:
 #ifdef DEBUG
     printf("Fl::handle(e=%d, window=%p);\n", e, window);
 #endif // DEBUG
-
     fl_xmousewin = window;
+    
     fl_fix_focus();
     Fl_Tooltip::enter(belowmouse());
     return 1;
@@ -943,7 +947,6 @@ void Fl_Window::hide() {
       wi = Fl_X::first;
     } else wi = wi->next;
   }
-
   if (this == Fl::modal_) { // we are closing the modal window, find next one:
     Fl_Window* W;
     for (W = Fl::first_window(); W; W = Fl::next_window(W))
@@ -954,7 +957,6 @@ void Fl_Window::hide() {
   // Make sure no events are sent to this window:
   fl_throw_focus(this);
   handle(FL_HIDE);
-
 #ifdef WIN32
   // this little trick keeps the current clipboard alive, even if we are about
   // to destroy the window that owns the selection.
@@ -997,6 +999,35 @@ void Fl_Window::hide() {
   MacDestroyWindow(this, ip->xid);
 #elif defined(__APPLE_QUARTZ__)
   MacDestroyWindow(this, ip->xid);
+#elif defined(DIRECTFB)
+  if ( !parent() ){
+    if ( ip->minimize() ){
+      ip->delete_icon();   
+    }
+    if ( ip->gc == ip->win_gc ){
+      release_gc( ip->gc );
+    }else{
+      release_gc( ip->gc );
+      release_gc( ip->win_gc );
+    }
+    extern dfbWindow grabbed_win;
+    if ( grabbed_win && grabbed_win == ip->_xid ){
+      grabbed_win->UngrabPointer( grabbed_win );
+      grabbed_win = 0;
+    }
+    extern Fl_X* focused;
+    extern Fl_X* wait_focus;
+    extern int switch_focus();
+    if (focused == ip)
+    {
+      wait_focus = Fl_X::first;
+      switch_focus();
+    }
+    ip->_xid->Destroy( ip->_xid );
+    release_window( ip->_xid );
+    ip->_xid = 0;
+  }else
+    release_gc( ip->gc );
 #else
 # if USE_XFT
   fl_destroy_xft_draw(ip->xid);
@@ -1070,6 +1101,7 @@ int Fl_Window::handle(int ev)
   return Fl_Group::handle(ev);
 }
 
+
 ////////////////////////////////////////////////////////////////
 // Back compatability cut & paste functions for fltk 1.1 only:
 
@@ -1185,6 +1217,10 @@ void Fl_Widget::damage(uchar fl, int X, 
       SetRectRgn(R, X, Y, X+W, Y+H);
       UnionRgn(R, i->region, i->region);
       DisposeRgn(R);
+#elif defined(DIRECTFB)
+      XRectangle R;
+      R.x = X; R.y = Y; R.w = W; R.h = H;
+      XUnionRectWithRegion(&R, i->region, i->region);
 #else
       XRectangle R;
       R.x = X; R.y = Y; R.width = W; R.height = H;
@@ -1212,6 +1248,8 @@ void Fl_Window::flush() {
 #  include "Fl_win32.cxx"
 #elif defined(__APPLE__)
 #  include "Fl_mac.cxx"
+#elif defined(DIRECTFB)
+#  include "Fl_directfb.cxx"
 #endif
 
 //
diff -Nwrup -x.git fltk-1.1.9/src/Fl_directfb.cxx FLTK_1.x-DirectFB/src/Fl_directfb.cxx
--- fltk-1.1.9/src/Fl_directfb.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/Fl_directfb.cxx	2009-11-28 15:48:05.978153905 -0500
@@ -0,0 +1,1891 @@
+//
+// "$Id: Fl_directfb.cxx,v 1.3 2006-10-31 09:31:14 nikego Exp $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+// Written by Nikita Egorov (nikego@gmail.com)
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains DirectFB-specific code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+
+
+#include <config.h>
+#include <FL/Fl.H>
+#include <FL/Fl_Window.H>
+#include <FL/x.H>
+#include <sys/unistd.h>
+#include <signal.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include "flstring.h"
+#include <unistd.h>
+#include <sys/time.h>
+
+D_DEBUG_DOMAIN(FL_DIRECTFB_CXX, "FLTK/Fl_DirectFB", "FLTK Main");
+
+IDirectFB*              fl_dfb = 0; 
+GC                      fl_screen = 0;
+IDirectFBDisplayLayer*  fl_display_layer = 0;
+GC                      fl_gc = 0;
+DFBInputDeviceID        keyboard_id = 0;
+DFBInputDeviceID        mouse_id = 0;
+
+static IDirectFBEventBuffer* event_buffer = 0; //I have only one event buffer for all windows 
+static int event_fd=-1;//
+
+bool lut_ = false;
+u32 pixf_ = DSPF_UNKNOWN;
+
+Colormap fl_colormap;
+VisualInfo visual;
+FL_EXPORT VisualInfo *fl_visual = &visual;
+ulong fl_event_time;
+
+char fl_show_iconic;	// hack for iconize()
+
+char fl_key_vector[32];
+
+int screen_width=0, screen_height=0;
+
+char last_dump_str[256];
+
+Fl_Cursor current_cursor = FL_CURSOR_DEFAULT;
+
+// stub
+void print_last_dump() {}
+
+ulong flip_size_sum = 0;
+
+#define FLIP_FLAGS (DFBSurfaceFlipFlags)(/*DSFLIP_WAIT |*/ DSFLIP_BLIT)
+
+// buffers flipping functions 
+void fl_flip(GC gc, Region reg) {
+  if (gc) {
+    int W,H;
+    get_size(gc, &W, &H);
+    if (reg) {
+      flip_size_sum += (reg->x2 - reg->x1+1) * (reg->y2 - reg->y1+1);
+    } else {
+      flip_size_sum += W * H;
+    }      
+    flip_gc(gc, reg, FLIP_FLAGS);
+  }
+}
+
+void post_id_event(DFBWindowID xid, DFBWindowEventType ev,int X, int Y,int cX=0,int cY=0) {
+  DFBEvent event;
+  event.clazz       = DFEC_WINDOW;
+  event.window.type = ev;
+  event.window.x    = X;
+  event.window.y    = Y;
+  event.window.cx   = cX;
+  event.window.cy   = cY;
+  event.window.window_id = xid;
+  event_buffer->PostEvent(event_buffer, &event);
+}
+
+static int _show_cursor = 1;
+
+void fl_show_cursor(int show) {
+  _show_cursor = show;
+  if (fl_display_layer){
+    D_DEBUG_AT(FL_DIRECTFB_CXX, "Cursor opacity = %d\n", show);
+    if (show){
+      set_cursor_opacity(fl_display_layer,255);
+    }else{
+      set_cursor_opacity(fl_display_layer,0);
+    }
+  }
+}
+
+void post_win_event(Window win,DFBWindowEventType ev,int X, int Y) {
+  post_id_event(win, ev, X, Y);
+}
+
+void post_win_event(Fl_Window* fl_win,DFBWindowEventType ev,int X, int Y,int cX, int cY) {
+  post_id_event(Fl_X::i(fl_win)->xid, ev, X, Y, cX, cY);
+}
+
+static inline int can_boxcheat(uchar b) { return (b == 1 || (b & 2) && b <= 15);}
+
+void Fl_Window::show() {
+  image(Fl::scheme_bg_);
+  if (Fl::scheme_bg_) {
+    labeltype(FL_NORMAL_LABEL);
+    align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE | FL_ALIGN_CLIP);
+  } else {
+    labeltype(FL_NO_LABEL);
+  }
+  if (!shown()) {
+    fl_open_display();
+    if (can_boxcheat(box())) fl_background_pixel = int(fl_xpixel(color()));
+    Fl_X::make_xid(this);
+  } else {
+    if (i->minimize()){
+      i->delete_icon();
+      redraw();
+      i->first_draw = 1;
+    }
+  }
+}
+
+Fl_Window*
+fl_find(dfbWindow _xid) {
+  Fl_X *window;
+  for (Fl_X **pp = &Fl_X::first; (window = *pp); pp = &window->next)
+    if (window->_xid == _xid) {
+      if (window != Fl_X::first && !Fl::modal()) {
+        // make this window be first to speed up searches
+        // this is not done if modal is true to avoid messing up modal stack
+        *pp = window->next;
+        window->next = Fl_X::first;
+        Fl_X::first = window;
+      }
+      return window->w;
+    }
+    return 0;
+}
+
+GC 
+find_gc(XID xid) {
+  Fl_X *window;
+  for (Fl_X **pp = &Fl_X::first;(window = *pp);pp = &window->next)
+    if (window->xid == xid) 
+      return window->gc;
+  return 0;
+}
+
+Window fl_window;
+Fl_Window *Fl_Window::current_;
+
+void Fl_Window::make_current() {
+  fl_window  = i->xid;
+  fl_gc      = i->gc;
+  current_   = this;
+  fl_clip_region(0);
+}
+
+// returns pointer to the filename, or null if name ends with '/'
+const char *fl_filename_name(const char *name) {
+  const char *p,*q;
+  if (!name) return (0);
+  for (p=q=name; *p;) if (*p++ == '/') q = p;
+  return q;
+}
+
+void Fl_Window::label(const char *name,const char *iname) {
+  Fl_Widget::label(name);
+  iconlabel_ = iname;
+}
+
+#  define CONSOLIDATE_MOTION 1
+/**** Define this if your keyboard lacks a backspace key... ****/
+/* #define BACKSPACE_HACK 1 */
+
+////////////////////////////////////////////////////////////////
+// interface to poll/select call:
+
+#  if USE_POLL
+#    include <poll.h>
+static pollfd *pollfds = 0;
+#  else
+#    if HAVE_SYS_SELECT_H
+#      include <sys/select.h>
+#    endif /* HAVE_SYS_SELECT_H */
+
+// The following #define is only needed for HP-UX 9.x and earlier:
+//#define select(a,b,c,d,e) select((a),(int *)(b),(int *)(c),(int *)(d),(e))
+
+static fd_set fdsets[3];
+static int maxfd;
+#    define POLLIN 1
+#    define POLLOUT 4
+#    define POLLERR 8
+
+#  endif /* USE_POLL */
+
+static int nfds = 0;
+static int fd_array_size = 0;
+struct FD {
+#  if !USE_POLL
+  int fd;
+  short events;
+#  endif
+  void (*cb)(int, void*);
+  void* arg;
+};
+
+static FD *fd = 0;
+
+void Fl::add_fd(int n, int events, void (*cb)(int, void*), void *v) {
+  remove_fd(n,events);
+  int i = nfds++;
+  if (i >= fd_array_size) {
+    FD *temp;
+    fd_array_size = 2 * fd_array_size + 1;
+
+    if (!fd) temp = (FD*)malloc(fd_array_size * sizeof(FD));
+    else temp = (FD*)realloc(fd, fd_array_size * sizeof(FD));
+
+    if (!temp) return;
+    fd = temp;
+
+#  if USE_POLL
+    pollfd *tpoll;
+
+    if (!pollfds) tpoll = (pollfd*)malloc(fd_array_size * sizeof(pollfd));
+    else tpoll = (pollfd*)realloc(pollfds, fd_array_size * sizeof(pollfd));
+
+    if (!tpoll) return;
+    pollfds = tpoll;
+#  endif
+  }
+  fd[i].cb = cb;
+  fd[i].arg = v;
+#  if USE_POLL
+  pollfds[i].fd = n;
+  pollfds[i].events = events;
+#  else
+  fd[i].fd = n;
+  fd[i].events = events;
+  if (events & POLLIN) FD_SET(n, &fdsets[0]);
+  if (events & POLLOUT) FD_SET(n, &fdsets[1]);
+  if (events & POLLERR) FD_SET(n, &fdsets[2]);
+  if (n > maxfd) maxfd = n;
+#  endif
+}
+
+void Fl::add_fd(int n, void (*cb)(int, void*), void* v) {
+  Fl::add_fd(n, POLLIN, cb, v);
+}
+
+void Fl::remove_fd(int n, int events) {
+  int i,j;
+  maxfd = -1; // recalculate maxfd on the fly
+  for (i=j=0; i<nfds; i++) {
+#  if USE_POLL
+    if (pollfds[i].fd == n) {
+      int e = pollfds[i].events & ~events;
+      if (!e) continue; // if no events left, delete this fd
+      pollfds[j].events = e;
+    }
+#  else
+    if (fd[i].fd == n) {
+      int e = fd[i].events & ~events;
+      if (!e) continue; // if no events left, delete this fd
+      fd[i].events = e;
+    }
+#  endif
+    if (fd[i].fd > maxfd) maxfd = fd[i].fd;
+    // move it down in the array if necessary:
+    if (j<i) {
+      fd[j] = fd[i];
+#  if USE_POLL
+      pollfds[j] = pollfds[i];
+#  endif
+    }
+    j++;
+  }
+  nfds = j;
+#  if !USE_POLL
+  if (events & POLLIN) FD_CLR(n, &fdsets[0]);
+  if (events & POLLOUT) FD_CLR(n, &fdsets[1]);
+  if (events & POLLERR) FD_CLR(n, &fdsets[2]);
+#  endif
+}
+
+void Fl::remove_fd(int n) {
+  remove_fd(n, -1);
+}
+
+int grabbed=0;
+int startx,endx;
+int starty,endy;
+int new_W=0,new_H=0;
+IDirectFBWindow *grabbed_win=0;
+int on_border = 0;
+Fl_Window *resized_win=0;
+Fl_Window* resize_bug_fix = 0;
+
+#if CONSOLIDATE_MOTION
+static Fl_Window* send_motion;
+extern Fl_Window* fl_xmousewin;
+#endif
+static bool in_a_window; // true if in any of our windows, even destroyed ones
+static void do_queued_events() {
+  in_a_window = true;
+  DFBEvent event;
+  fd_set readset;
+  FD_ZERO(&readset);
+  FD_SET(event_fd, &readset);
+  struct timeval tv={0};//timeout is zero
+  while(select(event_fd+1,&readset,NULL,NULL,&tv)>0){ //check for data
+    if (read(event_fd,&event,sizeof(DFBEvent))>0)   //read an event
+      fl_handle((const DFBWindowEvent&)event);    //handle the event
+  }
+  // we send FL_LEAVE only if the mouse did not enter some other window:
+  if (!in_a_window) Fl::handle(FL_LEAVE, 0);
+#if CONSOLIDATE_MOTION
+  else if (send_motion == fl_xmousewin) {
+    send_motion = 0;
+    Fl::handle(FL_MOVE, fl_xmousewin);
+  }
+#endif
+  if (grabbed&&(grabbed_win||resized_win)) {
+    if (startx != endx || starty != endy){
+      if (!on_border) {
+        if (grabbed_win)
+          grabbed_win->Move(grabbed_win,endx-startx,endy-starty);
+        startx = endx;
+        starty = endy;
+      } else 
+        if (resized_win) {
+          int W = resized_win->w()+endx-startx;
+          int H = resized_win->h()+endy-starty;
+          Fl_X* xw=Fl_X::i(resized_win);
+          int limitw=0,limith=0; 
+          if (xw->minw && W<xw->minw){W=xw->minw;limitw=1;}
+          if (xw->minh && H<xw->minh){H=xw->minh;limith=1;}
+          if (xw->maxw && W>xw->maxw){W=xw->maxw;limitw=1;}
+          if (xw->maxh && H>xw->maxh){H=xw->maxh;limith=1;} 
+          resized_win->size(W, H);
+          if (!limitw)startx=endx;
+          if (!limith)starty=endy;
+        }
+    }
+  }
+}
+
+// these pointers are set by the Fl::lock() function:
+static void nothing() {}
+void (*fl_lock_function)() = nothing;
+void (*fl_unlock_function)() = nothing;
+
+// This is never called with time_to_wait < 0.0:
+// It should return negative on error, 0 if nothing happens before
+// timeout, and >0 if any callbacks were done.
+int fl_wait(double time_to_wait) {
+
+#  if !USE_POLL
+  fd_set fdt[3];
+  fdt[0] = fdsets[0];
+  fdt[1] = fdsets[1];
+  fdt[2] = fdsets[2];
+#  endif
+  int n;
+
+  fl_unlock_function();
+
+  if (time_to_wait < 2147483.648) {
+#  if USE_POLL
+    n = ::poll(pollfds, nfds, int(time_to_wait*1000 + .5));
+#  else
+    timeval t;
+    t.tv_sec = int(time_to_wait);
+    t.tv_usec = int(1000000 * (time_to_wait-t.tv_sec));
+    n = ::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],&t);
+#  endif
+  } else {
+#  if USE_POLL
+    n = ::poll(pollfds, nfds, -1);
+#  else
+    n = ::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],0);
+#  endif
+  }
+
+  fl_lock_function();
+
+  if (n > 0) {
+    for (int i=0; i<nfds; i++) {
+#  if USE_POLL
+      if (pollfds[i].revents) fd[i].cb(pollfds[i].fd, fd[i].arg);
+#  else
+      int f = fd[i].fd;
+      short revents = 0;
+      if (FD_ISSET(f,&fdt[0])) revents |= POLLIN;
+      if (FD_ISSET(f,&fdt[1])) revents |= POLLOUT;
+      if (FD_ISSET(f,&fdt[2])) revents |= POLLERR;
+      if (fd[i].events & revents) fd[i].cb(f, fd[i].arg);
+#  endif
+    }
+  }
+  return n;
+}
+
+// fl_ready() is just like fl_wait(0.0) except no callbacks are done:
+int fl_ready() {
+#  if USE_POLL
+  return ::poll(pollfds, nfds, 0);
+#  else
+  timeval t;
+  t.tv_sec = 0;
+  t.tv_usec = 0;
+  fd_set fdt[3];
+  fdt[0] = fdsets[0];
+  fdt[1] = fdsets[1];
+  fdt[2] = fdsets[2];
+  return ::select(maxfd+1,&fdt[0],&fdt[1],&fdt[2],&t);
+#  endif
+}
+
+static void fd_callback(int dfd,void *) {
+  do_queued_events();
+}
+extern int id2fltk(int id);
+
+static int px, py;
+static ulong ptime;
+
+static void set_event_xy(DFBWindowEvent& xevent) {
+#  if CONSOLIDATE_MOTION
+  send_motion = 0;
+#  endif
+  Fl::e_x_root  = xevent.cx;
+  Fl::e_x       = xevent.x;
+  Fl::e_y_root  = xevent.cy;
+  Fl::e_y       = xevent.y;
+  //Fl::e_state   = xevent.buttons << 24;
+  fl_event_time = xevent.timestamp.tv_sec*1000 + xevent.timestamp.tv_usec / 1000;
+#  ifdef __sgi
+  // get the meta key off PC keyboards:
+  if (fl_key_vector[18]&0x18) Fl::e_state |= FL_META;
+#  endif
+  if (xevent.button == DIBI_RIGHT){
+    xevent.button = DIBI_MIDDLE;
+    if (xevent.type == DWET_BUTTONDOWN){ 
+      xevent.buttons =(DFBInputDeviceButtonMask)(((int)xevent.buttons & ~((int)DIBM_RIGHT))|((int)DIBM_MIDDLE));
+    }
+  }else if (xevent.button ==DIBI_MIDDLE){
+    xevent.button = DIBI_RIGHT;
+    if (xevent.type == DWET_BUTTONDOWN){ 
+      xevent.buttons =(DFBInputDeviceButtonMask)(((int)xevent.buttons & ~((int)DIBM_MIDDLE)) | ((int)DIBM_RIGHT));
+    }
+  }
+  // turn off is_click if enough time or mouse movement has passed: DIBI_LEFT 
+  if (abs(Fl::e_x_root-px)+abs(Fl::e_y_root-py) > 3 ||
+    fl_event_time >= ptime+1000)
+    Fl::e_is_click = 0;
+}
+
+const int WHEADER_H = 30;//height of window's header
+const int WBORDER_W = 2;//width of border
+const int WBORDER_H = 2;//height of border
+
+//the function returns state of cursor position
+// state is one of followed values:
+// -1- outside the window
+// 0 - inside the window out of border
+// 1 - vertical border
+// 2 - horizontal border
+// 3 - both (right-bottom corner)
+int is_on_border(Fl_Window* window, int x, int y) {
+  dfbWindow w = Fl_X::i(window)->_xid;
+  int W,H,X,Y,ret = -1;
+  get_size(w, &W, &H);
+  get_position(w, &X, &Y);
+
+  if (x >= X && x < X + W && y >= Y && y < Y + H)
+  {
+    ret = 0;
+    if ((x >= X + W - WBORDER_W - 1) && (x <= X + W) && (y <= Y + H) && (y >= Y)){
+      ret |= 1;
+      if (y >= Y + H - 10)
+        ret |= 2;
+    }
+    if ((y >= Y + H - WBORDER_H - 1) && (y <= Y + H) && (x <= X + W) && (x > X)){
+      ret |= 2;
+      if (x >= X + W - 10)
+        ret |= 1;
+    }
+  }
+  return ret;	
+}
+
+Fl_Window* check_event_pos(DFBWindowEvent& xevent) {
+  Fl_Window* window = fl_find(xevent.window_id);
+  Fl_Window* header = 0;
+  static Cursor saved_cursor = 0;
+  if (!window)
+    return 0;
+  if (window->border()){
+    int win_x = window->x(),maximize=Fl_X::i(window)->maximize();
+    header = Fl_X::i(window)->header;
+    //check for window border (need resize ?)
+    if (window->resizable()){
+      if (header && !header->child(2)->active())
+        header->child(2)->activate();
+      int b = is_on_border(window,xevent.cx,xevent.cy); 
+      if ((b!=on_border)&&!grabbed&&!(Fl::e_state&(0xF<<24))){
+        if (b){
+          //FIXME: this cursors' code is object to change
+          if (!saved_cursor) { 
+            saved_cursor = Fl_X::i(window)->cursors[1] ? : Fl_X::i(window)->cursors[0];
+          }
+          if (on_border!=0)//free cursor if previous state is "on border"
+            XDefineCursor(fl_display, Fl_X::i(window)->xid, 0);
+
+          switch (b) {
+              case 1:	fl_cursor(FL_CURSOR_WE);break;
+              case 2:	fl_cursor(FL_CURSOR_NS);break;
+              case 3:	fl_cursor(FL_CURSOR_NWSE);break;
+          }
+          grabbed_win=Fl_X::i(window)->_xid;
+          grabbed_win->GrabPointer(grabbed_win);
+        }else{
+          if (xevent.type == DWET_LOSTFOCUS || xevent.type == DWET_LEAVE) {
+            XDefineCursor(fl_display, Fl_X::i(window)->xid, 0);
+          } else {
+            XDefineCursor(fl_display, Fl_X::i(window)->xid, saved_cursor);
+            saved_cursor = 0;
+          }
+          if (grabbed_win){	
+            grabbed_win->UngrabPointer(grabbed_win);
+            grabbed_win=0;
+          }
+          grabbed=0;
+        }
+        on_border = b;
+      }
+    }else{
+      if (header && header->child(2)->active())
+        header->child(2)->deactivate();
+    }
+    //start resizing if user press left mouse button on the border
+    if (on_border&&(!maximize)&&!grabbed&&(xevent.type==DWET_BUTTONDOWN)&&(xevent.button==DIBI_LEFT)){
+      resized_win=window;
+      grabbed=1;
+      endx=startx=xevent.cx;
+      endy=starty=xevent.cy;
+    }
+    if ((xevent.y > 0) && (xevent.y < WHEADER_H) && !(Fl::e_state&(0xF<<24))){//check for header's place
+      if (header){ //if header is present
+        if  (Fl::pushed()){Fl::handle(FL_RELEASE, window);}
+        xevent.x = xevent.cx+WBORDER_W;// restore correct xy value for header
+        xevent.y = xevent.cy+WHEADER_H;
+        window = header;// change the current window to the header
+        //start to drag the window when user press the left button on the header
+        if ((!maximize)&&(xevent.type==DWET_BUTTONDOWN)){
+          if (xevent.x<win_x+header->w()-((WHEADER_H-5)+2)*3){//avoid buttons place
+            if (!grabbed && (xevent.button==DIBI_LEFT)){
+              endx=startx=xevent.cx;
+              endy=starty=xevent.cy;
+              grabbed_win = Fl_X::i(window)->_xid;
+              grabbed_win->GrabPointer(grabbed_win);
+              grabbed=1;
+            }
+          }
+        }
+      }
+    }else{
+      xevent.x -= WBORDER_W; //shift the position to subsurface 
+      xevent.y -= WHEADER_H;
+    }
+    //exit from dragging/resizing mode
+    if (xevent.type==DWET_BUTTONUP){
+      if (grabbed && (xevent.button==DIBI_LEFT)){
+        if (resized_win){
+          //XDefineCursor(fl_display, Fl_X::i(window)->xid, 0);
+          //XDefineCursor(fl_display, Fl_X::i(window)->xid/*xevent.window_id*/, saved_cursor);
+          resized_win=0;
+        }
+        grabbed=0;
+        goto release_grabbed_win;
+      }
+    }
+  }
+  //FIXME if user press button then I grab mouse to avoid missing of event "ButtonUp"
+  if ((header!=window) && !grabbed_win && (xevent.type==DWET_BUTTONDOWN)){
+    grabbed_win = Fl_X::i(window)->_xid;
+    grabbed_win->GrabPointer(grabbed_win);
+  }
+  //resp. I ungrab mouse 
+  if ((header!=window)&&(xevent.type==DWET_BUTTONUP)){
+release_grabbed_win:    	
+    if (grabbed_win){
+      grabbed_win->UngrabPointer(grabbed_win);
+      grabbed_win=0;
+    }
+  }
+  return window;
+}
+
+// if this is same event as last && is_click, increment click count:
+inline void checkdouble() {
+  if (Fl::e_is_click == Fl::e_keysym)
+    Fl::e_clicks++;
+  else {
+    Fl::e_clicks = 0;
+    Fl::e_is_click = Fl::e_keysym;
+  }
+  px = Fl::e_x_root;
+  py = Fl::e_y_root;
+  ptime = fl_event_time;
+}
+
+inline int check_modif (int& state, DFBWindowEvent& xevent){
+  state = 0;
+  if (xevent.modifiers & DIMM_SHIFT) state |= FL_SHIFT;
+  if (xevent.modifiers & DIMM_ALT) state |= FL_ALT;
+  if (xevent.modifiers & DIMM_CONTROL) state |= FL_CTRL;
+  if (xevent.modifiers & DIMM_META) state |= FL_META;
+  if (xevent.locks & DILS_SCROLL) state |= FL_SCROLL_LOCK;
+  if (xevent.locks & DILS_NUM) state |= FL_NUM_LOCK;	
+  if (xevent.locks & DILS_CAPS) state |= FL_CAPS_LOCK;
+  state |= xevent.buttons << 24;
+  return state;
+}
+
+Fl_X* focused = 0;
+Fl_X* wait_focus = 0;
+
+// emulate FOCUS/UNFOCUS events
+int switch_focus()
+{
+  if (focused)
+  {
+    Fl::handle(FL_UNFOCUS, focused->w);
+    focused->enter_window(false);
+  }
+  if (wait_focus)
+  {
+    focused = wait_focus;
+    wait_focus = 0;
+    Fl::handle(FL_FOCUS, focused->w);
+    focused->enter_window(true);
+  }
+  return 0;
+}
+
+#define WHEEL_DELTA 1
+int ts = 0;
+
+int fl_handle(const DFBWindowEvent& thisevent){
+  DFBWindowEvent xevent = thisevent;
+  Fl_Window *window = fl_find(xevent.window_id);
+  int ret=0;
+  if (!window) return 0;
+  switch (xevent.type) {
+    case DWET_BUTTONDOWN:
+      if (wait_focus == Fl_X::i(window) && focused != wait_focus)
+        switch_focus();
+      window=check_event_pos(xevent);
+      set_event_xy(xevent);
+      Fl::e_keysym = FL_Button + xevent.button + 1;
+      check_modif (Fl::e_state, xevent);	
+      in_a_window = true;
+      checkdouble();
+      if (!Fl::handle(FL_PUSH, window)) return 0;
+      return 1;
+    case DWET_BUTTONUP:
+      window=check_event_pos(xevent);
+      set_event_xy(xevent);
+      Fl::e_keysym = FL_Button + xevent.button + 1;
+      //Fl::e_state &= ~(FL_BUTTON1 << xevent.button);
+      check_modif (Fl::e_state, xevent);	
+      in_a_window = true;
+      if (!Fl::handle(FL_RELEASE, window)) return 0;
+      return 1;
+    case DWET_MOTION:
+      window=check_event_pos(xevent);
+      set_event_xy(xevent);
+      in_a_window = true;
+      if (grabbed){
+        if ((on_border == 0)||(on_border&1))
+          endx = xevent.cx;
+        if ((on_border == 0)||(on_border&2))	
+          endy = xevent.cy;
+      }
+      //Fl::e_state &= ~(FL_BUTTON1 << xevent.button);
+      //check_modif (Fl::e_state,xevent);	
+      return Fl::handle(FL_MOVE, window);
+    case DWET_WHEEL:
+      window=check_event_pos(xevent);
+      set_event_xy(xevent);
+      static int delta = 0; // running total of all motion
+      delta += xevent.step;
+      Fl::e_dy = -delta / WHEEL_DELTA;
+      delta += Fl::e_dy * WHEEL_DELTA;
+      return Fl::handle(FL_MOUSEWHEEL, window);
+    case DWET_KEYUP:
+    case DWET_KEYDOWN:{
+      fl_event_time = xevent.timestamp.tv_sec*1000 + xevent.timestamp.tv_usec / 1000;
+      // static int pressed = 0;
+      // if ((pressed==thisevent.key_id)&&(xevent.type==DWET_KEYDOWN))
+      //    return 0;
+      int fltk = id2fltk(thisevent.key_id);
+      if (!fltk)
+        fltk = thisevent.key_symbol;
+      Fl::e_keysym = fltk;
+      static char buffer[2];
+      if (thisevent.key_symbol < 256){
+        buffer[0] = thisevent.key_symbol;
+        Fl::e_length = 1;
+      }else{
+        buffer[0] = 0;
+        Fl::e_length = 0;
+      }
+      check_modif (Fl::e_state,xevent);
+      if (Fl::e_state & FL_CTRL){ //FIXME I change the symbol if user pressed Ctrl
+        if (Fl::e_length){
+          switch (buffer[0]){
+          case 13: buffer[0]=10;break;
+          case '[':case '\\':case ']':buffer[0]-= 'A'-1;break;
+          case 8:	buffer[0]=127;break;
+          default:
+            if (buffer[0]>='a' && buffer[0] <='z')
+              buffer[0]-='a'-1;
+            else{
+              buffer[0] = 0;
+              Fl::e_length = 0;
+            }	
+          }
+        }
+      }
+      Fl::e_text = buffer;
+      // FIXME if I set e_is_click to NULL then adjuster is not working during key is held
+      if (xevent.type == DWET_KEYUP)
+        Fl::e_is_click = 0;
+      int keycode = thisevent.key_code;
+      in_a_window = true;
+      if (xevent.type == DWET_KEYDOWN){
+        // if (DIKI_SHIFT_L <= thisevent.key_id && DIKI_HYPER_R >= thisevent.key_id){
+        //   pressed = thisevent.key_id;
+        // }
+        fl_key_vector[keycode/8] |= (1 << (keycode%8));
+        if (!Fl::handle(FL_KEYBOARD, window)) return 0;
+      }else{
+        // if (pressed == thisevent.key_id)
+        //   pressed = 0;
+        fl_key_vector[keycode/8] &= ~(1 << (keycode%8));
+        if (!Fl::handle(FL_KEYUP, window)) return 0;
+      }
+      return 1;
+                      }
+    case DWET_POSITION_SIZE: //window created
+      if (!window->border()){
+        Fl_X::x(window,xevent.x);Fl_X::y(window,xevent.y);
+      }else{
+        Fl_X::x(window,xevent.x+WBORDER_W);Fl_X::y(window,xevent.y+WHEADER_H);
+      }
+      Fl_X::i(window)->wait_for_expose = 0;
+      return Fl::handle(FL_SHOW, window);
+    case DWET_POSITION:
+      if (!window->border()){
+        Fl_X::x(window,xevent.x);Fl_X::y(window,xevent.y);
+      }else{
+        Fl_X::x(window,xevent.x+WBORDER_W);Fl_X::y(window,xevent.y+WHEADER_H);
+      }
+      return 1;
+    case DWET_SIZE:
+      { 
+        int W = xevent.w, H = xevent.h;
+        if (window->border() && !ts)
+        { 
+          W -= WBORDER_W * 2;
+          H -= WHEADER_H + WBORDER_H;
+        }
+        resize_bug_fix = window;
+        window->resize(window->x(), window->y(), W, H);
+
+        Fl_X::i(window)->first_draw = 1;
+        Fl_X::i(window)->wait_for_expose = 0;
+        return 1;
+      }
+    case DWET_CLOSE:
+      D_INFO("handle event 'DWET_CLOSE'\n");
+    case DWET_DESTROYED:
+      D_INFO("handle event 'DWET_DESTROYED'\n");
+      return Fl::handle(FL_CLOSE, window);
+      break;
+      // in fact GOTFOCUS/LOSTFOCUS events are ENTER/LEAVE !
+      // the DirectFB's "default" WM has such behavior...
+    case DWET_GOTFOCUS:
+      wait_focus = Fl_X::i(window);
+      //ret = Fl::handle(FL_FOCUS, window);
+      //Fl_X::i(window)->enter_window(true);
+      return ret;
+
+    case DWET_LOSTFOCUS:
+      check_event_pos(xevent);
+      //ret = Fl::handle(FL_UNFOCUS, window);
+      //Fl_X::i(window)->enter_window(false);
+      return ret;
+
+    case DWET_ENTER:
+      check_event_pos(xevent);
+      ret = Fl::handle(FL_ENTER,window);
+      return ret;
+
+    case DWET_LEAVE:
+      XDefineCursor(fl_display, Fl_X::i(window)->xid, 0);
+      check_event_pos(xevent);
+      Fl::handle(FL_LEAVE, window);
+      return ret;
+    default:
+      D_INFO("handle event 'UNKNOWN' %d\n", xevent.type);
+  }
+  return 0;
+}
+
+void Fl_Window::resize(int X,int Y,int W,int H)
+{
+  int is_a_move = (X != x() || Y != y());
+  int is_a_resize = (W != w() || H != h());
+
+  int resize_from_program = (this != resize_bug_fix);
+  if (!resize_from_program) resize_bug_fix = 0;
+
+  if (shown() && i->maximize()){
+    return;
+  }
+  if (parent()){//it is not a real window - we should change surface position only
+    if (X < 0) X = 0;
+    if (Y < 0) Y = 0;
+    if (H <=0) H = 1;
+    if (W <=0) W = 1;
+    Fl_Group::resize(X,Y,W,H);
+    if (shown()){
+      redraw();
+      Fl_X *parent_xid = get_parent_xid(this);
+      int max_x = parent()->x()+parent()->w()-1;
+      int max_y = parent()->y()+parent()->h()-1;
+      x(X>=max_x?max_x-1:X);
+      y(Y>=max_y?max_y-1:Y);
+      w(W>0 ? W : 1); h(H>0 ? H : 1);
+      release_gc(i->gc);
+      //create subsurface
+      DFBRectangle rect = {x(),y(),w(),h()};
+      if (parent_xid->header == this){//it's a header ?
+        i->gc = create_gc(parent_xid->win_gc, &rect);
+      }else{
+        i->gc = create_gc(parent_xid->gc, &rect);
+      }
+    }
+    return;
+  }
+
+  if (is_a_move && resize_from_program)
+    set_flag(FL_FORCE_POSITION);
+  else if (!is_a_resize && !is_a_move)
+    return;
+  if (is_a_resize){
+    Fl_Group::resize(X,Y,W,H);
+    if (shown()){
+      redraw();
+      i->wait_for_expose = 1;
+    }
+  }else{
+    x(X); y(Y);
+  }
+
+  if (resize_from_program && is_a_resize && !resizable()){
+    size_range(w(), h(), w(), h());
+  }
+
+  if (resize_from_program && shown()){
+    if (is_a_resize){
+      if (!resizable()) size_range(w(),h(),w(),h());
+      if (is_a_move){
+        if (border()){X-=WBORDER_W;Y-=WHEADER_H;}
+        i->_xid->MoveTo(i->_xid, X, Y);
+      }
+      if (border()){W+=WBORDER_W*2; H+=WHEADER_H+WBORDER_H;}
+      if (i->_xid)
+        i->_xid->Resize(i->_xid, W>0 ? W : 1, H>0 ? H : 1);
+      i->set_gc();
+    }else{
+      if (border()){X-=WBORDER_W;Y-=WHEADER_H;}
+      i->_xid->MoveTo(i->_xid, X, Y);
+    }
+  }
+}
+////////////////////////////////////////////////////////////////
+
+Fl_Widget *fl_selection_requestor;
+char *fl_selection_buffer[2];
+int fl_selection_length[2];
+int fl_selection_buffer_length[2];
+char fl_i_own_selection[2];
+
+int Fl::x(){
+  return 0;
+}
+
+int Fl::y(){
+  return 0;
+}
+
+int Fl::h(){
+  if (!screen_height)
+    fl_open_display();
+  return screen_height;
+}
+
+int Fl::w(){
+  if (!screen_width)
+    fl_open_display();
+  return screen_width;
+}
+
+void Fl::get_mouse(int &xx, int &yy){
+  fl_open_display();
+  get_cursor_position(fl_display_layer, &xx, &yy);
+}
+
+void Fl_Window::size_range_() {
+  size_range_set = 1;
+  if (shown()) i->sendxjunk();
+}
+
+void Fl_X::sendxjunk(){
+  if (w->parent() || w->override()) return; // it's not a window manager window!
+
+  if (!w->size_range_set) { // default size_range based on resizable():
+    if (w->resizable()) {
+      Fl_Widget *o = w->resizable();
+      int minw = o->w(); if (minw > 100) minw = 100;
+      int minh = o->h(); if (minh > 100) minh = 100;
+      w->size_range(w->w() - o->w() + minw, w->h() - o->h() + minh, 0, 0);
+    } else {
+      w->size_range(w->w(), w->h(), w->w(), w->h());
+    }
+    return; // because this recursively called here
+  }
+  minw=w->minw;minh=w->minh;maxw=w->maxw;maxh=w->maxh;
+  dw=w->dw;dh=w->dh; 
+  //the handle of  the events "border <-> no border" 
+  if ((bool)(w->border()) != (bool)(header)){
+    int X=w->x(),Y=w->y(),W=w->w(),H=w->h();
+    get_position(_xid, &X, &Y);
+    get_size(_xid, &W, &H);
+    int dx,dy;
+    if (!w->border()){
+      //get_position(xid, &X, &Y);
+      //get_size(xid, &W, &H);
+      H-=WHEADER_H+WBORDER_H;
+      W-=WBORDER_W*2;
+      dx=WBORDER_W;
+      dy=WHEADER_H;
+    }else{
+      dx=-WBORDER_W;
+      dy=-WHEADER_H;
+      H+=WHEADER_H+WBORDER_H;
+      W+=WBORDER_W*2;
+    }
+    ts = 0;
+    _xid->Resize(_xid,W,H);
+    _xid->Move(_xid,dx,dy); 
+    ts = 0;
+    w->Fl_Group::resize(X,Y,W,H);//resize of group (!!!)
+    DFBEvent event;
+    event.clazz = DFEC_WINDOW;
+    event.window.type = DWET_POSITION;
+    event.window.x = X+dx; event.window.y = Y+dy;
+    event.window.window_id = xid;
+    event_buffer->PostEvent(event_buffer, &event);
+    event.window.type = DWET_ENTER;
+    Fl::get_mouse(event.window.cx, event.window.cy);
+    event_buffer->PostEvent(event_buffer, &event);
+    set_gc();
+    first_draw = 1;
+    w->redraw();
+  }
+}
+
+// Call this when a "paste" operation happens:
+void Fl::paste(Fl_Widget &receiver, int clipboard) {
+  if (fl_i_own_selection[clipboard]) {
+    // We already have it, do it quickly without window server.
+    // Notice that the text is clobbered if set_selection is
+    // called in response to FL_PASTE!
+    Fl::e_text = fl_selection_buffer[clipboard];
+    Fl::e_length = fl_selection_length[clipboard];
+    if (!Fl::e_text) Fl::e_text = (char *)"";
+    receiver.handle(FL_PASTE);
+    return;
+  }
+  // otherwise get the window server to return it:
+  fl_selection_requestor = &receiver;
+}
+
+////////////////////////////////////////////////////////////////
+// Code for copying to clipboard and DnD out of the program:
+
+void Fl::copy(const char *stuff, int len, int clipboard) {
+  if (!stuff || len<0) return;
+  if (len+1 > fl_selection_buffer_length[clipboard]) {
+    delete[] fl_selection_buffer[clipboard];
+    fl_selection_buffer[clipboard] = new char[len+100];
+    fl_selection_buffer_length[clipboard] = len+100;
+  }
+  memcpy(fl_selection_buffer[clipboard], stuff, len);
+  fl_selection_buffer[clipboard][len] = 0; // needed for direct paste
+  fl_selection_length[clipboard] = len;
+  fl_i_own_selection[clipboard] = 1;
+  //NIKITA Atom property = clipboard ? CLIPBOARD : XA_PRIMARY;
+  //NIKITA XSetSelectionOwner(fl_display, property, fl_message_window, fl_event_time);
+}
+
+extern void fl_fix_focus(); 
+
+Fl_X* Fl_X::set_xid(Fl_Window* window, dfbWindow win)
+{
+  Fl_X* xp        = new Fl_X;
+  xp->gc          = xp->win_gc = 0;
+  xp->header      = 0;
+  xp->setwindow(window);
+
+  xp->next            = Fl_X::first;
+  Fl_X::first         = xp;
+  xp->region          = 0;
+  xp->first_draw      = 1;
+  xp->wait_for_expose = 0;
+  xp->backbuffer_bad  = 1;
+  xp->origin_size.w   = 0;
+  xp->cursors[0]      = 0;
+
+  DFBWindowID win_id  = -1;
+  win->GetID(win, &win_id);
+
+  xp->xid       = win_id;
+  xp->_xid      = win;
+  xp->minimize_ = 0;
+  if (window->modal()){
+    Fl::modal_ = window;
+    fl_fix_focus();
+  }
+  return xp;
+}
+
+int fl_background_pixel = -1; // hack to speed up bg box drawing
+int fl_disable_transient_for; // secret method of removing TRANSIENT_FOR
+
+extern void init_colormap();
+
+#include <FL/Fl_Button.H>
+#include <FL/Fl_Box.H>
+
+Fl_X *get_parent_xid(Fl_Widget* w)
+{
+  Fl_Widget* parent_wdg = w->parent();
+  Fl_Window* parent_win = (Fl_Window*)parent_wdg;
+  if (parent_wdg->type() < FL_WINDOW){
+    parent_win = parent_wdg->window();
+  }
+  return Fl_X::i(parent_win);
+}
+
+/*****************************************************************
+* 
+* header and icon creating and handling
+* 
+*/
+
+#include <FL/Fl_Bitmap.H>
+#include <FL/Fl_Pixmap.H>
+
+extern unsigned char idata_close_but[];
+extern unsigned char idata_max_but[];
+extern unsigned char idata_min_but[];
+extern unsigned char idata_norm_but[];
+extern const char* idata_dfb[];
+
+static Fl_Bitmap image_close_but(idata_close_but, 12, 10);
+static Fl_Bitmap image_max_but(idata_max_but, 12, 10);
+static Fl_Bitmap image_min_but(idata_min_but, 12, 10);
+static Fl_Bitmap image_norm_but(idata_norm_but, 12, 10);
+static Fl_Pixmap image_icon(idata_dfb);
+
+Fl_Window* create_icon_win(int& W, int H, Fl_Window*);
+
+int current_icon_pos = 0;
+
+void on_close_btn(Fl_Widget* pThis, void *param){
+  if (param){
+    Fl_Window* win = (Fl_Window*)param;
+    Fl::handle(FL_CLOSE,win);
+  }
+}
+void on_icon_btn(Fl_Widget* pThis, void *param){
+  if (param){
+    Fl_Window* win = (Fl_Window*)param;
+    if (Fl::modal() != win){
+      win->iconize();
+    }
+  }
+}
+void on_full_btn(Fl_Widget* pThis, void *param){
+  if (param){
+    Fl_Window* win = (Fl_Window*)param;
+    if (!win->resizable())
+      return;
+    Fl_X *xid = Fl_X::i(win);
+    if (!xid->maximize()){
+      xid->set_maximize();
+      pThis->image(image_norm_but);
+    }else{
+      xid->restore_size();
+      pThis->image(image_max_but);
+    }
+  }
+}
+#define HEADER_LABEL "__header__"
+#define ICON_LABEL   "__icon__"
+
+Fl_Window* create_header(int W, int H, Fl_Window* win)
+{
+  Fl_Window* header = new Fl_Window(0,0,W,H,HEADER_LABEL);
+  header->border(0);
+  header->box(FL_THIN_UP_BOX);
+  header->color(Fl_Color(12));
+  header->selection_color(FL_DARK_BLUE);
+  int but_h = H-6 ,but_w= H-5 ;	
+  int pos_x = W-(but_w+2)*3-1;  
+  Fl_Box* box = new Fl_Box(5,0,pos_x-5,H);
+  if (win->iconlabel())
+    box->label(win->iconlabel());
+  else 
+    if (win->label())	
+      box->label(win->label());
+    else
+      box->label("_");
+  Fl_Boxtype box_type = /*(!have_lut()) ? FL_PLASTIC_UP_BOX :*/ FL_THIN_UP_BOX;
+  box->labelcolor(FL_WHITE);
+  box->labelfont(FL_COURIER_BOLD);
+  box->align(FL_ALIGN_LEFT | FL_ALIGN_INSIDE);
+  box->labeltype(FL_NORMAL_LABEL);
+  header->resizable(box);
+  //box = new Fl_Box(5,0,pos_x-5,H);
+  //box->image(image_icon);
+  Fl_Button *btn = new Fl_Button(pos_x,3,but_w,but_h);
+  btn->image(image_min_but);
+  btn->box(box_type);
+  btn->labeltype(FL_NORMAL_LABEL);
+  //btn->align(FL_ALIGN_TOP | FL_ALIGN_INSIDE);
+  btn->callback(on_icon_btn);
+  btn->when(FL_WHEN_RELEASE_ALWAYS);
+  btn->user_data((void*)win);
+  btn = new Fl_Button(pos_x+but_w+2,3,but_w,but_h);
+  btn->image(image_max_but);
+  btn->box(box_type);
+  btn->labeltype(FL_NORMAL_LABEL);
+  //btn->align(FL_ALIGN_TOP | FL_ALIGN_INSIDE);
+  btn->callback(on_full_btn);
+  btn->when(FL_WHEN_RELEASE_ALWAYS);
+  btn->user_data((void*)win);
+  btn = new Fl_Button(pos_x+(but_w+2)*2,3, but_w,but_h);
+  btn->image(image_close_but);
+  btn->box(box_type);
+  btn->labeltype(FL_NORMAL_LABEL);
+  //btn->align(FL_ALIGN_TOP | FL_ALIGN_INSIDE);
+  btn->callback(on_close_btn);
+  btn->when(FL_WHEN_RELEASE_ALWAYS);
+  btn->user_data((void*)win);
+  header->end();
+  return header;
+}
+
+void resize_header(Fl_Window* header, int W){
+  Fl_X::i(header)->origin_size.w = 0;//clear maximize flag !
+  header->size(W, header->h());
+}
+
+void on_show_btn(Fl_Widget* pThis, void *param){
+  if (param){
+    Fl_Window* win = (Fl_Window*)param; 
+    win->show();
+  }
+}
+
+#include <FL/fl_draw.H>
+
+#define MAX_ICON_WIDTH 100
+
+Fl_Window* create_icon_win(int& W, int H, Fl_Window* win)
+{
+  Fl_Window* icon = new Fl_Window(0,0,W,H, ICON_LABEL); 
+  icon->border(0);
+  icon->box(FL_THIN_UP_BOX);
+  icon->user_data((void*)win);
+  const char* label = win->label();
+  if (!label || strlen(label)>0)
+    label = " ";
+  Fl_Button *btn = new Fl_Button(2,1,W-4,H-2,label);
+  btn->box(FL_NO_BOX);
+  btn->down_box(FL_NO_BOX);
+  icon->color(FL_DARK_BLUE, FL_DARK_BLUE);
+  btn->labelcolor(FL_WHITE);
+  btn->labelfont(FL_COURIER_BOLD);
+  btn->labelsize(12);
+  btn->user_data((void*)win);
+  btn->callback(on_show_btn);
+  //btn->when(FL_WHEN_RELEASE_ALWAYS);
+  icon->resizable(btn);
+  fl_font(FL_COURIER_BOLD, 12);
+  int h=0;
+  W=1000;
+  char text[80]={0};
+  strcpy(text,"@> ");
+  if (strlen(btn->label()))
+    strncat(text,btn->label(),70);
+  while(W >= MAX_ICON_WIDTH){
+    fl_measure(text, W, h, -1);
+    if (W >= MAX_ICON_WIDTH)
+      text[strlen(text)-1]=0;
+  }
+  btn->copy_label(text);
+  if (W < 30) W = 30;
+  //	if (W > MAX_ICON_WIDTH) W = MAX_ICON_WIDTH;
+  W+=20;
+  btn->align(FL_ALIGN_CENTER | FL_ALIGN_INSIDE);
+  icon->size(W, icon->h());
+  icon->end();
+  return icon;
+} 
+
+void Fl_X::set_gc(int W, int H)
+{
+  int width,height;
+  get_size(_xid, &width, &height);
+
+  if (!win_gc){
+    gc      = 0;
+    win_gc  = create_gc(_xid);;
+    //clear_surface(win_surface,0,0,0,0);
+    if (!w->border()){
+      gc = win_gc;
+      goto _l1;
+    }
+  }else{
+    resize(_xid, width, height);
+    clear_gc(win_gc,0,0,0,0);
+  }
+  if (w->border() && !w->parent()){
+    DFBRectangle rect= {0,0,width,height};
+    rect.x += WBORDER_W;
+    rect.y += WHEADER_H;
+    rect.w -= WBORDER_W*2;
+    rect.h -= WHEADER_H+WBORDER_H;
+    //redraw_header = true;
+    if (gc)
+      release_gc(gc);
+    gc = create_gc(win_gc, &rect);
+    if (header){
+      resize_header(header, width);
+      //Fl_X::i(header)->surface = win_surface;
+    }else{
+      header = create_header(width, WHEADER_H, w);
+      header->parent(w);
+      header->show();
+    }
+  }else{
+    if (gc != win_gc)
+      release_gc(gc);
+    gc = win_gc;
+  }
+_l1:   
+  for (Fl_X *wi = next; wi;){
+    Fl_Window* W = wi->w;
+    if (W->parent()) {
+      W->position(W->x(), W->y());
+    }
+    wi = wi->next;
+  }
+}
+
+#define FL_CENTER_WINDOWS 1
+
+Fl_X* Fl_X::make_xid(Fl_Window* w)
+{ 
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "%s()\n", __FUNCTION__);
+  
+  Fl_Group::current(0); // get rid of very common user bug: forgot end()
+  int X = w->x();
+  int Y = w->y();
+  int W = w->w();
+  if (W <= 0) W = 1; // X don't like zero...
+  int H = w->h();
+  if (H <= 0) H = 1; // X don't like zero...
+  if (!w->parent() && !Fl::grab()){
+    // center windows in case window manager does not do anything:
+#ifdef FL_CENTER_WINDOWS
+    if (!(w->flags() & Fl_Window::FL_FORCE_POSITION)){
+      w->x(X = Fl::x()+(Fl::w()-W)/2);
+      w->y(Y = Fl::y()+(Fl::h()-H)/2);
+    }
+#endif// FL_CENTER_WINDOWS
+    // force the window to be on-screen. Usually the X window manager
+    // does this, but a few don't, so we do it here for consistency:
+    int scr_x, scr_y, scr_w, scr_h;
+    Fl::screen_xywh(scr_x, scr_y, scr_w, scr_h, X, Y);
+
+    if (w->border()&& !w->parent()){
+      H+=WHEADER_H+WBORDER_H;
+      W+=WBORDER_W*2;
+      X-=WBORDER_W;
+      Y-=WHEADER_H;
+    }
+    // now insure contents are on-screen (more important than border):
+    if (X+W > scr_x+scr_w) X = scr_x+scr_w-W;
+    if (X < scr_x) X = scr_x;
+    if (Y+H > scr_y+scr_h) Y = scr_y+scr_h-H;
+    if (Y < scr_y) Y = scr_y;
+  } else {
+    if (w->parent()) {
+      D_DEBUG_AT(FL_DIRECTFB_CXX, "=>sub window\n");
+      //I dont create a new window because DirectFB does not support child windows
+      Fl_X* parent = get_parent_xid(w);
+      if (!parent)
+        return 0;
+      Fl_X* x = new Fl_X;
+      //using description of the parent window
+      memcpy(x, parent, sizeof(Fl_X));
+      DFBRectangle rect = { X, Y , W, H };
+      //create subsurface
+      if (parent->header == w){
+        x->gc = create_gc(parent->win_gc, &rect);
+      }else{
+        x->gc = create_gc(parent->gc, &rect);
+      }
+      //change window id to avoid finding out this child by parent id
+      x->header = 0;
+      x->xid = parent->xid | CHILD_ID;
+      x->setwindow(w);
+      //add to chain
+      x->next = parent->next;
+      parent->next = x;
+      x->region = 0;
+      x->first_draw = 1;
+      w->redraw();
+      D_DEBUG_AT(FL_DIRECTFB_CXX, "=>sub window return OK\n");
+      return x;
+    }
+  }
+  IDirectFBWindow *window;
+  DFBDisplayLayerConfig layer_config;
+
+  fl_display_layer->GetConfiguration(fl_display_layer, &layer_config);
+
+  DFBWindowDescription desc;
+
+  desc.flags = (DFBWindowDescriptionFlags)(DWDESC_PIXELFORMAT | DWDESC_CAPS | DWDESC_POSX |\
+    DWDESC_POSY | DWDESC_WIDTH | DWDESC_HEIGHT | DWDESC_SURFACE_CAPS);
+
+  desc.caps = DWCAPS_NONE;//DWCAPS_DOUBLEBUFFER;
+
+  desc.surface_caps = DFBSurfaceCapabilities(DSCAPS_DOUBLE | MEMORY_TYPE);
+  desc.pixelformat  = layer_config.pixelformat;
+  desc.posx = X;
+  desc.posy = Y;
+  desc.width = W;
+  desc.height = H;
+  
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "=>window rect(%d,%d,%d,%d)\n", X, Y, W, H);
+  
+  window = create_window(&desc);
+  set_opacity(window, 0);//hide the window
+  DFBWindowOptions win_opt = (DFBWindowOptions)(DWOP_KEEP_SIZE /*|DWOP_ALPHACHANNEL*/);
+  window->SetOptions(window, win_opt);
+
+  Fl_X* x = Fl_X::set_xid(w , window);
+
+  x->set_gc(/*W,H*/);
+  if (!event_buffer) {
+    window->CreateEventBuffer(window,&event_buffer);
+    fl_display_layer->WarpCursor(fl_display_layer, X+W/2,Y+H/2);
+    event_buffer->CreateFileDescriptor(event_buffer, &event_fd);
+    Fl::add_fd(event_fd, POLLIN, fd_callback);
+  }
+  else
+    window->AttachEventBuffer(window,event_buffer);
+
+  x->sendxjunk();
+
+  x->cursors[0] = XCreateFontCursor(fl_display, (FL_CURSOR_ARROW - 1) * 2);
+  XColor bg,fg;
+  bg.red = bg.green = bg.blue = 255 << 8;
+  fg.red = fg.green = fg.blue = 0;
+  XRecolorCursor(fl_display, x->cursors[0], &fg, &bg);
+  XDefineCursor(fl_display, x->xid, 0);
+
+  int showit = 1;
+
+  if (showit){
+    w->set_visible();
+    int old_event = Fl::e_number;
+    w->handle(Fl::e_number = FL_SHOW); // get child windows to appear
+    Fl::e_number = old_event;
+    w->redraw();
+  }
+  wait_focus = x;
+  switch_focus();
+  return x;
+}
+
+#include <FL/fl_draw.H>
+
+#define sb_w 16
+#define sb_h 16
+
+void Fl_X::set_maximize() 
+{
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "%s()\n", __FUNCTION__);
+  
+  if (maximize())
+    return;
+  origin_size.x = w->x();
+  origin_size.y = w->y();
+  int _w = w->w(),_h=w->h();
+  if (w->border()){
+    w->resize(Fl::x()+WBORDER_W, Fl::y()+WHEADER_H,Fl::w()-WBORDER_W*2, Fl::h()-WBORDER_H-WHEADER_H); 
+  }else{
+    w->resize(Fl::x(), Fl::y(),Fl::w(), Fl::h()); 
+  }
+  origin_size.w = _w;
+  origin_size.h = _h;
+  D_DEBUG_AT(FL_DIRECTFB_CXX, " => w %p %s origin xywh(%d %d %d %d)\n",\
+        w, w->label(), origin_size.x, origin_size.y, origin_size.w, origin_size.h);
+  DFBWindowOptions win_opt = (DFBWindowOptions)(DWOP_KEEP_POSITION|DWOP_KEEP_SIZE|DWOP_ALPHACHANNEL);
+  _xid->SetOptions(_xid, win_opt);
+}
+
+void Fl_X::set_minimize(){
+  if (!minimize()){
+    int W = 80;
+    int H = 20;
+    Fl_Window* icon = create_icon_win(W,H,w);
+    icon->position(current_icon_pos, Fl::h()-H);
+    icon->user_data((void*)_xid);
+    current_icon_pos += W;
+    icon->show();
+    minimize_=1;
+    set_opacity(_xid, 0);
+  }
+}
+
+void Fl_X::delete_icon()
+{
+  if (minimize()){
+    int empty_pos = -1,shift = 0;
+    for (Fl_X *wi = Fl_X::first; wi;){
+      Fl_Window* W = wi->w;
+      if (W->label()&&strcmp(W->label(),ICON_LABEL)==0){
+        if (W->user_data()==_xid){
+          empty_pos = W->x();
+          shift = W->w();
+          current_icon_pos -= W->w();
+          W->hide();
+          wi = Fl_X::first;
+          continue;
+        }else{
+          if (empty_pos != -1){
+            if (W->x() >= empty_pos){
+              W->position(W->x()-shift, W->y());
+              W->show();
+            }
+          }
+        }
+      }
+      wi = wi->next;
+    }
+  }
+  minimize_=0;
+}
+
+void Fl_X::restore_size(int X,int Y,int W,int H){
+  if (maximize()){
+    if (W == -1) W=origin_size.w;
+    //else if (header) W+=WBORDER_W*2;
+    if (H == -1) H=origin_size.h;
+    //else if (header) H+=WBORDER_H+WHEADER_H;
+    if (X == -1) X=origin_size.x;
+    //else if (header) X-=WBORDER_W;
+    if (Y == -1) Y=origin_size.y;
+    //else if (header) Y-=WHEADER_H;
+    origin_size.h = origin_size.w = 0;
+    w->resize(X, Y, W, H);
+    DFBWindowOptions win_opt = (DFBWindowOptions)(DWOP_KEEP_SIZE|DWOP_ALPHACHANNEL);
+    _xid->SetOptions(_xid, win_opt);
+  }
+}
+
+//function updates the window when I receive ENTER or LEAVE message
+void Fl_X::enter_window(bool in){
+  if (Fl::modal() && Fl::modal()!= w){
+    if (!Fl::modal()->border() || in)
+      return;
+  }
+  Fl_Widget *wdg = header;
+  if (!wdg){
+    if (!w->label()){
+      if (w->parent()){
+        wdg = get_parent_xid(w)->header;
+      }else
+        return;
+    }else{
+      if ((strcmp(w->label(), ICON_LABEL) == 0)){
+        wdg = w->child(0);
+      }else
+        return;
+    }
+  }
+  if (in)
+  {
+    wdg->color(FL_DARK_BLUE);
+    raise_to_top(_xid);
+  }
+  else
+    wdg->color(12);
+  wdg->redraw();
+}
+
+void Fl_X::draw_window_frame() {
+  if (!w->border() || w->parent())
+    return;
+  fl_gc     = win_gc;
+  fl_window = (Window)win_gc;
+  int W, H;
+  get_size(win_gc, &W, &H);
+  fl_clip_region(0);
+  win_gc->surface->DrawRectangle(win_gc->surface,1,1,W-2,H-2);
+  fl_draw_box(FL_UP_FRAME,0,0,W,H,FL_WHITE);
+}
+
+void Fl_X::flush()
+{
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "%s()\n", __FUNCTION__);
+  w->flush();
+  if (w->damage() & FL_DAMAGE_ALL){//FIXME I need some flag to restore subwindows ?
+    Fl_X *p = next;
+    while (p && (p->w->window() == w)) {
+      if (p->w->visible_r()) {
+        p->w->damage(FL_DAMAGE_ALL);
+        p->flush();
+      }
+      p = p->next;
+    }
+  }
+  w->make_current();
+  if (first_draw){
+    first_draw = 0;
+    if (w->border() && header){
+      draw_window_frame();
+      header->flush();
+      Fl_X::i(header)->first_draw = 0;
+    }
+    if ((w->label() == 0)||(strcmp(w->label(), HEADER_LABEL))){//exclude header window
+      if (!fl_show_iconic)//is not iconize ?
+        set_opacity(_xid, 255);//display window
+      else{
+        set_opacity(_xid, 0);
+        fl_show_iconic = 0;
+        set_minimize();
+      }
+    }
+    fl_flip(win_gc, 0);//flip the entire window surface
+    D_DEBUG_AT(FL_DIRECTFB_CXX,"  => Flip the entire window\n");
+    fl_show_cursor(_show_cursor);
+    remove_updates(win_gc);
+  }
+}
+
+void Fl_X::release()
+{
+  if (fl_dfb == 0) return;
+  if (Fl_X::first == 0){
+    fl_deinit_dfb();
+  }
+}
+
+DirectFBSurfaceBlittingFlagsNames(dsblit_list);
+DirectFBAccelerationMaskNames(dfxl_list);
+DirectFBSurfaceDrawingFlagsNames(dsdraw_list);
+DirectFBInputDeviceTypeFlagsNames(inpdev_list);
+
+int screen_params()
+{
+  get_size(fl_screen, &screen_width, &screen_height);
+  
+#if (DIRECTFB_MAJOR_VERSION >= 1 && DIRECTFB_MINOR_VERSION > 2)
+  int rotation = 0;
+  fl_display_layer->GetRotation(fl_display_layer, &rotation);
+  
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "Layer's rotation = %d\n", rotation);
+  
+  if (rotation == 90 || rotation == 270) {
+    swap(screen_width, screen_height);
+  }
+#endif
+  
+  fl_visual->byte_order = WORDS_BIGENDIAN; // MACROS
+  static Visual cur_visual;
+  fl_visual->visual = &cur_visual;
+  pixf_ = get_pixel_format(fl_screen);
+  lut_ = DFB_PIXELFORMAT_IS_INDEXED(pixf_);
+  fl_visual->bytes_per_pixel = (pixf_ >> 20) & 7;
+  fl_visual->bits_per_pixel = DFB_BITS_PER_PIXEL(pixf_);
+  switch (pixf_) {
+  case DSPF_LUT8:
+    fl_visual->red_mask = fl_visual->blue_mask = fl_visual->green_mask = 0;
+    fl_visual->visual->red_mask = fl_visual->visual->blue_mask = fl_visual->visual->green_mask = 0;
+    fl_visual->colormap_size = 256;
+    fl_visual->depth = 1;
+    fl_visual->c_class = PseudoColor;
+    fl_visual->visual->map_entries = 256;
+    fl_visual->visual->bits_per_rgb = 8;//FIXME
+    break;
+  case DSPF_ARGB:
+  case DSPF_RGB32:
+  case DSPF_RGB24:
+    fl_visual->red_mask = fl_visual->visual->red_mask = 0xFF0000;
+    fl_visual->green_mask = fl_visual->visual->green_mask = 0x00FF00;
+    fl_visual->blue_mask = fl_visual->visual->blue_mask = 0x0000FF;
+    fl_visual->colormap_size = 0;
+    fl_visual->depth = 1;
+    fl_visual->c_class = DirectColor;
+    fl_visual->visual->map_entries = 0;//FIXME
+    fl_visual->visual->bits_per_rgb = 32;//FIXME
+    break;
+  case DSPF_RGB16:
+    fl_visual->red_mask = fl_visual->visual->red_mask = 0xF800;
+    fl_visual->green_mask = fl_visual->visual->green_mask = 0x07E0;
+    fl_visual->blue_mask = fl_visual->visual->blue_mask = 0x001F;
+    fl_visual->colormap_size = 0;
+    fl_visual->depth = 1;
+    fl_visual->c_class = DirectColor;
+    fl_visual->visual->map_entries = 0;//FIXME
+    fl_visual->visual->bits_per_rgb = 16;//FIXME
+    break;
+  case DSPF_RGB332:
+    fl_visual->red_mask = fl_visual->visual->red_mask = 0xE0;
+    fl_visual->green_mask = fl_visual->visual->green_mask = 0x1C;
+    fl_visual->blue_mask = fl_visual->visual->blue_mask = 0x03;
+    fl_visual->colormap_size = 0;
+    fl_visual->depth = 1;
+    fl_visual->c_class = DirectColor;
+    fl_visual->visual->map_entries = 0;//FIXME
+    fl_visual->visual->bits_per_rgb = 8;//FIXME
+    break;
+  case DSPF_ARGB4444:
+    fl_visual->red_mask = fl_visual->visual->red_mask = 0x0F00;
+    fl_visual->green_mask = fl_visual->visual->green_mask = 0x00F0;
+    fl_visual->blue_mask = fl_visual->visual->blue_mask = 0x000F;
+    fl_visual->colormap_size = 0;
+    fl_visual->depth = 1;
+    fl_visual->c_class = DirectColor;
+    fl_visual->visual->map_entries = 0;//FIXME
+    fl_visual->visual->bits_per_rgb = 16;//FIXME
+    break;
+  default:
+    Fl::fatal("Unsupported pixel format!\n");
+  }
+  DFBGraphicsDeviceDescription dev_desc;
+  fl_dfb->GetDeviceDescription(fl_dfb, &dev_desc);
+
+  D_INFO("Device name\t'%s' , Vendor '%s'\n", dev_desc.name, dev_desc.vendor);
+  D_INFO("Driver name\t'%s' , Vendor '%s'\n", dev_desc.driver.name, dev_desc.driver.vendor);
+  D_INFO("Format '%s' (Bytes:%d,Bits:%d,LUT:'%s')\n",\
+    pixelformat_name((DFBSurfacePixelFormat)pixf_), fl_visual->bytes_per_pixel, fl_visual->bits_per_pixel,lut_?"yes":"no");
+
+#ifdef DEBUG
+  D_DEBUG_AT(FL_DIRECTFB_CXX," => Acceleration:\n");
+  if (dev_desc.acceleration_mask == 0)
+    D_DEBUG_AT(FL_DIRECTFB_CXX," =>\tNone\n");
+  else{
+    for (int i = 0; dfxl_list[i].mask; i++){
+      if (dev_desc.acceleration_mask & dfxl_list[i].mask)
+        D_DEBUG_AT(FL_DIRECTFB_CXX," =>\t %s\n",dfxl_list[i].name);
+    }
+  }
+  D_DEBUG_AT(FL_DIRECTFB_CXX," => Blitting flags:\n");
+  if (dev_desc.blitting_flags == 0)
+    D_DEBUG_AT(FL_DIRECTFB_CXX," => \tNone\n");
+  else{
+    for (int i = 0; dsblit_list[i].flag; i++){
+      if (dev_desc.blitting_flags & dsblit_list[i].flag)
+        D_DEBUG_AT(FL_DIRECTFB_CXX," => \t %s\n",dsblit_list[i].name);
+    }
+  }
+  D_DEBUG_AT(FL_DIRECTFB_CXX," => Drawing flags:\n");
+  if (dev_desc.drawing_flags == 0)
+    D_DEBUG_AT(FL_DIRECTFB_CXX," => \tNone\n");
+  else{
+    for (int i = 0; dsdraw_list[i].flag; i++){
+      if (dev_desc.drawing_flags & dsdraw_list[i].flag)
+        D_DEBUG_AT(FL_DIRECTFB_CXX," => \t %s\n",dsdraw_list[i].name);
+    }
+  }
+#endif
+  return dev_desc.acceleration_mask;
+}
+
+static int deinit = 0; //flag for signal handler
+
+void fl_deinit_dfb(void) {
+  if (!fl_dfb || deinit)
+    return;
+
+  deinit = 1;
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "%s()\n", __FUNCTION__);
+
+  if (event_buffer){
+    event_buffer->Release(event_buffer);
+    event_buffer=0;
+  }
+  fl_free_dfbfonts();
+  fl_free_cursors();
+
+  print_gc_list();
+
+  free_gc_list();
+
+  // FIXME when I uncomment next line I receive sigsegv on dfb->Release()... sometimes
+  fl_display_layer->Release(fl_display_layer);
+
+  fl_dfb->Release(fl_dfb);
+  fl_dfb = 0;
+  D_DEBUG_AT(FL_DIRECTFB_CXX, " => DirectFB is released\n");
+}
+
+int fl_init_dfb(int argc, char **argvv) {
+  static int beenhere = 0;
+  if (!beenhere){
+    beenhere = 1;
+    DFBCHECK (DirectFBInit (&argc, (char***)&argvv));
+    DFBCHECK (DirectFBCreate (&fl_dfb)); // Create the super interface.
+  }
+  return 0;
+}
+
+static void tick_cb(void*) {
+  Fl::repeat_timeout(1.0, tick_cb);
+}
+
+void sigfunc(int sig){
+  fprintf(stderr, "Signal '%d' received\n", sig);
+  if ((sig==SIGSEGV)||(sig==SIGINT)||(sig=SIGTERM)){
+    if (!deinit)
+      fl_deinit_dfb();
+    exit (0);
+  }
+}
+
+DFBEnumerationResult myVideoModeCallback(int width,int height,int bpp,void *callbackdata) {
+  //_TRACE("Video mode %d : width %d\theight %d\tbpp %d\n", ++nmode, width, height, bpp); 
+  return DFENUM_OK;
+}
+
+DFBEnumerationResult myInputDeviceCallback(DFBInputDeviceID	device_id,DFBInputDeviceDescription desc,void *callbackdata)
+{
+  D_INFO("Input device ID =%d\t type= ",device_id);
+  if (desc.type == 0){
+    D_INFO("None");
+  }else{
+    for (int i = 0; inpdev_list[i].type; i++){
+      if (desc.type & inpdev_list[i].type)
+        D_INFO(inpdev_list[i].name);
+    }
+  }
+  D_INFO("\tname %s\n", desc.name);
+  if (desc.type == DIDTF_KEYBOARD){
+    keyboard_id = device_id;
+  }
+  return DFENUM_OK;
+}
+
+FL_EXPORT void fl_open_display()
+{
+  D_DEBUG_AT(FL_DIRECTFB_CXX, "%s()\n", __FUNCTION__);
+  
+  D_DEBUG_AT(FL_DIRECTFB_CXX,"DirectFB Version %d.%d\n",DIRECTFB_MAJOR_VERSION,DIRECTFB_MINOR_VERSION);
+  
+  if (!fl_dfb) {
+    fl_init_dfb(0, 0);
+  }
+  if (!fl_screen && fl_dfb) {
+
+    fl_dfb->EnumVideoModes(fl_dfb,myVideoModeCallback, 0);
+
+    fl_dfb->EnumInputDevices(fl_dfb,myInputDeviceCallback, 0);
+
+    DFBDisplayLayerConfig layer_config;
+
+    fl_dfb->GetDisplayLayer(fl_dfb, DLID_PRIMARY, &fl_display_layer);
+
+    fl_display_layer->SetCooperativeLevel(fl_display_layer, DLSCL_ADMINISTRATIVE);
+
+    fl_display_layer->GetConfiguration(fl_display_layer, &layer_config);
+
+    //layer_config.buffermode = DLBM_BACKVIDEO;
+
+    //fl_display_layer->SetConfiguration(fl_display_layer, &layer_config);
+    
+    DFBGraphicsDeviceDescription gdesc;
+    fl_dfb->GetDeviceDescription(fl_dfb, &gdesc);
+
+    Cursor c = XCreateFontCursor(fl_display, (FL_CURSOR_ARROW - 1) * 2);
+    XColor bg,fg;
+    bg.red = bg.green = bg.blue = 255 << 8;
+    fg.red = fg.green = fg.blue = 0;
+    XRecolorCursor(fl_display, c, &fg, &bg);
+    set_cursor_shape(fl_display_layer, ISGC(c->shape), c->hot_x, c->hot_y);
+    fl_display_layer->EnableCursor(fl_display_layer, 1);
+    fl_show_cursor(_show_cursor);
+
+    DFBSurfaceDescription dsc; // A surface description is needed to create a surface.
+    dsc.flags = DFBSurfaceDescriptionFlags(DSDESC_CAPS);
+    dsc.caps=(DFBSurfaceCapabilities)(DSCAPS_PRIMARY | DSCAPS_FLIPPING);
+    if (gdesc.acceleration_mask) 
+      dsc.caps = (DFBSurfaceCapabilities)(dsc.caps | DSCAPS_VIDEOONLY);
+
+    fl_screen = create_gc(&dsc);
+    screen_params();
+
+# if !USE_COLORMAP
+    int pf = pixel_format();
+    switch (pf) {
+      case DSPF_ARGB:
+      case DSPF_RGB32:
+      case DSPF_RGB16:
+      case DSPF_RGB332:
+      case DSPF_ARGB4444:
+        break;
+      default:
+        Fl::fatal("FLTK need 'RGB32' or 'ARGB' modes!");
+    }
+# endif
+
+# if USE_COLORMAP
+    fl_colormap = XCreateColormap(fl_display);
+    init_xcolormap();
+    XFlushColormap(fl_display, fl_colormap);
+# endif
+
+    Fl::add_timeout(1.0, tick_cb);
+    signal(SIGSEGV, sigfunc);
+    signal(SIGINT, sigfunc);
+    signal(SIGTERM, sigfunc);
+    atexit(fl_deinit_dfb);
+  }
+}
diff -Nwrup -x.git fltk-1.1.9/src/fl_dnd_x.cxx FLTK_1.x-DirectFB/src/fl_dnd_x.cxx
--- fltk-1.1.9/src/fl_dnd_x.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_dnd_x.cxx	2009-11-28 15:48:05.990154744 -0500
@@ -30,7 +30,12 @@
 #include <FL/x.H>
 #include "flstring.h"
 
-
+#ifdef DIRECTFB
+//stub
+int Fl::dnd(){
+  return 0;
+}
+#else
 extern Atom fl_XdndAware;
 extern Atom fl_XdndSelection;
 extern Atom fl_XdndEnter;
@@ -194,7 +199,7 @@ int Fl::dnd() {
   source_fl_win->cursor(FL_CURSOR_DEFAULT);
   return 1;
 }
-
+#endif
 
 //
 // End of "$Id: fl_dnd_x.cxx 5190 2006-06-09 16:16:34Z mike $".
diff -Nwrup -x.git fltk-1.1.9/src/Fl_Double_Window.cxx FLTK_1.x-DirectFB/src/Fl_Double_Window.cxx
--- fltk-1.1.9/src/Fl_Double_Window.cxx	2007-05-14 11:51:00.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_Double_Window.cxx	2009-11-28 15:48:05.962154030 -0500
@@ -35,6 +35,21 @@
 // Fl_Window class will probably do double-buffer and this subclass
 // does nothing.
 
+#ifdef DIRECTFB
+
+void Fl_Double_Window::flush(int eraseoverlay) {
+  if(eraseoverlay){redraw();}
+  Fl_Window::flush();
+  if(eraseoverlay){fl_clip_region(0);}
+}
+void Fl_Double_Window::flush(){flush(0);}
+void Fl_Double_Window::show(){Fl_Window::show();}
+void Fl_Double_Window::resize(int x,int y,int w,int h){Fl_Window::resize(x,y,w,h);}
+void Fl_Double_Window::hide(){Fl_Window::hide();}
+Fl_Double_Window::~Fl_Double_Window(){};
+
+#else
+
 #if USE_XDBE
 
 #include <X11/extensions/Xdbe.h>
@@ -446,7 +461,7 @@ void Fl_Double_Window::hide() {
 Fl_Double_Window::~Fl_Double_Window() {
   hide();
 }
-
+#endif
 //
 // End of "$Id: Fl_Double_Window.cxx 5829 2007-05-14 15:51:00Z matt $".
 //
diff -Nwrup -x.git fltk-1.1.9/src/fl_draw_image.cxx FLTK_1.x-DirectFB/src/fl_draw_image.cxx
--- fltk-1.1.9/src/fl_draw_image.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_draw_image.cxx	2009-11-28 15:48:05.990154744 -0500
@@ -64,6 +64,7 @@
 #  include <FL/x.H>
 #  include "Fl_XColor.H"
 #  include "flstring.h"
+# include  <stdio.h>
 
 static XImage xi;	// template used to pass info to X
 static int bytes_per_pixel;
@@ -81,6 +82,8 @@ static int ri,gi,bi;	// saved error-diff
 // 8-bit converter with error diffusion
 
 static void color8_converter(const uchar *from, uchar *to, int w, int delta) {
+	if ( !( from && to ) )
+		return;
   int r=ri, g=gi, b=bi;
   int d, td;
   if (dir) {
@@ -354,6 +357,7 @@ static void figure_out_visual() {
   fl_xpixel(FL_BLACK); // setup fl_redmask, etc, in fl_color.cxx
   fl_xpixel(FL_WHITE); // also make sure white is allocated
 
+#ifndef DIRECTFB 
   static XPixmapFormatValues *pfvlist;
   static int FL_NUM_pfv;
   if (!pfvlist) pfvlist = XListPixmapFormats(fl_display,&FL_NUM_pfv);
@@ -375,6 +379,17 @@ static void figure_out_visual() {
   if (pfv->scanline_pad & 7 || (n&(n-1)))
     Fl::fatal("Can't do scanline_pad of %d",pfv->scanline_pad);
   if (n < sizeof(STORETYPE)) n = sizeof(STORETYPE);
+# else
+	unsigned int n = 8; //FIXME 
+	xi.bitmap_unit = n;
+	xi.bitmap_bit_order = WORDS_BIGENDIAN ? MSBFirst : LSBFirst;
+	xi.bitmap_pad = n;
+	xi.bits_per_pixel = fl_visual->bits_per_pixel;
+	xi.format = ZPixmap;
+  	xi.byte_order = fl_visual->byte_order;
+	xi.depth = fl_visual->depth;
+  	fl_visual->bytes_per_pixel = bytes_per_pixel = xi.bits_per_pixel / 8;
+#endif	
   scanline_add = n-1;
   scanline_mask = -n;
 
@@ -451,7 +466,6 @@ static void figure_out_visual() {
   default:
     Fl::fatal("Can't do %d bits_per_pixel",xi.bits_per_pixel);
   }
-
 }
 
 #  define MAXBUFFER 0x40000 // 256k
@@ -461,14 +475,15 @@ static void innards(const uchar *buf, in
 		    Fl_Draw_Image_Cb cb, void* userdata)
 {
   if (!linedelta) linedelta = W*delta;
-
   int dx, dy, w, h;
   fl_clip_box(X,Y,W,H,dx,dy,w,h);
+  
   if (w<=0 || h<=0) return;
   dx -= X;
   dy -= Y;
 
   if (!bytes_per_pixel) figure_out_visual();
+  	
   xi.width = w;
   xi.height = h;
 
diff -Nwrup -x.git fltk-1.1.9/src/fl_font.cxx FLTK_1.x-DirectFB/src/fl_font.cxx
--- fltk-1.1.9/src/fl_font.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_font.cxx	2009-11-28 15:48:05.992153871 -0500
@@ -39,13 +39,14 @@
 #  include "fl_font_win32.cxx"
 #elif defined(__APPLE__)
 #  include "fl_font_mac.cxx"
+#elif defined(DIRECTFB)
+#  include "fl_font_directfb.cxx"
 #elif USE_XFT
 #  include "fl_font_xft.cxx"
 #else
 #  include "fl_font_x.cxx"
 #endif // WIN32
 
-
 double fl_width(const char* c) {
   if (c) return fl_width(c, strlen(c));
   else return 0.0f;
diff -Nwrup -x.git fltk-1.1.9/src/fl_font_directfb.cxx FLTK_1.x-DirectFB/src/fl_font_directfb.cxx
--- fltk-1.1.9/src/fl_font_directfb.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/fl_font_directfb.cxx	2009-11-28 15:48:05.992153871 -0500
@@ -0,0 +1,320 @@
+//
+// "$Id: fl_font_directfb.cxx,v 1.3 2006-10-31 09:31:14 nikego Exp $"
+//
+// DirectFB-specific font selection code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+
+#include <FL/x.H>
+
+Fl_FontSize::Fl_FontSize(const char* name)
+{
+  font = XLoadFont(fl_display, name);
+  if (!font) {
+    Fl::warning("bad font: %s", name);
+    font = XLoadFont(fl_display, "fixed"); // if fixed fails we crash
+  }
+  next = 0;
+#  if HAVE_GL
+  listbase = 0;
+#  endif
+}
+
+Fl_FontSize* fl_fontsize;
+
+Fl_FontSize::~Fl_FontSize()
+{
+#  if HAVE_GL
+  // Delete list created by gl_draw().  This is not done by this code
+  // as it will link in GL unnecessarily.  There should be some kind
+  // of "free" routine pointer, or a subclass?
+  // if (listbase) {
+  //  int base = font->min_char_or_byte2;
+  //  int size = font->max_char_or_byte2-base+1;
+  //  int base = 0; int size = 256;
+  //  glDeleteLists(listbase+base,size);
+  // }
+#  endif
+  if (this == fl_fontsize)
+    fl_fontsize = 0;
+  D_DEBUG("free font %p\n", font);
+  XFreeFont(fl_display, font);
+}
+
+////////////////////////////////////////////////////////////////
+
+// WARNING: if you add to this table, you must redefine FL_FREE_FONT
+// in Enumerations.H & recompile!!
+static Fl_Fontdesc built_in_table[] = {
+{"-*-Arial-medium-r-normal--*"},
+{"-*-Arial-bold-r-normal--*"},
+{"-*-Arial-medium-i-normal--*"},
+{"-*-Arial-bold-i-normal--*"},
+{"-*-Courier New-medium-r-normal--*"},
+{"-*-Courier New-bold-r-normal--*"},
+{"-*-Courier New-medium-i-normal--*"},
+{"-*-Courier New-bold-i-normal--*"},
+{"-*-Times New Roman-Medium-r-Normal--*"},
+{"-*-Times New Roman-Bold-r-Normal--*"},
+{"-*-Times New Roman-Medium-i-Normal--*"},
+{"-*-Times New Roman-Bold-i-Normal--*"},
+{"-*-symbol-*"},
+{"-*-lucidatypewriter-medium-r-normal-sans-*"},
+{"-*-lucidatypewriter-bold-r-normal-sans-*"},
+{"-*-*zapf dingbats-*"},
+{""}
+};
+
+Fl_Fontdesc* fl_fonts = built_in_table;
+
+#define MAXSIZE 32767
+
+// return dash number N, or pointer to ending null if none:
+const char* fl_font_word(const char* p, int n)
+{
+  while (*p) {
+    if (*p=='-') {
+      if (!--n)
+        break;
+    }
+    p++;
+  }
+  return p;
+}
+
+// return a pointer to a number we think is "point size":
+char* fl_find_fontsize(char* name)
+{
+  char* c = name;
+  // for standard x font names, try after 7th dash:
+  if (*c == '-') {
+    c = (char*)fl_font_word(c, 7);
+    if (*c++ && isdigit(*c))
+      return c;
+    return 0; // malformed x font name?
+  }
+  char* r = 0;
+  // find last set of digits:
+  for (c++; *c; c++)
+    if (isdigit(*c) && !isdigit(*(c-1)))
+      r = c;
+  return r;
+}
+
+const char* fl_encoding = "iso8859-1";
+
+// return true if this matches fl_encoding:
+int fl_correct_encoding(const char* name)
+{
+  if (*name != '-')
+    return 0;
+  const char* c = fl_font_word(name, 13);
+  return (*c++ && !strcmp(c, fl_encoding));
+}
+
+// locate or create an Fl_FontSize for a given Fl_Fontdesc and size:
+static Fl_FontSize* find(int fnum, int size)
+{
+  Fl_Fontdesc* s = fl_fonts+fnum;
+  if (!s->name)
+    s = fl_fonts; // use font 0 if still undefined
+  Fl_FontSize* f;
+  for (f = s->first; f; f = f->next)
+    if (f->minsize <= size && f->maxsize >= size)
+      return f;
+  fl_open_display();
+  if (!s->xlist) {
+    //__TRACE("\nfind() => pattern '%s'",s->name);
+    s->xlist = XListFonts(fl_display, s->name, 100, &(s->n));
+    if (!s->xlist) { // use fixed if no matching font...
+      s->first = new Fl_FontSize("fixed");
+      s->first->minsize = 0;
+      s->first->maxsize = 32767;
+      return s->first;
+    }
+  }
+  // search for largest <= font size:
+  char* name = s->xlist[0];
+  int ptsize = 0; // best one found so far
+  int matchedlength = 32767;
+  char namebuffer[1024]; // holds scalable font name
+  int found_encoding = 0;
+  int m = s->n;
+  if (m<0)
+    m = -m;
+  for (int n=0; n < m; n++) {
+    char* thisname = s->xlist[n];
+    if (fl_correct_encoding(thisname)) {
+      if (!found_encoding)
+        ptsize = 0; // force it to choose this
+      found_encoding = 1;
+    } else {
+      if (found_encoding)
+        continue;
+    }
+    char* c = fl_find_fontsize(thisname);
+    int thissize = c ? atoi(c) : MAXSIZE;
+    int thislength = strlen(thisname);
+    if (thissize == size && thislength < matchedlength) {
+      // exact match, use it:
+      name = thisname;
+      ptsize = size;
+      matchedlength = thislength;
+    } else if (!thissize && ptsize!=size) {
+      // whoa!  A scalable font!  Use unless exact match found:
+      int l = c-thisname;
+      memcpy(namebuffer,thisname,l);
+      l += sprintf(namebuffer+l,"%d",size);
+      while (*c == '0') c++;
+      strcpy(namebuffer+l,c);
+      name = namebuffer;
+      ptsize = size;
+    } else if (!ptsize || // no fonts yet
+        thissize < ptsize && ptsize> size || // current font too big
+        thissize> ptsize && thissize <= size // current too small
+    ) {
+      name = thisname; ptsize = thissize;
+      matchedlength = thislength;
+    }
+  }
+
+  if (ptsize != size) { // see if we already found this unscalable font:
+    for (f = s->first; f; f = f->next) {
+      if (f->minsize <= ptsize && f->maxsize >= ptsize) {
+        if (f->minsize > size)
+          f->minsize = size;
+        if (f->maxsize < size)
+          f->maxsize = size;
+        return f;
+      }
+    }
+  }
+  // okay, we definately have some name, make the font:
+  f = new Fl_FontSize(name);
+  if (ptsize < size) {
+    f->minsize = ptsize;
+    f->maxsize = size;
+  } else {
+    f->minsize = size;
+    f->maxsize = ptsize;
+  }
+  f->next = s->first;
+  s->first = f;
+  return f;
+}
+
+////////////////////////////////////////////////////////////////
+// Public interface:
+
+int fl_font_ = 0;
+int fl_size_ = 0;
+
+FL_EXPORT void fl_free_dfbfonts()
+{
+  for (int i = 0;; i++) {
+    Fl_Fontdesc* s = fl_fonts+i;
+    if (!s || !s->name || !strlen(s->name))
+      break;
+    Fl_FontSize *f = s->first, *next;
+    if (!f)
+      continue;
+    while (f) {
+      next = f->next;
+      delete f;
+      f = next;
+    }
+  }
+}
+
+static XFont fl_directfb_font = 0;
+
+void fl_font(int fnum, int size)
+{
+  if (fnum == fl_font_ && size == fl_size_)
+    return;
+  fl_font_ = fnum;
+  fl_size_ = size;
+  Fl_FontSize* f = find(fnum, size);
+  if (f != fl_fontsize) {
+    fl_fontsize = f;
+    fl_directfb_font = f->font;
+  }
+}
+
+int fl_height()
+{
+  return get_font_height(fl_directfb_font);
+}
+
+int fl_descent()
+{
+  return get_font_descender(fl_directfb_font);
+}
+
+double fl_width(const char* s, int n)
+{
+  if (fl_directfb_font) {
+    int width;
+    get_string_width(fl_directfb_font, s, n, &width);
+    return width;
+  }
+  return -1.0;
+}
+
+double fl_width(uchar c)
+{
+  if (fl_directfb_font) {
+    char s[2] = { c, 0 };
+    int width;
+    get_string_width(fl_directfb_font, s, 1, &width);
+    return width;
+  }
+  return -1.0;
+}
+
+void fl_draw(const char* str, int n, int x, int y)
+{
+  Surface surface = ISGC(fl_window);
+  if (!surface)
+    surface = fl_gc;
+  if (fl_directfb_font && surface) {
+    XFont fbfont = get_surface_font(surface);
+    if (!fbfont || (fbfont != fl_directfb_font)) {
+      set_surface_font(surface, fl_directfb_font);
+    }
+    draw_string(surface, str, n, x, y, DSTF_LEFT);
+    if (fbfont)
+      fbfont->Release(fbfont);
+    update_region(surface, DFB_REGION_VALS_FROM_RECTANGLE_VALS(x, y,
+        (int)(fl_width(str, n)+.5), fl_height()));
+  }
+}
+
+void fl_draw(const char* str, int n, float x, float y)
+{
+  fl_draw(str, n, (int)x, (int)y);
+}
+
+//
+// End of "$Id: fl_font_directfb.cxx,v 1.3 2006-10-31 09:31:14 nikego Exp $".
+//
diff -Nwrup -x.git fltk-1.1.9/src/Fl_Font.H FLTK_1.x-DirectFB/src/Fl_Font.H
--- fltk-1.1.9/src/Fl_Font.H	2006-08-19 11:24:55.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_Font.H	2009-11-28 15:48:05.964153826 -0500
@@ -72,6 +72,9 @@ public:
   const char* encoding;
   int size;
   FL_EXPORT Fl_FontSize(const char* xfontname);
+#  elif DIRECTFB
+  XFont font;	//DirectFB's font 
+  FL_EXPORT Fl_FontSize(const char* xfontname);
 #  else
   XFontStruct* font;	// X font information
   FL_EXPORT Fl_FontSize(const char* xfontname);
@@ -104,6 +107,7 @@ FL_EXPORT const char* fl_font_word(const
 FL_EXPORT char *fl_find_fontsize(char *name);
 #  endif
 
+
 #endif
 
 //
diff -Nwrup -x.git fltk-1.1.9/src/Fl_get_system_colors.cxx FLTK_1.x-DirectFB/src/Fl_get_system_colors.cxx
--- fltk-1.1.9/src/Fl_get_system_colors.cxx	2007-02-20 12:02:41.000000000 -0500
+++ FLTK_1.x-DirectFB/src/Fl_get_system_colors.cxx	2009-11-28 15:48:05.979154026 -0500
@@ -24,7 +24,7 @@
 //
 //     http://www.fltk.org/str.php
 //
-
+#include <config.h>
 #include <FL/Fl.H>
 #include <FL/fl_draw.H>
 #include <FL/x.H>
@@ -33,6 +33,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <FL/Fl_Pixmap.H>
+
 #include <FL/Fl_Tiled_Image.H>
 #include "tile.xpm"
 
@@ -93,7 +94,7 @@ static void set_selection_color(uchar r,
   Fl::set_color(FL_SELECTION_COLOR,r,g,b);
 }
 
-#if defined(WIN32) || defined(__APPLE__)
+#if defined(WIN32) || defined(__APPLE__) || defined(DIRECTFB)
 
 #  include <stdio.h>
 // simulation of XParseColor:
@@ -194,7 +195,6 @@ void Fl::get_system_colors()
 // But this will also match *.background if there is no *.Text.background
 // entry, requiring users to put in both (unless they want the text fields
 // the same color as the windows).
-
 static void
 getsyscolor(const char *key1, const char* key2, const char *arg, const char *defarg, void (*func)(uchar,uchar,uchar))
 {
@@ -278,7 +278,6 @@ int Fl::scheme(const char *s) {
 
 int Fl::reload_scheme() {
   Fl_Window *win;
-
   if (scheme_ && !strcasecmp(scheme_, "plastic")) {
     // Update the tile image to match the background color...
     uchar r, g, b;
@@ -379,7 +378,7 @@ int Fl::reload_scheme() {
 
   return 1;
 }
-
+//#endif
 
 //
 // End of "$Id: Fl_get_system_colors.cxx 5699 2007-02-20 17:02:41Z matt $".
diff -Nwrup -x.git fltk-1.1.9/src/Fl_GIF_Image.cxx FLTK_1.x-DirectFB/src/Fl_GIF_Image.cxx
--- fltk-1.1.9/src/Fl_GIF_Image.cxx	2007-05-19 20:01:06.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_GIF_Image.cxx	2009-11-28 15:48:05.964153826 -0500
@@ -38,6 +38,24 @@
 #include <stdlib.h>
 #include "flstring.h"
 
+#ifdef DIRECTFB
+
+#include <FL/x.H>
+
+Fl_GIF_Image::Fl_GIF_Image(const char *infname): Fl_RGB_Image(0,0,0) {
+
+  mask = 0;
+  int _w,_h,_d=4;
+  //using DirectFB's method to load an image
+  array = fl_load_image( infname,_w,_h,_d );
+  if ( array ){
+    w( _w ); h( _h ); d( _d );
+    ld(0);// _w *_d );
+  }
+}
+
+#else
+
 // Read a .gif file and convert it to a "xpm" format (actually my
 // modified one with compressed colormaps).
 
@@ -72,13 +90,16 @@
  *                     Mountain View, CA 94043
  *                     (415) 336-1080
  */
-
 typedef unsigned char uchar;
 
 #define NEXTBYTE (uchar)getc(GifFile)
 #define GETSHORT(var) var = NEXTBYTE; var += NEXTBYTE << 8
+#ifdef DIRECTFB
+#include <FL/x.H>
+#endif
 
 Fl_GIF_Image::Fl_GIF_Image(const char *infname) : Fl_Pixmap((char *const*)0) {
+	
   FILE *GifFile;	// File to read
   char **new_data;	// Data array
 
@@ -199,6 +220,13 @@ Fl_GIF_Image::Fl_GIF_Image(const char *i
     ColorMapSize = 1 << BitsPerPixel;
   }
 
+  if (BitsPerPixel >= CodeSize)
+  {
+    // Workaround for broken GIF files...
+    BitsPerPixel = CodeSize - 1;
+    ColorMapSize = 1 << BitsPerPixel;
+  }
+
   uchar *Image = new uchar[Width*Height];
 
   int YC = 0, Pass = 0; /* Used to de-interlace the picture */
@@ -378,7 +406,7 @@ Fl_GIF_Image::Fl_GIF_Image(const char *i
   fclose(GifFile);
 }
 
-
+#endif
 //
 // End of "$Id: Fl_GIF_Image.cxx 5845 2007-05-20 00:01:06Z mike $".
 //
diff -Nwrup -x.git fltk-1.1.9/src/Fl_grab.cxx FLTK_1.x-DirectFB/src/Fl_grab.cxx
--- fltk-1.1.9/src/Fl_grab.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_grab.cxx	2009-11-28 15:48:05.979154026 -0500
@@ -60,6 +60,8 @@ void Fl::grab(Fl_Window* win) {
 #elif defined(__APPLE__)
       fl_capture = fl_xid( first_window() );
       SetUserFocusWindow( fl_capture );
+#elif defined(DIRECTFB)      
+
 #else
       XGrabPointer(fl_display,
 		   fl_xid(first_window()),
@@ -88,6 +90,8 @@ void Fl::grab(Fl_Window* win) {
 #elif defined(__APPLE__)
       fl_capture = 0;
       SetUserFocusWindow( (WindowRef)kUserFocusAuto );
+#elif defined(DIRECTFB)  
+      
 #else
       XUngrabKeyboard(fl_display, fl_event_time);
       XUngrabPointer(fl_display, fl_event_time);
diff -Nwrup -x.git fltk-1.1.9/src/Fl_Image.cxx FLTK_1.x-DirectFB/src/Fl_Image.cxx
--- fltk-1.1.9/src/Fl_Image.cxx	2007-06-07 13:23:41.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_Image.cxx	2009-11-28 15:48:05.966153433 -0500
@@ -430,6 +430,15 @@ void Fl_RGB_Image::draw(int XP, int YP, 
       fl_draw_image(array, 0, 0, w(), h(), d(), ld());
       fl_end_offscreen();
     }
+#ifdef DIRECTFB
+    else if (d() == 4) {//DirectFB can draw an image with alpha
+      id = fl_create_offscreen_argb(w(), h());
+      fl_begin_offscreen((Fl_Offscreen)id);
+      //copy with conversation the FLTK pixel format (ABGR) to ARGB
+      fl_draw_abgr_to_argb(array, 0, 0, w(), h());
+      fl_end_offscreen();
+    }
+#endif
 #endif
   }
 #ifdef WIN32
diff -Nwrup -x.git fltk-1.1.9/src/Fl_JPEG_Image.cxx FLTK_1.x-DirectFB/src/Fl_JPEG_Image.cxx
--- fltk-1.1.9/src/Fl_JPEG_Image.cxx	2007-05-19 20:01:06.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_JPEG_Image.cxx	2009-11-28 15:48:05.967154039 -0500
@@ -40,7 +40,20 @@
 #include <stdlib.h>
 #include <setjmp.h>
 
+#ifdef DIRECTFB
 
+#include <FL/x.H>
+
+Fl_JPEG_Image::Fl_JPEG_Image(const char* infname):Fl_RGB_Image(0,0,0){
+  mask=0;
+  int _w,_h,_d=3;
+  array=fl_load_image(infname,_w,_h,_d);
+  if(array){
+    w(_w);h(_h);d(_d);
+  }
+}
+
+#else
 // Some releases of the Cygwin JPEG libraries don't have a correctly
 // updated header file for the INT32 data type; the following define
 // from Shane Hill seems to be a usable workaround...
@@ -187,7 +200,7 @@ Fl_JPEG_Image::Fl_JPEG_Image(const char 
   fclose(fp);
 #endif // HAVE_LIBJPEG
 }
-
+#endif
 //
 // End of "$Id: Fl_JPEG_Image.cxx 5845 2007-05-20 00:01:06Z mike $".
 //
diff -Nwrup -x.git fltk-1.1.9/src/Fl_Light_Button.cxx FLTK_1.x-DirectFB/src/Fl_Light_Button.cxx
--- fltk-1.1.9/src/Fl_Light_Button.cxx	2007-02-27 14:23:24.000000000 -0500
+++ FLTK_1.x-DirectFB/src/Fl_Light_Button.cxx	2009-11-28 15:48:05.967154039 -0500
@@ -100,12 +100,13 @@ void Fl_Light_Button::draw() {
 	      break;
 
             // Small circles don't draw well on many systems...
+#	ifndef DIRECTFB // ...exclude in DirectFB       
 	    case 6 :
 	      fl_rectf(x() + tdx + 2, y() + tdy, tW - 4, tW);
 	      fl_rectf(x() + tdx + 1, y() + tdy + 1, tW - 2, tW - 2);
 	      fl_rectf(x() + tdx, y() + tdy + 2, tW, tW - 4);
 	      break;
-
+#	endif
 	    case 5 :
 	    case 4 :
 	    case 3 :
diff -Nwrup -x.git fltk-1.1.9/src/fl_line_style.cxx FLTK_1.x-DirectFB/src/fl_line_style.cxx
--- fltk-1.1.9/src/fl_line_style.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_line_style.cxx	2009-11-28 15:48:05.993153877 -0500
@@ -125,6 +125,16 @@ void fl_line_style(int style, int width,
     fl_quartz_line_pattern = 0; fl_quartz_line_pattern_size = 0;
   }
   fl_quartz_restore_line_style_();
+#elif defined(DIRECTFB)
+	unsigned long line_type[6] = {
+  	0xffffffff ,// FL_SOLID
+    0x0f0f0f0f,	// FL_DASH
+    0x55555555, // FL_DOT
+    0xFAFAFAFA, // FL_DASHDOT
+    0xEAEAEAEA, // FL_DASHDOTDOT
+    0 };
+    if (style > 4) style = 4;
+    set_dash_style(fl_gc, line_type[style], 32);
 #else
   int ndashes = dashes ? strlen(dashes) : 0;
   // emulate the WIN32 dash patterns on X
@@ -152,6 +162,7 @@ void fl_line_style(int style, int width,
   }
   static int Cap[4] = {CapButt, CapButt, CapRound, CapProjecting};
   static int Join[4] = {JoinMiter, JoinMiter, JoinRound, JoinBevel};
+
   XSetLineAttributes(fl_display, fl_gc, width, 
 		     ndashes ? LineOnOffDash : LineSolid,
 		     Cap[(style>>8)&3], Join[(style>>12)&3]);
diff -Nwrup -x.git fltk-1.1.9/src/fl_overlay.cxx FLTK_1.x-DirectFB/src/fl_overlay.cxx
--- fltk-1.1.9/src/fl_overlay.cxx	2007-01-18 10:25:09.000000000 -0500
+++ FLTK_1.x-DirectFB/src/fl_overlay.cxx	2009-11-28 15:48:05.994153291 -0500
@@ -36,7 +36,7 @@
 #include <config.h>
 #endif
 
-//#define USE_XOR
+#define USE_XOR
 
 static int px,py,pw,ph;
 
@@ -61,6 +61,11 @@ static void draw_current_rect() {
   // Use the Fl_Overlay_Window instead.
   fl_color(FL_WHITE);
   fl_rect(px, py, pw, ph);
+# elif defined(DIRECTFB)
+  fl_color(FL_WHITE);
+  set_drawing_flags(fl_gc, DSDRAW_XOR);
+  XDrawRectangle(fl_display,fl_window,fl_gc,px,py,pw,ph);
+  set_drawing_flags(fl_gc, DSDRAW_NOFX );
 # else
   XSetFunction(fl_display, fl_gc, GXxor);
   XSetForeground(fl_display, fl_gc, 0xffffffff);
diff -Nwrup -x.git fltk-1.1.9/src/Fl_own_colormap.cxx FLTK_1.x-DirectFB/src/Fl_own_colormap.cxx
--- fltk-1.1.9/src/Fl_own_colormap.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_own_colormap.cxx	2009-11-28 15:48:05.980153496 -0500
@@ -47,6 +47,13 @@ void Fl::own_colormap() {}
 // MacOS X always provides a TrueColor interface...
 
 void Fl::own_colormap() {}
+
+#elif defined(DIRECTFB)
+// do nothing...
+
+void Fl::own_colormap() {
+	fl_open_display();
+}
 #else
 // X version
 
diff -Nwrup -x.git fltk-1.1.9/src/fl_read_image.cxx FLTK_1.x-DirectFB/src/fl_read_image.cxx
--- fltk-1.1.9/src/fl_read_image.cxx	2008-03-09 13:58:10.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_read_image.cxx	2009-11-28 15:48:05.995153660 -0500
@@ -39,13 +39,14 @@
 #elif defined(__APPLE__)
 #  include "fl_read_image_mac.cxx"
 #else
+#if !defined(DIRECTFB)
 #  include <X11/Xutil.h>
 #  ifdef __sgi
 #    include <X11/extensions/readdisplay.h>
 #  else
 #    include <stdlib.h>
 #  endif // __sgi
-
+#endif
 // Defined in fl_color.cxx
 extern uchar fl_redmask, fl_greenmask, fl_bluemask;
 extern int fl_redshift, fl_greenshift, fl_blueshift, fl_extrashift;
@@ -121,7 +122,7 @@ fl_read_image(uchar *p,		// I - Pixel bu
 #  else
   image = 0;
 #  endif // __sgi
-
+#if !defined(DIRECTFB)
   if (!image) {
     // fetch absolute coordinates
     int dx, dy, sx, sy, sw, sh;
@@ -160,7 +161,10 @@ fl_read_image(uchar *p,		// I - Pixel bu
       }
     }
   }
-
+#else
+  if(p)
+    memset(p, alpha, w * h *(alpha?4:3));
+#endif
   if (!image) return 0;
 
 #ifdef DEBUG
@@ -215,7 +219,6 @@ fl_read_image(uchar *p,		// I - Pixel bu
   if (!image->red_mask) {
     // Get the colormap entries for this window...
     maxindex = fl_visual->visual->map_entries;
-
     for (i = 0; i < maxindex; i ++) colors[i].pixel = i;
 
     XQueryColors(fl_display, fl_colormap, colors, maxindex);
diff -Nwrup -x.git fltk-1.1.9/src/fl_rect.cxx FLTK_1.x-DirectFB/src/fl_rect.cxx
--- fltk-1.1.9/src/fl_rect.cxx	2007-02-12 11:41:41.000000000 -0500
+++ FLTK_1.x-DirectFB/src/fl_rect.cxx	2009-11-28 15:48:05.995153660 -0500
@@ -117,6 +117,11 @@ void fl_xyline(int x, int y, int x1, int
   CGContextAddLineToPoint(fl_gc, x1, y2);
   CGContextStrokePath(fl_gc);
   if (fl_quartz_line_width_==1.0f) CGContextSetShouldAntialias(fl_gc, true);
+#elif defined(DIRECTFB)
+  DFBRegion rg[2];
+  rg[0].x1 = x;   rg[0].y1 = y;   rg[0].x2 = x1;  rg[0].y2 = y;
+  rg[1].x1 = x1;  rg[1].y1 = y;   rg[1].x2 = x1;  rg[1].y2 = y2;
+  XDrawLines(fl_display, fl_window, fl_gc, rg, 2, 0);
 #else
   XPoint p[3];
   p[0].x = x;  p[0].y = p[1].y = y;
@@ -146,6 +151,12 @@ void fl_xyline(int x, int y, int x1, int
   CGContextAddLineToPoint(fl_gc, x3, y2);
   CGContextStrokePath(fl_gc);
   if (fl_quartz_line_width_==1.0f) CGContextSetShouldAntialias(fl_gc, true);
+#elif defined(DIRECTFB)
+  DFBRegion rg[3];
+  rg[0].x1 = x;   rg[0].y1 = y;   rg[0].x2 = x1;  rg[0].y2 = y;
+  rg[1].x1 = x1;  rg[1].y1 = y;   rg[1].x2 = x1;  rg[1].y2 = y2;
+  rg[2].x1 = x1;  rg[2].y1 = y2;  rg[2].x2 = x3;  rg[2].y2 = y2;
+  XDrawLines(fl_display, fl_window, fl_gc, rg, 3, 0);
 #else
   XPoint p[4];
   p[0].x = x;  p[0].y = p[1].y = y;
@@ -173,7 +184,8 @@ void fl_yxline(int x, int y, int y1) {
 #endif
 }
 
-void fl_yxline(int x, int y, int y1, int x2) {
+void fl_yxline(int x, int y, int y1, int x2)
+{
 #ifdef WIN32
   if (x2 > x) x2++;
   else x2--;
@@ -191,6 +203,11 @@ void fl_yxline(int x, int y, int y1, int
   CGContextAddLineToPoint(fl_gc, x2, y1);
   CGContextStrokePath(fl_gc);
   if (fl_quartz_line_width_==1.0f) CGContextSetShouldAntialias(fl_gc, true);
+#elif defined(DIRECTFB)
+  DFBRegion rg[2];
+  rg[0].x1 = x;   rg[0].y1 = y;   rg[0].x2 = x;   rg[0].y2 = y1;
+  rg[1].x1 = x;   rg[1].y1 = y1;  rg[1].x2 = x2;  rg[1].y2 = y1;
+  XDrawLines(fl_display, fl_window, fl_gc, rg, 2, 0);
 #else
   XPoint p[3];
   p[0].x = p[1].x = x;  p[0].y = y;
@@ -220,6 +237,12 @@ void fl_yxline(int x, int y, int y1, int
   CGContextAddLineToPoint(fl_gc, x2, y3);
   CGContextStrokePath(fl_gc);
   if (fl_quartz_line_width_==1.0f) CGContextSetShouldAntialias(fl_gc, true);
+#elif defined(DIRECTFB)
+  DFBRegion rg[3];
+  rg[0].x1 = x;   rg[0].y1 = y;   rg[0].x2 = x;   rg[0].y2 = y1;
+  rg[1].x1 = x;   rg[1].y1 = y1;  rg[1].x2 = x2;  rg[1].y2 = y1;
+  rg[2].x1 = x2;  rg[2].y1 = y1;  rg[2].x2 = x2;  rg[2].y2 = y3;
+  XDrawLines(fl_display, fl_window, fl_gc, rg, 3, 0);
 #else
   XPoint p[4];
   p[0].x = p[1].x = x;  p[0].y = y;
@@ -269,6 +292,12 @@ void fl_line(int x, int y, int x1, int y
   CGContextAddLineToPoint(fl_gc, x2, y2);
   CGContextStrokePath(fl_gc);
   if (fl_quartz_line_width_==1.0f ) CGContextSetShouldAntialias(fl_gc, true);
+#elif defined(DIRECTFB)
+  DFBRegion rg[2];
+  rg[0].x1 = x;				rg[0].y1 = y;
+  rg[1].x1 = rg[0].x2 = x1;	rg[1].y1 = rg[0].y2 = y1;
+  rg[1].x2 = x2;			rg[1].y2 = y2;
+  XDrawLines(fl_display, fl_window, fl_gc, rg, 2, 0);
 #else
   XPoint p[3];
   p[0].x = x;  p[0].y = y;
@@ -295,6 +324,12 @@ void fl_loop(int x, int y, int x1, int y
   CGContextAddLineToPoint(fl_gc, x2, y2);
   CGContextClosePath(fl_gc);
   CGContextStrokePath(fl_gc);
+#elif defined(DIRECTFB)  
+  DFBRegion rg[3];
+  rg[0].x1 = rg[2].x2 = x;	rg[0].y1 = rg[2].y2 = y;
+  rg[1].x1 = rg[0].x2 = x1;	rg[1].y1 = rg[0].y2 = y1;
+  rg[2].x1 = rg[1].x2 = x2;	rg[2].y1 = rg[1].y2 = y2;
+  XDrawLines(fl_display, fl_window, fl_gc, rg, 3, 0);
 #else
   XPoint p[4];
   p[0].x = x;  p[0].y = y;
@@ -325,6 +360,13 @@ void fl_loop(int x, int y, int x1, int y
   CGContextAddLineToPoint(fl_gc, x3, y3);
   CGContextClosePath(fl_gc);
   CGContextStrokePath(fl_gc);
+#elif defined(DIRECTFB)  
+	DFBRegion rg[4];
+	rg[0].x1 = rg[3].x2 = x;	rg[0].y1 = rg[3].y2 = y;
+	rg[1].x1 = rg[0].x2 = x1;	rg[1].y1 = rg[0].y2 = y1;
+	rg[2].x1 = rg[1].x2 = x2;	rg[2].y1 = rg[1].y2 = y2;
+	rg[3].x1 = rg[2].x2 = x3;	rg[3].y1 = rg[2].y2 = y3;
+	XDrawLines(fl_display, fl_window, fl_gc, rg, 4, 0);
 #else
   XPoint p[5];
   p[0].x = x;  p[0].y = y;
@@ -335,6 +377,7 @@ void fl_loop(int x, int y, int x1, int y
   XDrawLines(fl_display, fl_window, fl_gc, p, 5, 0);
 #endif
 }
+//DFBRegion cur_clip_reg;
 
 void fl_polygon(int x, int y, int x1, int y1, int x2, int y2) {
   XPoint p[4];
@@ -360,6 +403,18 @@ void fl_polygon(int x, int y, int x1, in
   CGContextAddLineToPoint(fl_gc, x2, y2);
   CGContextClosePath(fl_gc);
   CGContextFillPath(fl_gc);
+#elif defined(DIRECTFB)  
+# if 0//DirectFB 0.9.25 CRASHED (!!!) if clipping region is used 
+	_FillTriangle(fl_gc, x, y, x1, y1, x2, y2); 
+# else	// using software version of polygon
+{
+	POINT_f p[3];
+	p[0].x = x;  p[0].y = y;
+  	p[1].x = x1; p[1].y = y1;
+  	p[2].x = x2; p[2].y = y2;
+	FillPoly(fl_window, fl_gc, 3, p); 
+}
+# endif	
 #else
   p[3].x = x;  p[3].y = y;
   XFillPolygon(fl_display, fl_window, fl_gc, p, 3, Convex, 0);
@@ -394,6 +449,15 @@ void fl_polygon(int x, int y, int x1, in
   CGContextAddLineToPoint(fl_gc, x3, y3);
   CGContextClosePath(fl_gc);
   CGContextFillPath(fl_gc);
+#elif defined(DIRECTFB)
+{
+  POINT_f p[5];
+  p[0].x = x;  p[0].y = y;
+  p[1].x = x1; p[1].y = y1;
+  p[2].x = x2; p[2].y = y2;
+  p[3].x = x3; p[3].y = y3;
+  FillPoly(fl_window, fl_gc, 4, p);  
+}
 #else
   p[4].x = x;  p[4].y = y;
   XFillPolygon(fl_display, fl_window, fl_gc, p, 4, Convex, 0);
@@ -412,6 +476,11 @@ void fl_point(int x, int y) {
   CGContextAddLineToPoint(fl_gc, x, y);
   CGContextStrokePath(fl_gc);
   if (fl_quartz_line_width_==1.0f) CGContextSetShouldAntialias(fl_gc, true);
+#elif defined(DIRECTFB)
+  XDrawLine(fl_display, fl_window, fl_gc, x, y, x, y);
+  //draw_line(fl_window, x, y, x, y);
+#define width w
+#define height h
 #else
   XDrawPoint(fl_display, fl_window, fl_gc, x, y);
 #endif
@@ -425,7 +494,7 @@ static Fl_Region rstack[STACK_SIZE];
 static int rstackptr=0;
 int fl_clip_state_number=0; // used by gl_begin.cxx to update GL clip
 
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
 // Missing X call: (is this the fastest way to init a 1-rectangle region?)
 // MSWindows equivalent exists, implemented inline in win32.H
 Fl_Region XRectangleRegion(int x, int y, int w, int h) {
@@ -679,7 +748,10 @@ int fl_clip_box(int x, int y, int w, int
   return 1;
 #endif
 }
-
+#ifdef DIRECTFB
+#undef width
+#undef height
+#endif
 //
 // End of "$Id: fl_rect.cxx 5692 2007-02-12 16:41:41Z matt $".
 //
diff -Nwrup -x.git fltk-1.1.9/src/fl_vertex.cxx FLTK_1.x-DirectFB/src/fl_vertex.cxx
--- fltk-1.1.9/src/fl_vertex.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/fl_vertex.cxx	2009-11-28 15:48:05.997153922 -0500
@@ -97,6 +97,9 @@ typedef float COORD_T;
 typedef struct { float x; float y; } QPoint;
 #  define XPOINT QPoint
 extern float fl_quartz_line_width_;
+#elif defined(DIRECTFB)
+typedef float COORD_T;
+#define XPOINT POINT_f
 #else
 typedef short COORD_T;
 #  define XPOINT XPoint
@@ -117,6 +120,17 @@ void fl_begin_loop() {n = 0; what = LOOP
 
 void fl_begin_polygon() {n = 0; what = POLYGON;}
 
+#ifdef DIRECTFB 
+static int smooth=0;
+
+void fl_begin_smooth_line(){n = 0; what = LINE; smooth=1;}
+
+void fl_begin_smooth_loop() {n = 0; what = LOOP; smooth=1;};
+
+void fl_begin_smooth_polygon(){n = 0; what = POLYGON; smooth=1;}
+
+#endif
+
 double fl_transform_x(double x, double y) {return x*m.a + y*m.c + m.x;}
 
 double fl_transform_y(double x, double y) {return x*m.b + y*m.d + m.y;}
@@ -138,7 +152,7 @@ static void fl_transformed_vertex(COORD_
 }
 
 void fl_transformed_vertex(double xf, double yf) {
-#ifdef __APPLE_QUARTZ__
+#if defined(__APPLE_QUARTZ__) || defined(DIRECTFB)
   fl_transformed_vertex(COORD_T(xf), COORD_T(yf));
 #else
   fl_transformed_vertex(COORD_T(rint(xf)), COORD_T(rint(yf)));
@@ -162,6 +176,9 @@ void fl_end_points() {
     CGContextStrokePath(fl_gc);
   }
   if (fl_quartz_line_width_==1.0f) CGContextSetShouldAntialias(fl_gc, false);
+#elif defined(DIRECTFB)
+    for (int i=0; i<n; i++)
+      draw_line_i(p[i].x, p[i].y, p[i].x, p[i].y);
 #else
   if (n>1) XDrawPoints(fl_display, fl_window, fl_gc, p, n, 0);
 #endif
@@ -184,6 +201,16 @@ void fl_end_line() {
   for (int i=1; i<n; i++)
     CGContextAddLineToPoint(fl_gc, p[i].x, p[i].y);
   CGContextStrokePath(fl_gc);
+#elif defined(DIRECTFB)
+  for (int i=1; i < n; i++){
+#ifdef SMOOTH_DRAWING
+    if (smooth)
+      draw_line_r(p[i-1].x, p[i-1].y, p[i].x, p[i].y);
+    else
+#endif /* SMOOTH_DRAWING */ 
+      draw_line_i(p[i-1].x, p[i-1].y, p[i].x, p[i].y);
+    }
+    smooth=0;
 #else
   if (n>1) XDrawLines(fl_display, fl_window, fl_gc, p, n, 0);
 #endif
@@ -225,6 +252,14 @@ void fl_end_polygon() {
     CGContextAddLineToPoint(fl_gc, p[i].x, p[i].y);
   CGContextClosePath(fl_gc);
   CGContextFillPath(fl_gc);
+#elif defined(DIRECTFB)
+#ifdef SMOOTH_DRAWING
+  if(smooth)
+    SmoothPoly(fl_gc,n,p);
+  else
+#endif /* SMOOTH_DRAWING */
+    FillPoly(fl_window,fl_gc,n,p);
+  smooth=0;
 #else
   if (n>2) XFillPolygon(fl_display, fl_window, fl_gc, p, n, Convex, 0);
 #endif
@@ -283,9 +318,12 @@ void fl_end_complex_polygon() {
     CGContextAddLineToPoint(fl_gc, p[i].x, p[i].y);
   CGContextClosePath(fl_gc);
   CGContextFillPath(fl_gc);
+#elif defined(DIRECTFB)
+  FillPoly(fl_window, fl_gc, n, p);
 #else
   if (n>2) XFillPolygon(fl_display, fl_window, fl_gc, p, n, 0, 0);
 #endif
+
 }
 
 // shortcut the closed circles so they use XDrawArc:
@@ -314,6 +352,8 @@ void fl_circle(double x, double y,double
   // Quartz warning : circle won't scale to current matrix!
   CGContextAddArc(fl_gc, xt, yt, (w+h)*0.25f, 0, 2.0f*M_PI, 1);
   (what == POLYGON ? CGContextFillPath : CGContextStrokePath)(fl_gc);
+#elif defined(DIRECTFB)
+  ArcAngle(fl_gc,llx,lly,w-1,h-1,0,360,(what==POLYGON ? PIE : ARC));
 #else
   (what == POLYGON ? XFillArc : XDrawArc)
     (fl_display, fl_window, fl_gc, llx, lly, w, h, 0, 360*64);
diff -Nwrup -x.git fltk-1.1.9/src/Fl_visual.cxx FLTK_1.x-DirectFB/src/Fl_visual.cxx
--- fltk-1.1.9/src/Fl_visual.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_visual.cxx	2009-11-28 15:48:05.980153496 -0500
@@ -27,6 +27,8 @@
 
 // Set the default visual according to passed switches:
 
+#include <stdio.h>
+
 #include <config.h>
 #include <FL/Fl.H>
 #include <FL/x.H>
@@ -47,7 +49,10 @@ int Fl::visual(int flags) {
   (void)flags;
   return 1;
 }
-
+#elif defined(DIRECTFB)
+int Fl::visual(int flags) {
+  return 1;
+}
 #else
 
 #if USE_XDBE
@@ -103,14 +108,17 @@ int Fl::visual(int flags) {
   XVisualInfo *visualList = XGetVisualInfo(fl_display, 0, &vTemplate, &num);
   // find all matches, use the one with greatest depth:
   XVisualInfo *found = 0;
+
   for (int i=0; i<num; i++) if (test_visual(visualList[i], flags)) {
     if (!found || found->depth < visualList[i].depth)
       found = &visualList[i];
   }
   if (!found) {XFree((void*)visualList); return 0;}
   fl_visual = found;
+
   fl_colormap = XCreateColormap(fl_display, RootWindow(fl_display,fl_screen),
 				fl_visual->visual, AllocNone);
+
   return 1;
 }
 
diff -Nwrup -x.git fltk-1.1.9/src/Fl_Window_fullscreen.cxx FLTK_1.x-DirectFB/src/Fl_Window_fullscreen.cxx
--- fltk-1.1.9/src/Fl_Window_fullscreen.cxx	2006-06-09 12:16:34.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_Window_fullscreen.cxx	2009-11-28 15:48:05.976154076 -0500
@@ -63,6 +63,13 @@ void Fl_Window::border(int b) {
 }
 
 void Fl_Window::fullscreen() {
+#ifdef DIRECTFB
+  border(0);
+  if (shown())  
+   	i->set_maximize();
+  else
+  	resize(0,0,Fl::w(),Fl::h());
+#else	
 #ifndef WIN32
   //this would clobber the fake wm, since it relies on the border flags to
   //determine its thickness
@@ -82,14 +89,23 @@ void Fl_Window::fullscreen() {
   if (!x()) x(1); // force it to call XResizeWindow()
   resize(0,0,Fl::w(),Fl::h());
 #endif
+#endif //DIRECTFB
 }
 
 void Fl_Window::fullscreen_off(int X,int Y,int W,int H) {
+#ifdef DIRECTFB
+  border(1);
+  if (shown())  
+  	i->restore_size(X,Y,W,H);
+  else
+  	resize(X,Y,W,H);	
+#else		
   // this order produces less blinking on IRIX:
   resize(X,Y,W,H);
 #ifndef WIN32
   border(1);
 #endif
+#endif
 }
 
 //
diff -Nwrup -x.git fltk-1.1.9/src/Fl_x.cxx FLTK_1.x-DirectFB/src/Fl_x.cxx
--- fltk-1.1.9/src/Fl_x.cxx	2007-06-18 09:08:57.000000000 -0400
+++ FLTK_1.x-DirectFB/src/Fl_x.cxx	2009-11-28 15:48:05.982153769 -0500
@@ -24,11 +24,14 @@
 //
 //     http://www.fltk.org/str.php
 //
+#include <config.h>//I dont know why, but I have no macroses here...
 
 #ifdef WIN32
 //#  include "Fl_win32.cxx"
 #elif defined(__APPLE__)
 //#  include "Fl_mac.cxx"
+#elif defined(DIRECTFB)
+//#  include "Fl_directfb.cxx"
 #else
 
 #  define CONSOLIDATE_MOTION 1
diff -Nwrup -x.git fltk-1.1.9/src/_image.cxx FLTK_1.x-DirectFB/src/_image.cxx
--- fltk-1.1.9/src/_image.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/_image.cxx	2009-11-28 15:48:05.985156050 -0500
@@ -0,0 +1,758 @@
+//
+// "$Id: _image.cxx,v 1.2 2006-10-31 09:31:14 nikego Exp $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+// Written by Nikita Egorov (NikeGo@gmail.com)
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains image drawing code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+
+
+D_DEBUG_DOMAIN(IMAGE_CXX, "_image", "FLTK _image.cxx");
+
+#define MSCURSORSIZE 32
+
+static struct dfb_cursors {
+    unsigned int cur_type;   
+    unsigned char bits[MSCURSORSIZE*MSCURSORSIZE/8+1];
+    u8 mask[MSCURSORSIZE*MSCURSORSIZE/8+1];
+    Cursor cursor;
+    int w;
+    int h;
+    int hotx;
+    int hoty;
+} ms_table[]= { 
+    
+{(FL_CURSOR_ARROW-1)*2, 
+{0x00,0x00,0x00,0x00,0x02,0x00,0x06,0x00,0x0E,0x00,0x1E,0x00,0x3E,0x00,0x7E,0x00,
+0xFE,0x00,0xFE,0x01,0x3E,0x00,0x36,0x00,0x62,0x00,0x60,0x00,0xC0,0x00,0xC0,0x00,
+0x80,0x01,0x80,0x01,0x00,0x00}, 
+{0x01,0x00,0x03,0x00,0x07,0x00,0x0F,0x00,0x1F,0x00,0x3F,0x00,0x7F,0x00,0xFF,0x00,
+0xFF,0x01,0xFF,0x03,0xFF,0x07,0x7F,0x00,0xF7,0x00,0xF3,0x00,0xE1,0x01,0xE0,0x01,
+0xC0,0x03,0xC0,0x03,0x80,0x01},
+0,11,19,1,1},
+{(FL_CURSOR_INSERT-1)*2,
+{0x00,0x00,0x70,0x07,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
+0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,0x80,0x00,
+0x70,0x07,0x00,0x00},
+{0x78,0x0F,0xF8,0x0F,0xF8,0x0F,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,
+0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xC0,0x01,0xF8,0x0F,
+0xF8,0x0F,0x78,0x0F},
+0,12,18,7,9},
+{(FL_CURSOR_WAIT-1)*2, 
+{0x00,0x00,0xF0,0x1F,0x00,0x00,0xF0,0x1F,0xF0,0x1F,0xB0,0x1A,
+ 0x70,0x1D,0xE0,0x0E,0xC0,0x07,0x80,0x02,0x00,0x01,0x00,0x01,
+ 0x80,0x03,0xC0,0x06,0xE0,0x0F,0xF0,0x1E,0x70,0x1D,0xB0,0x1A,
+ 0x50,0x15,0x00,0x00,0xF0,0x1F,0x00,0x00},
+{0xFC,0x7F,0xFC,0x7F,0xFC,0x7F,0xF8,0x3F,0xF8,0x3F,0xF8,0x3F
+,0xF8,0x3F,0xF8,0x3F,0xF0,0x1F,0xE0,0x0F,0xC0,0x07,0xC0,0x07
+,0xE0,0x0F,0xF0,0x1F,0xF8,0x3F,0xF8,0x3F,0xF8,0x3F,0xF8,0x3F
+,0xF8,0x3F,0xFC,0x7F,0xFC,0x7F,0xFC,0x7F},
+0,15,22,8,11},
+{(FL_CURSOR_CROSS-1)*2,
+{0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
+0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
+0x00,0x80,0x00,0x00,0x80,0xFF,0xFF,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
+0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
+0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00},
+{0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,
+0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,
+0xC0,0xFF,0xFF,0x01,0xC0,0xFF,0xFF,0x01,0xC0,0xFF,0xFF,0x01,0x00,0xC0,0x01,0x00,
+0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,
+0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00,0x00,0xC0,0x01,0x00},
+0,25,19,15,9},
+{(FL_CURSOR_HAND-1)*2,
+{0x00,0x30,0x00,0x00,0x28,0x00,0x00,0x28,0x00,0x00,0x28,0x00,
+0x00,0x28,0x00,0x00,0xA8,0x01,0x00,0x28,0x0D,0x00,0x28,0x09,
+0x00,0x28,0x69,0x60,0x28,0x49,0xE0,0x48,0x4A,0x40,0x09,0x50,
+0x40,0x02,0x40,0x80,0x0C,0x40,0x80,0x00,0x40,0x00,0x01,0x40,
+0x00,0x01,0x20,0x00,0x02,0x20,0x00,0x02,0x20,0x00,0x04,0x10,
+0x00,0x08,0x10,0x00,0x10,0x08,0x00,0x10,0x08,0x00,0x30,0x00,
+0x00,0xF8,0x1F,0x00,0xF8,0x1F,0x00,0xF8,0x1F,0x00,0xF8,0x1F,
+0x00,0xF8,0x1F},
+{0x00,0x30,0x00,0x00,0x38,0x00,0x00,0x38,0x00,0x00,0x38,0x00,
+0x00,0x38,0x00,0x00,0xB8,0x01,0x00,0xB8,0x0D,0x00,0xB8,0x0D,
+0x00,0xB8,0x6D,0x60,0xB8,0x6D,0xE0,0xF8,0x6F,0xC0,0xF9,0x7F,
+0xC0,0xF3,0x7F,0x80,0xFF,0x7F,0x80,0xFF,0x7F,0x00,0xFF,0x7F,
+0x00,0xFF,0x3F,0x00,0xFE,0x3F,0x00,0xFE,0x3F,0x00,0xFC,0x1F,
+0x00,0xF8,0x1F,0x00,0xF0,0x0F,0x00,0xF0,0x0F,0x00,0x30,0x00,
+0x00,0xF8,0x1F,0x00,0xF8,0x1F,0x00,0xF8,0x1F,0x00,0xF8,0x1F,
+0x00,0xF8,0x1F}, 
+0,24,29,12,0},
+{(FL_CURSOR_MOVE-1)*2,
+{0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0xC0,0x01,0x00,0x00,0xE0,0x03,0x00,
+0x00,0xF0,0x07,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x82,0x20,0x00,
+0x00,0x83,0x60,0x00,0x80,0x83,0xE0,0x00,0xC0,0xFF,0xFF,0x01,0x80,0x83,0xE0,0x00,
+0x00,0x83,0x60,0x00,0x00,0x82,0x20,0x00,0x00,0x80,0x00,0x00,0x00,0x80,0x00,0x00,
+0x00,0xF0,0x07,0x00,0x00,0xE0,0x03,0x00,0x00,0xC0,0x01,0x00,0x00,0x80,0x00,0x00,
+0x00,0x00,0x00,0x00},
+{0x00,0x80,0x00,0x00,0x00,0xC0,0x01,0x00,0x00,0xE0,0x03,0x00,0x00,0xF0,0x07,0x00,
+0x00,0xF8,0x0F,0x00,0x00,0xF8,0x0F,0x00,0x00,0xC6,0x31,0x00,0x00,0xC7,0x71,0x00,
+0x80,0xC7,0xF1,0x00,0xC0,0xFF,0xFF,0x01,0xE0,0xFF,0xFF,0x03,0xC0,0xFF,0xFF,0x01,
+0x80,0xC7,0xF1,0x00,0x00,0xC7,0x71,0x00,0x00,0xC6,0x31,0x00,0x00,0xF8,0x0F,0x00,
+0x00,0xF8,0x0F,0x00,0x00,0xF0,0x07,0x00,0x00,0xE0,0x03,0x00,0x00,0xC0,0x01,0x00,
+0x00,0x80,0x00,0x00}, 
+0,31,21,15,10},
+{(FL_CURSOR_HELP-1)*2,
+{0x00,0x00,0x00,0x00,0x00,0x00,0xFE,0x00,0x40,0x00,0x01,0x01,0xC0,0x80,0x18,0x02,
+0xC0,0x41,0x24,0x04,0xC0,0x43,0x24,0x04,0xC0,0x47,0x24,0x04,0xC0,0x4F,0x24,0x02,
+0xC0,0x9F,0x17,0x01,0xC0,0x3F,0x88,0x00,0xC0,0x07,0x44,0x00,0xC0,0x06,0x44,0x00,
+0x40,0x0C,0x44,0x00,0x00,0x0C,0x38,0x00,0x00,0x18,0x44,0x00,0x00,0x18,0x82,0x00,
+0x00,0x30,0x44,0x00,0x00,0x30,0x38,0x00,0x00,0x00,0x00,0x00},
+{0x20,0x00,0x00,0x00,0x60,0x00,0x00,0x00,0xE0,0x00,0xFE,0x00,0xE0,0x01,0xE7,0x01,
+0xE0,0x83,0xC3,0x07,0xE0,0x87,0xC3,0x07,0xE0,0x8F,0xC3,0x07,0xE0,0x9F,0xC3,0x01,
+0xE0,0x3F,0xE0,0x00,0xE0,0x7F,0x70,0x00,0xE0,0xFF,0x38,0x00,0xE0,0x0F,0x38,0x00,
+0xE0,0x1E,0x38,0x00,0x60,0x1E,0x00,0x00,0x20,0x3C,0x38,0x00,0x00,0x3C,0x7C,0x00,
+0x00,0x78,0x38,0x00,0x00,0x78,0x00,0x00,0x00,0x30,0x00,0x00},
+0,27,19,1,1},
+{0xFFFFFFFF,""}};
+
+/************************************************************************
+ * image functions 
+ */
+int 
+XPutImage(Display* display, Drawable d, GC gc,\
+           XImage * image, int src_x, int src_y,\
+           int dest_x, int dest_y,\
+           unsigned int width, unsigned int height)
+{
+  GC ctx = ISGC(d);
+  if (!ctx)
+     ctx = gc;
+  
+  int pix_f    = get_pixel_format(ctx);
+  int bytes_pp = DFB_BYTES_PER_PIXEL(pix_f);
+
+  if ((DFB_BITS_PER_PIXEL(pix_f) == image->bits_per_pixel)) {
+
+    DFBSurfaceDescription desc;
+    memset(&desc, 0, sizeof(DFBSurfaceDescription));
+    desc.flags  = (DFBSurfaceDescriptionFlags)\
+      (DSDESC_CAPS|DSDESC_WIDTH|DSDESC_HEIGHT|DSDESC_PIXELFORMAT/*|DSDESC_PREALLOCATED*/);
+    desc.caps         = DSCAPS_SYSTEMONLY;
+    desc.pixelformat  = (DFBSurfacePixelFormat)pix_f;
+    desc.height       = height;
+    desc.width        = width;
+
+   // desc.preallocated[0].data   = src;
+   // desc.preallocated[0].pitch  = image->bytes_per_line;
+
+    GC image_gc = create_gc(&desc);
+    if (image_gc) {
+        int pitch;
+        u8 *buf = (u8*)lock_surface(image_gc, DSLF_WRITE, &pitch);
+        if (!buf) {
+            release_gc(image_gc);
+            return 0;
+        }
+        u8 *src = (u8*)(image->data + src_y * image->bytes_per_line + src_x * bytes_pp);
+
+        u8 *s = src;
+        u8 *d = buf;
+        for (unsigned i = 0; i < height; i++) {
+          for (int j = 0; j < image->bytes_per_line; j+=bytes_pp){
+            switch(bytes_pp){
+            case 2:
+              STORE_U16_VO((d+j), *(u16*)(s+j));
+              break;
+            case 4:
+              STORE_U32_VO((d+j), *(u32*)(d+j));
+              break;
+            }
+          }
+          s += image->bytes_per_line;
+          d += pitch;
+        }
+        unlock_surface(image_gc);
+
+        DFBRectangle rect = { x:src_x, y:src_y, w:width, h:height };
+        blit(ctx, image_gc, &rect, dest_x, dest_y);
+        release_gc(image_gc);
+    }
+    update_region(ctx, DFB_REGION_VALS_FROM_RECTANGLE_VALS(dest_x, dest_y, width, height));
+    return 1;
+  }
+  return 0;
+}
+
+/* implementation of XDestroyImage() */
+int
+XDestroyImage(XImage *image)
+{
+  if (image->data)
+    Xfree(image->data);
+  Xfree(image);
+  return 1;
+}
+
+/*************************************************************************
+ * stubs
+ */
+ 
+XImage*
+XGetImage(Display * display, Drawable d, int x, int y,
+    unsigned int width, unsigned int height,
+    unsigned long plane_mask, int format)
+{
+    D_ONCE("XGetImage() not supported!\n");
+    return 0;
+}
+
+XImage*
+XCreateImage(Display *display, Visual* visual, unsigned int depth,
+    int format, int offset, char *data, unsigned int width,
+    unsigned int height, int bitmap_pad, int bytes_per_line)
+{
+    D_ONCE("XCreateImage() not supported!\n");
+    return 0;
+}
+
+int 
+XCopyArea(Display *display, Drawable src, Drawable dest, GC gc,\
+        int src_x,int src_y,\
+        unsigned width,unsigned height,\
+        int dest_x,int dest_y)
+{
+  DFBRectangle rect = { x:src_x, y:src_y, w:width, h:height};
+  Surface s = ISGC( src );
+  if (!s) 
+    s = gc;
+  Surface d = ISGC( dest );
+  if (!d) 
+    d = gc;
+  set_blitting_flags(d, DSBLIT_NOFX);
+  blit(d, s, &rect, dest_x, dest_y);
+  update_region(d, DFB_REGION_VALS_FROM_RECTANGLE_VALS(dest_x, dest_y, width, height));
+  return 0;
+}
+
+/**********************************************************************
+ *  cursor functions  
+ */
+ 
+/* implementation of XCreatePixmapCursor() */
+Cursor 
+XCreatePixmapCursor(Display* display, Pixmap source,\
+                    Pixmap mask, XColor *fg_col, XColor *bg_col,\
+                    unsigned hot_x, unsigned hot_y)
+{
+  if (!fg_col || !bg_col)
+    return 0;
+
+  if (!DFB_PIXELFORMAT_HAS_ALPHA(get_pixel_format(ISGC(source))) ||
+      !DFB_PIXELFORMAT_HAS_ALPHA(get_pixel_format(ISGC(mask))))
+    return 0;
+
+  Cursor c = (Cursor)Xmalloc(sizeof(_cursor));
+  if (!c)
+    return 0;
+
+  c->hot_x = hot_x;
+  c->hot_y = hot_y;
+
+  DFBRectangle rect = { 0 };
+  get_size(ISGC(source), &rect.w, &rect.h);
+
+  c->mask   = (Pixmap)create_gc(ISGC(mask), &rect);
+  c->source = (Pixmap)create_gc(ISGC(source), &rect);
+
+  c->shape = create_pixmap(rect.w, rect.h, DSPF_ARGB);
+
+  XRecolorCursor(display, c, fg_col, bg_col);
+  return c;
+}
+
+/* implementation of XRecolorCursor() */
+int 
+XRecolorCursor(Display* display, Cursor cursor, XColor *fg_col, XColor *bg_col)
+{
+    if (!cursor || !cursor->shape || !cursor->mask || !cursor->source)
+        return -1;
+        
+#define  f_r (fg_col->red >> 8)
+#define  f_g (fg_col->green >> 8)
+#define  f_b (fg_col->blue >> 8)
+#define  b_r (bg_col->red >> 8)
+#define  b_g (bg_col->green >> 8)
+#define  b_b (bg_col->blue >> 8)
+    
+    DFBRectangle rect = {0};
+    Surface source    = ISGC(cursor->source);
+    Surface shape     = ISGC(cursor->shape);
+    Surface mask      = ISGC(cursor->mask);
+
+    get_size(source, &rect.w, &rect.h);
+    set_color(shape, 0, 0, 0, 0);
+    
+    // filling transparent background
+    shape->surface->FillRectangle(shape->surface, 0, 0, rect.w, rect.h);
+
+    // prepare to blit the mask 
+    set_blitting_flags(shape, DSBLIT_COLORIZE | DSBLIT_BLEND_ALPHACHANNEL);
+    
+    set_porter_duff(shape, DSPD_SRC);
+    set_color(shape, b_r, b_g, b_b, 255);
+    
+    // draw the mask
+    blit(shape, mask, &rect, 0, 0);
+ 
+    set_porter_duff(shape, DSPD_NONE);
+    set_color(shape, f_r, f_g, f_b, 255);
+    
+    // drawing the source
+    blit(shape, source, &rect, 0, 0);
+    return 0;
+}
+
+/* implementation of XCreateFontCursor() */
+Cursor
+XCreateFontCursor(Display *display, unsigned int shape)
+{
+    Cursor xc = 0;
+    for (int i = 0 ;ms_table[i].cur_type != 0xFFFFFFFF; i++){
+        if (shape == ms_table[i].cur_type){ 
+            if (!ms_table[i].cursor){
+              Pixmap p = (Pixmap)XCreateBitmapFromData(fl_display, fl_window, (char*)ms_table[i].bits , ms_table[i].w,ms_table[i].h);
+              Pixmap m = (Pixmap)XCreateBitmapFromData(fl_display, fl_window, (char*)ms_table[i].mask , ms_table[i].w,ms_table[i].h);
+              XColor dummy = { 0 };
+              ms_table[i].cursor = XCreatePixmapCursor(fl_display, p, m, &dummy, &dummy, ms_table[i].hotx, ms_table[i].hoty);
+              XFreePixmap(fl_display, p);
+              XFreePixmap(fl_display, m);
+           }
+           xc = ms_table[i].cursor;
+           break;
+       }
+    }
+    return xc;
+}
+
+/* implementation of XCreateFreeCursor() */
+void 
+XFreeCursor(Display* display, Cursor xc)
+{ 
+    if (xc){
+        for (int i = 0 ;ms_table[i].cur_type != 0xFFFFFFFF; i++)
+           if (xc == ms_table[i].cursor)
+                return;
+        release_gc(ISGC(xc->shape));
+        release_gc(ISGC(xc->mask));
+        release_gc(ISGC(xc->source));
+        Xfree(xc); 
+    }
+}
+
+
+/* implementation of XDefineCursor() */
+void
+XDefineCursor(Display* display, Window xid, Cursor c)
+{
+  Fl_Window* window = fl_find(xid);
+  if (!window)
+    return;
+  Fl_X* w = Fl_X::i(window);
+  if (!w)
+    return;
+  if (c) {
+    w->cursors[1] = c;
+  } else {
+     c = w->cursors[0];
+  }
+  set_cursor_shape(display, NULL, 0, 0);//release old shape
+  if (c)
+   set_cursor_shape(display, ISGC(c->shape), c->hot_x, c->hot_y);
+
+}
+
+/*********************************************************************
+ * bits/bytes conversions 
+ */
+ 
+inline static void 
+bits_to_bytes(const u8* src, u8* dst, int lines, int w , int dst_pitch)
+{
+    int src_pitch = (w+7)/8,n,j;
+    for (n = 0; n < lines; n++){
+        for (j = 0; j < w; j++)
+            dst[j] = src[j / 8] & (1 << (j & 7)) ? 255 : 0;
+        src += src_pitch;    
+        dst += dst_pitch;
+    }
+}
+
+inline static void 
+reverse_bits(const u8* src, u8* dst, int lines, int w , int dst_pitch)
+{
+    static u8 reverse[16] =    /* Bit reversal lookup table */
+    { 0x00, 0x88, 0x44, 0xcc, 0x22, 0xaa, 0x66, 0xee,
+      0x11, 0x99, 0x55, 0xdd, 0x33, 0xbb, 0x77, 0xff };
+      
+    int pitch = (w+7)/8,i,j;
+    for (i = 0; i < lines; i++){
+        for (j = 0; j < pitch; j++)
+            dst[j] = (reverse[src[j] & 0x0f] & 0xf0) |
+                     (reverse[(src[j] >> 4) & 0x0f] & 0x0f);
+        src += pitch;    
+        dst += dst_pitch;
+    }
+}
+
+inline static void 
+fill_bits(const u8* src, u8* dst, int lines, int w , int dst_pitch)
+{
+    int pitch = (w+7)/8,i,j;
+    for (i = 0; i < lines; i++){
+        for (j = 0; j < pitch; j++)
+            dst[j] = src[j];
+        src += pitch;    
+        dst += dst_pitch;
+    }
+}
+
+Pixmap
+XCreateBitmapFromData(Display* display, Window win, const char *data,
+                      unsigned width, unsigned height)
+{
+  DFBSurfaceDescription desc;
+  desc.caps = DSCAPS_NONE;
+  desc.flags = (DFBSurfaceDescriptionFlags)(DSDESC_CAPS|DSDESC_WIDTH|DSDESC_HEIGHT|DSDESC_PIXELFORMAT);
+  desc.pixelformat = DSPF_A8;//can be DSPF_A1
+  desc.height = height;
+  desc.width = width;
+
+  GC bmp_gc = create_gc(&desc);
+  int pitch=0;
+  u8 *buf = (u8*)lock_surface(bmp_gc, DSLF_WRITE, &pitch);
+  memset(buf, 0x00, height * pitch);
+  switch(desc.pixelformat){
+  case DSPF_A1:
+    reverse_bits((u8*)data, buf, height, width, pitch);
+    break;
+  case DSPF_A8:
+    bits_to_bytes((u8*)data, buf, height, width, pitch);
+    break;
+  default:
+    break;
+  }
+  unlock_surface(bmp_gc);
+  return (Pixmap)bmp_gc;
+}
+
+/********************************************************************
+ * FLTK's functions :
+ * off-screen pixmaps: create, destroy, draw into, copy to window:
+ */
+
+Fl_Offscreen fl_create_offscreen_rgb(int w,int h)
+{
+	return (Fl_Offscreen)create_pixmap(w, h, DSPF_RGB32);
+}
+
+Fl_Offscreen fl_create_offscreen_argb(int w,int h)
+{
+	return (Fl_Offscreen)create_pixmap(w, h, DSPF_ARGB);
+}
+
+Fl_Offscreen fl_create_offscreen(int w,int h)
+{
+	return (Fl_Offscreen)create_pixmap(w ,h);
+}
+
+void fl_delete_offscreen(Fl_Offscreen offscreen)
+{
+	release_gc(ISGC(offscreen));
+}
+
+// begin/end are functions that save the old state in static variables:
+
+static Pixmap _tmp_surface=0;
+#include <FL/fl_draw.H>
+
+void fl_begin_offscreen(Pixmap offscreen)
+{
+	_tmp_surface = fl_window;
+	fl_window    = offscreen;
+	fl_push_no_clip();
+}
+
+void fl_end_offscreen()
+{
+	fl_pop_clip();
+	fl_window = _tmp_surface;
+}
+
+void fl_copy_offscreen_bk(int x,int y,int w,int h,Pixmap pixmap,int srcx,int srcy,ulong bkcolor)
+{
+	DFBRectangle rect={ x:srcx,y:srcy,w:w,h:h };
+    Surface in  = ISGC(pixmap);
+    Surface out = ISGC(fl_window);
+    if (!out)
+      out = fl_gc;
+
+	set_blitting_flags(out, DSBLIT_SRC_COLORKEY);
+	set_src_color_key(in, bkcolor);
+	blit(out, in, &rect, x, y);
+    update_region(out, DFB_REGION_VALS_FROM_RECTANGLE_VALS(x, y, w, h));
+}
+
+void fl_draw_abgr_to_argb(const uchar* array, int x, int y, int w, int h)
+{
+  Surface surf = ISGC(fl_window);
+  if (!surf)
+      surf = fl_gc;
+
+  if (get_pixel_format(surf) != DSPF_ARGB)
+    return;
+
+  int i,j,pitch = 0;
+  u32* buf = (u32*)lock_surface(surf, DSLF_READ|DSLF_WRITE, &pitch);
+  if (buf){
+    u32* src = (u32*)array;
+    u32* dst = buf + y*pitch/sizeof(u32) + x;
+    for (j=0;j<h;j++){
+      for (i=0;i<w;i++){
+        u32 c = LOAD_U32_VO(src+i);
+#if defined(WORDS_BIGENDIAN) && !defined(REVERSE_BYTES)
+        //FIXME, may be that is correct only for crosscompiled programs
+        c = swap_bytes(c);  //if you obtain some strange pixmap you can try to comment the line 
+#endif
+        c = (c & 0xFF00FF00) | ((c & 0xFF) << 16) | ((c >> 16) & 0xFF);
+        STORE_U32_VO(dst+i, c);
+      }
+      dst += pitch/sizeof(u32);
+      src += w;
+    }
+    unlock_surface(surf);
+  }
+}
+
+void fl_copy_offscreen(int x,int y,int w,int h,Pixmap pixmap,int srcx,int srcy)
+{
+  DFBRectangle rect = {x:srcx,y:srcy,w:w,h:h};
+  GC in  = ISGC(pixmap);
+  GC out = ISGC(fl_window);
+  if (!out)
+      out = fl_gc;
+  if (out->clip_mask){
+    GC argb_gc  = create_gc(DSCAPS_SYSTEMONLY,\
+      DSDESC_CAPS|DSDESC_WIDTH|DSDESC_HEIGHT|DSDESC_PIXELFORMAT,\
+      DSPF_ARGB, w, h);
+
+    set_porter_duff(argb_gc, DSPD_SRC);
+    set_blitting_flags(argb_gc, DSBLIT_BLEND_ALPHACHANNEL);
+    blit(argb_gc, out->clip_mask, &rect, 0, 0);
+
+    set_porter_duff(argb_gc, DSPD_SRC_IN);
+    set_blitting_flags(argb_gc, DSBLIT_BLEND_ALPHACHANNEL);
+    blit(argb_gc, in, &rect, 0, 0);
+
+    rect.x = rect.y = 0;
+    set_porter_duff(out, DSPD_SRC_OVER);
+    set_blitting_flags(out, DSBLIT_BLEND_ALPHACHANNEL);
+    blit(out, argb_gc, &rect, x, y);
+
+    set_porter_duff(out, DSPD_NONE);
+    release_gc(argb_gc);
+  }else{
+    set_src_blend_function(in, DSBF_SRCALPHA);
+    set_dst_blend_function(out, DSBF_INVSRCALPHA);
+    set_blitting_flags(out, DSBLIT_BLEND_ALPHACHANNEL);
+    blit(out, in, &rect, x, y);
+  }
+  set_blitting_flags(out, DSBLIT_NOFX);
+  update_rect(out, x, y, w, h);
+}
+
+void
+fl_free_cursors()
+{
+  for (int i = 0 ;ms_table[i].cur_type != 0xFFFFFFFF; i++)
+    if (ms_table[i].cursor){
+      Cursor xc = ms_table[i].cursor;
+      ms_table[i].cursor = 0;
+      release_gc(ISGC(xc->shape));
+      release_gc(ISGC(xc->mask));
+      release_gc(ISGC(xc->source));
+      Xfree(xc);
+    }
+}
+
+// NOTE !
+// ABGR is a 4-bytes format for FLTK's drawing functions !
+u8* 
+fl_load_image(const char *infname, int& w, int& h, int& d)
+{
+	if (!fl_dfb)
+		fl_open_display();
+        
+	if (d != 4 && d != 3)
+        return 0;
+    u8 *buf = 0;
+    
+    IDirectFBImageProvider *image_provider =\
+         create_image_provider(infname);
+    
+	if (image_provider){
+		DFBSurfaceDescription desc;
+		get_surface_description(image_provider, &desc);
+		D_DEBUG_AT(IMAGE_CXX,"image desc w %d h %d format %s \n",\
+		        desc.width, desc.height, pixelformat_name(desc.pixelformat));
+		GC image_gc = create_mem_gc(w = desc.width, h = desc.height, DSPF_ARGB);
+        if (image_gc){
+    		render_to(image_provider, image_gc, 0);
+    
+    		int pitch;
+    		buf = (u8*)Xmalloc(w * h * d);
+    		u32 *src = (u32*) lock_surface(image_gc, DSLF_READ, &pitch);
+            u8  *dst = buf;
+    		if (buf){
+                for (int i = 0; i < h; i++){
+                    for (int j = 0; j < w; j++){
+                        u32 color = LOAD_U32_VO(src+j);
+                        if (d == 4){
+                            *dst++ = (color >> 16) & 0xFF;// red - first(!)
+                            *dst++ = (color >>  8) & 0xFF;// green 
+                            *dst++ = (color >>  0) & 0xFF;// blue
+                            *dst++ = (color >> 24) & 0xFF;// alpha - last
+                        }else{
+                            *dst++ = (color >> 16) & 0xFF;// red
+                            *dst++ = (color >>  8) & 0xFF;// green
+                            *dst++ = (color >>  0) & 0xFF;// blue
+                        }
+                    }
+                    src += pitch/4;
+                }
+    			unlock_surface(image_gc);
+           }
+		   release_gc(image_gc);
+        }else{
+            D_DEBUG_AT(IMAGE_CXX,"The surface was not created !\n");
+        }
+        image_provider->Release(image_provider);
+	}
+    return buf;
+}
+
+Fl_Bitmask fl_create_alphamask(int w, int h, int d, int ld, const u8 *array) 
+{
+    if (d != 4){
+        D_DEBUG_AT(IMAGE_CXX, "fl_create_alphamask failed d = %d\n", d);
+        return 0;   
+    }
+    int pitch;
+    
+    DFBSurfaceDescription desc;
+    desc.caps        = DSCAPS_SYSTEMONLY; 
+    desc.flags       = (DFBSurfaceDescriptionFlags)(DSDESC_CAPS|DSDESC_WIDTH|DSDESC_HEIGHT|DSDESC_PIXELFORMAT);
+    desc.pixelformat = DSPF_A8;
+    desc.height      = h;
+    desc.width       = w;
+    
+    GC mask_gc = create_gc(&desc);
+
+    u8* mask = (u8*)lock_surface(mask_gc, DSLF_WRITE, &pitch);
+    
+    int dst_ld = pitch-w;
+    u32   *src = (u32*)array;
+    u8    *dst = mask;
+    u32   color;
+    for (int i = 0; i < h; i++){
+        for (int j = 0; j < w; j++){
+            color  = LOAD_U32_VO(src++);
+            *dst++ = (color >> 24) & 0xFF;//only alpha channel
+        }
+        dst += dst_ld;
+        src = (u32*)((u8*)src + ld);
+    }
+    unlock_surface(mask_gc); 
+    return (Fl_Bitmask)mask_gc;
+}
+
+/********************************************************************************
+ * debug function
+ */
+ 
+void dump_surf_data(GC gc, int x, int y, int w, int h)
+{
+    int pitch;
+    int pix_f = get_pixel_format(gc);
+    int bytes_per_pixel = DFB_BYTES_PER_PIXEL(pix_f);
+           
+    u8 *src = (u8*)lock_surface(gc, DSLF_READ, &pitch);
+    for (int i = y; i<y+h; i++){
+       u8 *pos= src + i * pitch;
+       for (int j=0; j < pitch; j += bytes_per_pixel){
+           if (j > x*bytes_per_pixel && j < (x+w)*bytes_per_pixel){
+                switch(bytes_per_pixel){
+                    case 4:
+                        printf("%08X ", *((u32*)(pos+j)));
+                        break;
+                    case 2:
+                        printf("%04X ", *((u16*)(pos+j)));
+                        break;
+                    case 1:
+                        printf("%02X ", *((u8*)(pos+j)));
+                        break;    
+                }
+           }
+       }    
+       printf("\n");    
+    }
+    unlock_surface(gc); 
+}
+/**********************************************************************/
+/* images */
+
+unsigned char idata_close_but[] =
+"\0\360\f\363\230\361\360\360`\360\360\360\230\361\f\363\0\360\0\360";
+
+unsigned char idata_max_but[] =
+"\376\363\376\363\2\362\2\362\2\362\2\362\2\362\2\362\376\363\0\360";
+
+unsigned char idata_min_but[] =
+"\0\360\0\360\0\360\0\360\0\360\0\360\0\360\374\360\374\360\0\360";
+
+unsigned char idata_norm_but[] =
+"\370\361\370\361\b\361~\361~\361\302\361""B\360""B\360~\360\0\360";
+
+const char *idata_dfb[] = {
+"30 16 -2 1",
+" \0\0\0!\377\0\0",
+"            !!!!!!!!!!!!!!!!  ",
+"           !!!!!!!!!!!!!!!!!! ",
+"          !!!!!!!!!!!!!!!!!!!!",
+"            !!!!!!!!!!!!!!!!!!",
+"       !!!!!              !!!!",
+"     !!!!!!!!!!           !!!!",
+"    !!!!!!!!!!!!!        !!!! ",
+"   !!!!!!!!!!!!!!!!     !!!!! ",
+"  !!!!!!!!!!!!!!       !!!!!  ",
+"   !!!!!!!!!          !!!!!   ",
+"    !!!!            !!!!!!    ",
+"         !!!!!!!!!!!!!!!!     ",
+"     !!!!!!!!!!!!!!!!!!!      ",
+"   !!!!!!!!!!!!!!!!!!!!       ",
+"  !!!!!!!!!!!!!!!!!!!         ",
+"                              "
+};
diff -Nwrup -x.git fltk-1.1.9/src/_listfonts.cxx FLTK_1.x-DirectFB/src/_listfonts.cxx
--- fltk-1.1.9/src/_listfonts.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/_listfonts.cxx	2009-11-28 15:48:05.985156050 -0500
@@ -0,0 +1,499 @@
+//
+// "$Id: _listfonts.cxx,v 1.1 2006-04-06 14:01:27 nikego Exp $"
+//
+// Font-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains font-specific code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+//
+// This file was taken from  Microwindows (Nano-X Window System) project
+// that is a part of the nxlib project.
+// http://www.microwindows.org
+// Edited by Nikita Egorov (nikego@gmail.com) 
+
+char **_nxfontlist = 0;
+int _nxfontcount = 0;
+
+//using namespace std;
+
+FILE *
+_nxLoadFontDir(char *str)
+{
+	char path[256];
+
+	sprintf(path, "%s/fonts.dir", str);
+	return fopen(path, "r");
+}
+
+
+void
+_nxSetDefaultFontDir(void)
+{
+	int i;
+
+	if (_nxfontlist) {
+		for (i = 0; i < _nxfontcount; i++)
+			Xfree(_nxfontlist[i]);
+		Xfree(_nxfontlist);
+	}
+
+	_nxfontlist = (char **) Xcalloc(2, sizeof(char *));
+	_nxfontlist[0] = strdup(X11_FONT_DIR1);
+	_nxfontlist[1] = strdup(X11_FONT_DIR2);
+	_nxfontcount = 2;
+}
+
+struct _list {
+	char **list;
+	int alloc;
+	int used;
+	struct _list *next;
+};
+
+static struct _list *g_fontlist = 0;
+
+static struct _list *
+_createFontList(void)
+{
+	struct _list *ptr;
+
+	if (!g_fontlist)
+		ptr = g_fontlist =
+			(struct _list *)Xcalloc(sizeof(struct _list), 1);
+	else {
+		struct _list *t;
+		for (t = g_fontlist; t->next; t = t->next)
+			continue;
+		ptr = t->next =
+			(struct _list *)Xcalloc(sizeof(struct _list), 1);
+	}
+	return ptr;
+}
+
+static int
+_addFontToList(struct _list *list, char *font)
+{
+	if (list->alloc == 0) {
+		list->list = (char**)Xmalloc(5 * sizeof(char *));
+		list->alloc = 5;
+	} else if (list->used == list->alloc) {
+		list->list = (char**)Xrealloc(list->list,
+				(list->alloc + 5) * sizeof(char *));
+		list->alloc += 5;
+	}
+
+	list->list[list->used++] = strdup(font);
+	return list->used;
+}
+
+static char **
+_getFontList(struct _list *list, int *size)
+{
+	if (!list->list) {
+		*size = 0;
+		return 0;
+	}
+
+	if (list->alloc != list->used)
+		list->list =
+			(char**)Xrealloc(list->list, (list->used) * sizeof(char *));
+
+	*size = list->used;
+	return list->list;
+}
+
+static void
+_freeFontList(char **fontlist)
+{
+	struct _list *ptr = g_fontlist;
+	struct _list *prev = 0;
+
+	if (!fontlist)
+		return;
+
+	while (ptr) {
+		if (ptr->list == fontlist) {
+			int i;
+			for (i = 0; i < ptr->used; i++)
+				Xfree(ptr->list[i]);
+
+			Xfree(ptr->list);
+
+			if (ptr == g_fontlist)
+				g_fontlist = ptr->next;
+			else
+				prev->next = ptr->next;
+
+			return;
+		}
+		prev = ptr;
+		ptr = ptr->next;
+	}
+}
+#if 1
+static int
+_dashcount(char *name)
+{
+	int	ndashes = 0;
+
+	while (*name)
+		if (*name++ == '-')
+			++ndashes;
+	return ndashes;
+}
+
+static int
+patternmatch(char *pat, int patdashes, char *string, int stringdashes)
+{
+	int c, t;
+
+	if (stringdashes < patdashes)
+		return 0;
+
+	for (;;) {
+	    switch (c = *pat++) {
+	    case '*':
+		if (!(c = *pat++))
+			return 1;
+		if (c == '-') {
+			patdashes--;
+			for (;;) {
+				while ((t = *string++) != '-')
+					if (!t)
+						return 0;
+				stringdashes--;
+				if (patternmatch(pat, patdashes, string, stringdashes))
+					return 1;
+				if (stringdashes == patdashes)
+					return 0;
+			}
+		} else {
+			for (;;) {
+				while ((t = *string++) != c) {
+					if (!t)
+						return 0;
+					if (t == '-') {
+						if (stringdashes-- < patdashes)
+							return 0;
+					}
+				}
+				if (patternmatch(pat, patdashes, string, stringdashes))
+					return 1;
+			}
+		}
+	    case '?':
+		if (*string++ == '-')
+			stringdashes--;
+		break;
+	    case '\0':
+		return (*string == '\0');
+	    case '-':
+		if (*string++ == '-') {
+			patdashes--;
+			stringdashes--;
+			break;
+		}
+		return 0;
+	    default:
+		if (c == *string++)
+			break;
+		return 0;
+	    }
+	}
+}
+
+static int
+match(char *pat, char *string)
+{
+	return patternmatch(pat, _dashcount(pat), string, _dashcount(string));
+}
+
+#else
+static int
+match(char *pattern, char *font)
+{
+	char *src = pattern;
+	char *dst = font;
+	int m = 0;
+
+	if (!strcmp(pattern, "-*"))
+		pattern = "*"; //"-*-*-*-*-*-*-*-*-*-*-*-*-*-*";
+
+	if (!strcmp(pattern, "*"))
+		return 1;
+
+	while (1) {
+		char *s, *e;
+
+		src++;
+		dst++;
+
+		/* Skip any wildcardish stuff */
+		if (*src == '*') {
+			src++;
+			if (!*src)
+				break;
+
+			for (; *dst && *dst != '-'; dst++)
+				continue;
+			if (!*dst)
+				break;
+
+			continue;
+		}
+
+		/* Find the end of the compare */
+		s = src;
+		e = src;
+		for (; *e && *e != '-'; e++)
+			continue;
+		_TRACE("strnicmp '%s' '%s'\n", s ,dst);
+		if (strnicmp(s, dst, (int) (e - s)) == 0) {
+			m = 1;
+		} else {
+			m = 0;
+			break;
+		}
+
+		src += (int) (e - s);
+		dst += (int) (e - s);
+	}
+	return m;
+}
+#endif
+
+static char **
+_findFontPattern(char *_pattern, int maxnames, int *count)
+{
+	char pattern[128];
+	strcpy(pattern, _pattern);
+	strlwr(pattern);
+	//_TRACE("pattern = '%s'\n", pattern);
+	
+	struct _list *flist = _createFontList();
+	int fcount = 0, i = 0, f;
+	char buffer[128];
+
+	if (!_nxfontlist)
+		_nxSetDefaultFontDir();
+
+	for (f = 0; f < _nxfontcount; f++) {
+		//_TRACE("trying open font list %s\n", _nxfontlist[f]);
+		FILE *fontdir = _nxLoadFontDir(_nxfontlist[f]);
+		if (!fontdir)
+			continue;
+
+		fgets(buffer, 128, fontdir);
+		fcount = atoi(buffer);
+
+		if (!fcount) {
+			fclose(fontdir);
+			continue;
+		}
+
+		for (i = 0; i < fcount; i++) {
+			char *font;
+
+			memset(buffer, 0, 128);
+			fgets(buffer, 128, fontdir);
+
+			/* Remove the end 'o line */
+			buffer[strlen(buffer) - 1] = '\0';
+
+			/* Find the field seperator */
+			font = strchr(buffer, ' ');
+			*font++ = '\0';
+			strlwr(font);
+
+			if (match(pattern, font))
+				if (_addFontToList(flist, font) == maxnames)
+					break;
+		}
+		fclose(fontdir);
+	}
+	return _getFontList(flist, count);
+}
+
+/*
+ * Compare two strings just like strcmp, but preserve decimal integer
+ * sorting order, i.e. "2" < "10" or "iso8859-2" < "iso8859-10" <
+ * "iso10646-1". Strings are sorted as if sequences of digits were
+ * prefixed by a length indicator (i.e., does not ignore leading zeroes).
+ *
+ * Markus Kuhn <Markus.Kuhn@cl.cam.ac.uk>
+ */
+#define isdigit(c) ('0' <= (c) && (c) <= '9')
+static int
+strcmpn(unsigned char *s1, unsigned char *s2)
+{
+	int digits, predigits = 0;
+	unsigned char *ss1, *ss2;
+
+	while (1) {
+		if (*s1 == 0 && *s2 == 0)
+			return 0;
+		digits = isdigit(*s1) && isdigit(*s2);
+		if (digits && !predigits) {
+			ss1 = s1;
+			ss2 = s2;
+			while (isdigit(*ss1) && isdigit(*ss2))
+				ss1++, ss2++;
+			if (!isdigit(*ss1) && isdigit(*ss2))
+				return -1;
+			if (isdigit(*ss1) && !isdigit(*ss2))
+				return 1;
+		}
+		if (*s1 < *s2)
+			return -1;
+		if (*s1 > *s2)
+			return 1;
+		predigits = digits;
+		s1++, s2++;
+	}
+}
+
+static int
+comparefunc(const void* a, const void* b)
+{
+	unsigned char *aa = *(unsigned char **)a;
+	unsigned char *bb = *(unsigned char **)b;
+
+	return strcmpn(aa, bb);
+}
+
+/***************************************************************************/
+#if 1
+char **
+_nxGetFontDir(int *count)
+{
+	int i;
+
+	int size;
+	char **ret;
+
+	if (!_nxfontcount)
+		_nxSetDefaultFontDir();
+
+	size = _nxfontcount + 1;
+	ret = (char **) Xcalloc(size, sizeof(char *));
+
+	for (i = 0; i < _nxfontcount; i++)
+		ret[i] = strdup(_nxfontlist[i]);
+	ret[_nxfontcount] = 0;
+
+	*count = _nxfontcount;
+	return (ret);
+}
+
+void
+_nxSetFontDir(char **directories, int ndirs)
+{
+	int i;
+
+	if (_nxfontlist) {
+		for (i = 0; i < _nxfontcount; i++)
+			Xfree(_nxfontlist[i]);
+		Xfree(_nxfontlist);
+	}
+
+	_nxfontlist = (char **) Xcalloc(ndirs, sizeof(char *));
+	for (i = 0; i < ndirs; i++)
+		_nxfontlist[i] = strdup(directories[i]);
+
+	_nxfontcount = ndirs;
+}
+
+void
+_nxFreeFontDir(char **list)
+{
+	int i;
+
+	if (list) {
+		for (i = 0; list[i]; i++)
+			Xfree(list[i]);
+		Xfree(list);
+	}
+}
+// end of namespace list_fonts
+
+char **
+XListFonts(Display * display, const char *pattern, int maxnames,
+	int *actual_count_return)
+{
+	int count;
+	char **ret;
+
+	ret = _findFontPattern((char *)pattern, maxnames, &count);
+	*actual_count_return = count;
+
+	/* sort the return, helps for lack of locale info at end of XLFD*/
+	qsort((char *)ret, count, sizeof(char *), comparefunc);
+
+	return ret;
+}
+
+
+int
+XFreeFontNames(char **list)
+{
+	_freeFontList(list);
+	return 1;
+}
+int
+XSetFontPath(Display * display, char **directories, int ndirs)
+{
+	_nxSetFontDir(directories, ndirs);
+	return 1;
+}
+
+char **
+XGetFontPath(Display * display, int *npaths_return)
+{
+	return _nxGetFontDir(npaths_return);
+}
+
+int
+XFreeFontPath(char **list)
+{
+	_nxFreeFontDir(list);
+	return 1;
+}
+#else
+Bool
+XGetFontProperty(XFontStruct * font, Atom atom, unsigned long *value_return)
+{
+//_TRACE("XGetFontProperty called\n");
+	switch (atom) {
+	case XA_FONT:			/* 18*/
+	case XA_UNDERLINE_POSITION:	/* 51*/
+	case XA_UNDERLINE_THICKNESS:	/* 52*/
+		break;
+	default:
+	//	_TRACE("XGetFontProperty: Unknown FontProperty Atom %d\n",
+	//		(int)atom);
+	}
+	return 0;
+}
+#endif
diff -Nwrup -x.git fltk-1.1.9/src/_loadfont.cxx FLTK_1.x-DirectFB/src/_loadfont.cxx
--- fltk-1.1.9/src/_loadfont.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/_loadfont.cxx	2009-11-28 15:48:05.985156050 -0500
@@ -0,0 +1,207 @@
+//
+// "$Id: _loadfont.cxx,v 1.2 2006-10-31 09:31:14 nikego Exp $"
+//
+// Font loading code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains font specific code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+//
+// This file was taken from  Microwindows (Nano-X Window System) project
+// that is a part of the nxlib project. http://www.microwindows.org
+// Edited by Nikita Egorov (nikego@gmail.com)
+
+static int prefix(const char *prestr, char *allstr)
+{
+  while (*prestr)
+    if (*prestr++ != *allstr++)
+      return 0;
+  if (*allstr != '.')
+    return 0;
+  return 1;
+}
+
+char * _nxFindX11Font(const char *_xfontname)
+{
+  char xfontname[128]= { 0 };
+  strcpy(xfontname, _xfontname);
+  strlwr(xfontname);
+  int fcount, i, f;
+  char *ret;
+  char buffer[128];
+  /******************************************************************/
+  /* Added by Nikita */
+  /* Prepare for truetype fonts - deleting font size */
+  char ttfname[128];
+  strcpy(ttfname, xfontname);
+  char* pos = strstr(ttfname, "--");
+  if (pos) {
+    pos += 2;
+    *pos = '0';
+    pos++;
+    if (*pos != '-') {
+      if (pos[1] == '-')
+        strcpy(pos, pos + 1);
+    }
+  }
+  //printf("ttfname '%s' '%s'\n", ttfname, xfontname);
+  /******************************************************************/
+  if (!_nxfontcount)
+    _nxSetDefaultFontDir();
+
+  /* Go through all of the font dirs */
+  for (f = 0; f < _nxfontcount; f++) {
+    FILE *fontdir = _nxLoadFontDir(_nxfontlist[f]);
+    if (!fontdir)
+      continue;
+
+    fgets(buffer, 128, fontdir);
+    fcount = atoi(buffer);
+
+    if (!fcount) {
+      fclose(fontdir);
+      continue;
+    }
+
+    for (i = 0; i < fcount; i++) {
+      char *file = buffer, *font = 0;
+
+      fgets(buffer, 128, fontdir);
+
+      /* Remove the end 'o line */
+      buffer[strlen(buffer) - 1] = '\0';
+
+      /******************************************************************/
+      /* Added by Nikita */
+      strlwr(buffer);
+      const char* xfontname_ = xfontname;
+      if (strstr(buffer, ".ttf"))//checking for truetype font
+      {
+        xfontname_ = ttfname;
+      }
+      /******************************************************************/
+
+      /* Find the field seperator */
+
+      font = strchr(buffer, ' ');
+      *font++ = '\0';
+
+      if (strcmp(xfontname_, font) == 0) {
+        ret = (char *) Xmalloc(strlen(_nxfontlist[f]) + strlen(file) + 2);
+        sprintf(ret, "%s/%s", _nxfontlist[f], file);
+
+        fclose(fontdir);
+        return ret;
+      }
+    }
+
+    /* not found, try <prefix.pcf> */
+    fseek(fontdir, 0L, SEEK_SET);
+    fgets(buffer, 128, fontdir);
+    for (i = 0; i < fcount; i++) {
+      char *file = buffer, *font = 0;
+
+      fgets(buffer, 128, fontdir);
+
+      /* Remove the end 'o line */
+      buffer[strlen(buffer) - 1] = '\0';
+      strlwr(buffer);
+
+      /* Find the field seperator */
+
+      font = strchr(buffer, ' ');
+      *font++ = '\0';
+
+      if (prefix(xfontname, file)) {
+        ret = (char *) Xmalloc(strlen(_nxfontlist[f]) + strlen(file) + 2);
+        sprintf(ret, "%s/%s", _nxfontlist[f], file);
+
+        fclose(fontdir);
+        return ret;
+      }
+    }
+
+    if (fontdir)
+      fclose(fontdir);
+  }
+  return 0;
+}
+
+static int any(int c, const char *str)
+{
+  while (*str)
+    if (*str++ == c)
+      return 1;
+  return 0;
+}
+
+XFont XLoadFont(Display* display, const char *name)
+{
+  XFont fbfont = 0;
+  char *fontname=0;
+
+  /* first check for wildcards*/
+  if (any('*', name) || any('?', name)) {
+    char **fontlist;
+    int count;
+
+    /* pick first sorted return value for now...*/
+    fontlist = XListFonts(display, name, 100000, &count);
+    if (fontlist)
+      fontname = fontlist[0];
+  } else
+    fontname = (char *)name;
+
+  /* first try to find from X11/fonts.dir file*/
+  fontname = _nxFindX11Font(fontname);
+
+  /* if not found, try 6x13 for "fixed"*/
+  if (!fontname && !strcmp(name, "fixed"))
+    fontname = _nxFindX11Font("6x13");
+
+  /* found font, load into server*/
+  if (fontname) {
+    char *sizepos = strstr(name, "--");
+    DFBFontDescription font_dsc;
+    font_dsc.flags = (DFBFontDescriptionFlags)(DFDESC_HEIGHT/* |DFDESC_INDEX*/);
+    //if (have_lut()){
+    //  font_dsc.attributes = (DFBFontAttributes)(DFFA_MONOCHROME);
+    //  font_dsc.flags = (DFBFontDescriptionFlags)(font_dsc.flags | DFDESC_ATTRIBUTES) ;
+    //}
+    int size = 10;
+    if (sizepos) {
+      sizepos += 2;
+      size = atoi(sizepos);
+    }
+    /*font_dsc.index = 3; //sometimes it worked...*/
+    font_dsc.height = size;
+    create_font(fontname, &font_dsc, &fbfont);
+  } else {
+    D_INFO("The font file %d not found\n", fontname);
+  }
+  if (fontname)
+    Xfree(fontname);
+
+  return fbfont;
+}
diff -Nwrup -x.git fltk-1.1.9/src/makedepend FLTK_1.x-DirectFB/src/makedepend
--- fltk-1.1.9/src/makedepend	2007-02-10 09:31:12.000000000 -0500
+++ FLTK_1.x-DirectFB/src/makedepend	2009-11-28 15:48:06.002154046 -0500
@@ -1,601 +1,587 @@
 # DO NOT DELETE THIS LINE -- make depend depends on it.
-Fl.o: Fl.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/Fl_Tooltip.H ../FL/Fl_Widget.H flstring.h \
-  ../FL/Fl_Export.H ../config.h ../FL/fl_draw.H
-Fl_Adjuster.o: Fl_Adjuster.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Adjuster.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Bitmap.H ../FL/Fl_Image.H ../FL/fl_draw.H \
-  fastarrow.h mediumarrow.h slowarrow.h
-Fl_Bitmap.o: Fl_Bitmap.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/Fl_Bitmap.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Browser.o: Fl_Browser.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Browser.H ../FL/Fl_Browser_.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/fl_draw.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Browser_.o: Fl_Browser_.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/Fl_Browser_.H \
-  ../FL/Fl_Group.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H \
-  ../FL/Fl_Valuator.H ../FL/fl_draw.H
-Fl_Browser_load.o: Fl_Browser_load.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Browser.H ../FL/Fl_Browser_.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
-Fl_Box.o: Fl_Box.cxx ../FL/Fl_Widget.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Box.H
-Fl_Button.o: Fl_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Button.H ../FL/Fl_Widget.H ../FL/Fl_Group.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H
-Fl_Chart.o: Fl_Chart.cxx ../FL/math.h ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Chart.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Check_Browser.o: Fl_Check_Browser.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/fl_draw.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Check_Browser.H ../FL/Fl.H ../FL/Fl_Browser_.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
-Fl_Check_Button.o: Fl_Check_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Check_Button.H ../FL/Fl_Light_Button.H \
-  ../FL/Fl_Button.H ../FL/Fl_Widget.H
-Fl_Choice.o: Fl_Choice.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/fl_draw.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Clock.o: Fl_Clock.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Clock.H ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Color_Chooser.o: Fl_Color_Chooser.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Color_Chooser.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Box.H ../FL/Fl_Return_Button.H \
-  ../FL/Fl_Button.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/Fl_Value_Input.H \
-  ../FL/Fl_Valuator.H ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/fl_draw.H \
-  ../FL/math.h ../FL/Fl_Window.H ../FL/Fl_Group.H
-Fl_Counter.o: Fl_Counter.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Counter.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Dial.o: Fl_Dial.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Dial.H ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  ../FL/math.h
-Fl_Double_Window.o: Fl_Double_Window.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Double_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/x.H \
-  ../FL/fl_draw.H
-Fl_File_Browser.o: Fl_File_Browser.cxx ../FL/Fl_File_Browser.H \
-  ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/filename.H ../FL/fl_draw.H \
-  ../FL/filename.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_File_Chooser.o: Fl_File_Chooser.cxx ../FL/Fl_File_Chooser.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Double_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Group.H \
-  ../FL/Fl_Choice.H ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H \
-  ../FL/Fl_Image.H ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H \
-  ../FL/Fl_Preferences.H ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H \
-  ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_File_Icon.H ../FL/Fl.H \
-  ../FL/filename.H ../FL/Fl_Box.H ../FL/Fl_Check_Button.H \
-  ../FL/Fl_Light_Button.H ../FL/Fl_Button.H ../FL/Fl_File_Input.H \
-  ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H \
-  ../FL/fl_ask.H ../FL/fl_draw.H ../FL/Fl_Bitmap.H
-Fl_File_Chooser2.o: Fl_File_Chooser2.cxx ../FL/Fl_File_Chooser.H \
-  ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Double_Window.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Group.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/Fl_Menu_Button.H \
-  ../FL/Fl_Button.H ../FL/Fl_Preferences.H ../FL/Fl_Tile.H \
-  ../FL/Fl_File_Browser.H ../FL/Fl_Browser.H ../FL/Fl_Browser_.H \
-  ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/filename.H ../FL/Fl_Box.H \
-  ../FL/Fl_Check_Button.H ../FL/Fl_Light_Button.H ../FL/Fl_Button.H \
-  ../FL/Fl_File_Input.H ../FL/Fl_Input.H ../FL/Fl_Input_.H \
-  ../FL/Fl_Return_Button.H ../FL/fl_ask.H ../FL/filename.H ../FL/x.H \
-  ../FL/Fl_Shared_Image.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_File_Icon.o: Fl_File_Icon.cxx flstring.h ../FL/Fl_Export.H ../config.h \
-  ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/filename.H
-Fl_File_Input.o: Fl_File_Input.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_File_Input.H ../FL/Fl_Input.H \
-  ../FL/Fl_Input_.H ../FL/Fl_Widget.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Group.o: Fl_Group.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/fl_draw.H
-Fl_Help_View.o: Fl_Help_View.cxx ../FL/Fl_Help_View.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H \
-  ../FL/Fl_Valuator.H ../FL/fl_draw.H ../FL/Fl_Shared_Image.H \
-  ../FL/Fl_Image.H ../FL/Fl_Window.H ../FL/Fl_Pixmap.H ../FL/x.H \
-  ../FL/Fl_Window.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Image.o: Fl_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/Fl_Image.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Input.o: Fl_Input.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/fl_draw.H ../FL/fl_ask.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Input_.o: Fl_Input_.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Input_.H ../FL/Fl_Widget.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/fl_draw.H ../FL/fl_ask.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Light_Button.o: Fl_Light_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Light_Button.H ../FL/Fl_Button.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-Fl_Menu.o: Fl_Menu.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Menu_Window.H ../FL/Fl_Single_Window.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/fl_draw.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Menu_.o: Fl_Menu_.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Menu_.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-Fl_Menu_Bar.o: Fl_Menu_Bar.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Menu_Bar.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/fl_draw.H
-Fl_Sys_Menu_Bar.o: Fl_Sys_Menu_Bar.cxx
-Fl_Menu_Button.o: Fl_Menu_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Menu_Button.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/fl_draw.H
-Fl_Menu_Window.o: Fl_Menu_Window.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  ../FL/Fl_Menu_Window.H ../FL/Fl_Single_Window.H
-Fl_Menu_add.o: Fl_Menu_add.cxx ../FL/Fl_Menu_.H ../FL/Fl_Widget.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Menu_Item.H \
-  ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Menu_global.o: Fl_Menu_global.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Menu_.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H
-Fl_Multi_Label.o: Fl_Multi_Label.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Image.H ../FL/Fl_Multi_Label.H
-Fl_Overlay_Window.o: Fl_Overlay_Window.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Overlay_Window.H \
-  ../FL/Fl_Double_Window.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/x.H
-Fl_Pack.o: Fl_Pack.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Pack.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Pixmap.o: Fl_Pixmap.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../FL/Fl_Pixmap.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Positioner.o: Fl_Positioner.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Positioner.H ../FL/Fl_Widget.H \
-  ../FL/fl_draw.H
-Fl_Preferences.o: Fl_Preferences.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Preferences.H ../FL/filename.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Progress.o: Fl_Progress.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Progress.H ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Repeat_Button.o: Fl_Repeat_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Repeat_Button.H ../FL/Fl.H ../FL/Fl_Button.H \
-  ../FL/Fl_Widget.H
-Fl_Return_Button.o: Fl_Return_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Return_Button.H ../FL/Fl_Button.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Roller.o: Fl_Roller.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Roller.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Round_Button.o: Fl_Round_Button.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Round_Button.H ../FL/Fl_Light_Button.H \
-  ../FL/Fl_Button.H ../FL/Fl_Widget.H
-Fl_Scroll.o: Fl_Scroll.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Tiled_Image.H ../FL/Fl_Image.H \
-  ../FL/Fl_Scroll.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H \
-  ../FL/fl_draw.H
-Fl_Scrollbar.o: Fl_Scrollbar.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H \
-  ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-Fl_Shared_Image.o: Fl_Shared_Image.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Shared_Image.H ../FL/Fl_Image.H ../FL/Fl_XBM_Image.H \
-  ../FL/Fl_Bitmap.H ../FL/Fl_XPM_Image.H ../FL/Fl_Pixmap.H
-Fl_Single_Window.o: Fl_Single_Window.cxx ../FL/Fl_Single_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H
-Fl_Slider.o: Fl_Slider.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-Fl_Tabs.o: Fl_Tabs.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Tabs.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  ../FL/Fl_Tooltip.H ../FL/Fl_Widget.H
-Fl_Text_Buffer.o: Fl_Text_Buffer.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Text_Buffer.H
-Fl_Text_Display.o: Fl_Text_Display.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Text_Buffer.H ../FL/Fl_Text_Display.H ../FL/fl_draw.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Text_Buffer.H \
-  ../FL/Fl_Window.H
-Fl_Text_Editor.o: Fl_Text_Editor.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Text_Editor.H ../FL/Fl_Text_Display.H ../FL/fl_draw.H \
-  ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Text_Buffer.H ../FL/fl_ask.H
-Fl_Tile.o: Fl_Tile.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Tile.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Window.H
-Fl_Tiled_Image.o: Fl_Tiled_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Tiled_Image.H ../FL/Fl_Image.H \
-  ../FL/fl_draw.H
-Fl_Tooltip.o: Fl_Tooltip.cxx ../FL/Fl_Tooltip.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Widget.H \
-  ../FL/fl_draw.H ../FL/Fl_Menu_Window.H ../FL/Fl_Single_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H
-Fl_Valuator.o: Fl_Valuator.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/math.h \
-  flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Value_Input.o: Fl_Value_Input.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Value_Input.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Group.H \
-  ../FL/math.h
-Fl_Value_Output.o: Fl_Value_Output.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Value_Output.H ../FL/Fl_Valuator.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Value_Slider.o: Fl_Value_Slider.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Value_Slider.H ../FL/Fl_Slider.H \
-  ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Widget.o: Fl_Widget.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/Fl_Group.H ../FL/Fl_Tooltip.H \
-  ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Window.o: Fl_Window.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Window_fullscreen.o: Fl_Window_fullscreen.cxx ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H
-Fl_Window_hotspot.o: Fl_Window_hotspot.cxx ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/x.H ../FL/Fl_Window.H
-Fl_Window_iconize.o: Fl_Window_iconize.cxx ../FL/x.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
-Fl_Wizard.o: Fl_Wizard.cxx ../FL/Fl_Wizard.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/fl_draw.H
-Fl_XBM_Image.o: Fl_XBM_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_XBM_Image.H ../FL/Fl_Bitmap.H \
-  ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_XPM_Image.o: Fl_XPM_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_XPM_Image.H ../FL/Fl_Pixmap.H \
-  ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_abort.o: Fl_abort.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_add_idle.o: Fl_add_idle.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H
-Fl_arg.o: Fl_arg.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Window.H ../FL/Fl_Tooltip.H ../FL/Fl_Widget.H ../FL/filename.H \
-  ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_compose.o: Fl_compose.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H
-Fl_display.o: Fl_display.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_get_key.o: Fl_get_key.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H
-Fl_get_system_colors.o: Fl_get_system_colors.cxx ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/math.h \
-  flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl_Pixmap.H \
-  ../FL/Fl_Image.H ../FL/Fl_Tiled_Image.H tile.xpm
-Fl_grab.o: Fl_grab.cxx ../config.h ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H
-Fl_lock.o: Fl_lock.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../config.h
-Fl_own_colormap.o: Fl_own_colormap.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H
-Fl_visual.o: Fl_visual.cxx ../config.h ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H
-Fl_x.o: Fl_x.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/Fl_Window.H ../FL/Fl_Tooltip.H ../FL/Fl_Widget.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-filename_absolute.o: filename_absolute.cxx ../FL/filename.H \
-  ../FL/Fl_Export.H flstring.h ../FL/Fl_Export.H ../config.h
-filename_expand.o: filename_expand.cxx ../FL/filename.H ../FL/Fl_Export.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-filename_ext.o: filename_ext.cxx ../FL/filename.H ../FL/Fl_Export.H
-filename_isdir.o: filename_isdir.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/filename.H ../FL/Fl_Export.H
-filename_list.o: filename_list.cxx ../FL/filename.H ../FL/Fl_Export.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-filename_match.o: filename_match.cxx ../FL/filename.H ../FL/Fl_Export.H
-filename_setext.o: filename_setext.cxx ../FL/filename.H ../FL/Fl_Export.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-fl_arc.o: fl_arc.cxx ../FL/fl_draw.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/math.h
-fl_arci.o: fl_arci.cxx ../FL/fl_draw.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H
-fl_ask.o: fl_ask.cxx flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_ask.H ../FL/Fl_Box.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Button.H ../FL/Fl_Return_Button.H \
-  ../FL/Fl_Button.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Input.H \
-  ../FL/Fl_Input_.H ../FL/Fl_Secret_Input.H ../FL/Fl_Input.H ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/fl_draw.H
-fl_boxtype.o: fl_boxtype.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/fl_draw.H ../config.h
-fl_color.o: fl_color.cxx Fl_XColor.H ../config.h ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl.H ../FL/Enumerations.H ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  fl_cmap.h
-fl_cursor.o: fl_cursor.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/x.H ../FL/Fl_Window.H ../FL/fl_draw.H
-fl_curve.o: fl_curve.cxx ../FL/fl_draw.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H
-fl_diamond_box.o: fl_diamond_box.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H
-fl_dnd.o: fl_dnd.cxx fl_dnd_x.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/x.H ../FL/Fl_Window.H flstring.h ../FL/Fl_Export.H ../config.h
-fl_draw.o: fl_draw.cxx ../FL/fl_draw.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-fl_draw_image.o: fl_draw_image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H Fl_XColor.H ../config.h \
-  ../FL/Enumerations.H flstring.h ../FL/Fl_Export.H
-fl_draw_pixmap.o: fl_draw_pixmap.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-fl_encoding_latin1.o: fl_encoding_latin1.cxx ../FL/fl_draw.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Enumerations.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-fl_encoding_mac_roman.o: fl_encoding_mac_roman.cxx ../FL/fl_draw.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Enumerations.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-fl_engraved_label.o: fl_engraved_label.cxx ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Widget.H \
-  ../FL/fl_draw.H
-fl_file_dir.o: fl_file_dir.cxx flstring.h ../FL/Fl_Export.H ../config.h \
-  ../FL/filename.H ../FL/Fl_Export.H ../FL/Fl_File_Chooser.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Double_Window.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Group.H ../FL/Fl_Choice.H \
-  ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H \
-  ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H ../FL/Fl_Preferences.H \
-  ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H ../FL/Fl_Browser.H \
-  ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H \
-  ../FL/Fl_Valuator.H ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/filename.H \
-  ../FL/Fl_Box.H ../FL/Fl_Check_Button.H ../FL/Fl_Light_Button.H \
-  ../FL/Fl_Button.H ../FL/Fl_File_Input.H ../FL/Fl_Input.H \
-  ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H ../FL/fl_ask.H
-fl_font.o: fl_font.cxx flstring.h ../FL/Fl_Export.H ../config.h \
-  ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_draw.H \
-  ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  Fl_Font.H fl_font_xft.cxx
-fl_gtk.o: fl_gtk.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/fl_draw.H
-fl_labeltype.o: fl_labeltype.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/Fl_Group.H ../FL/fl_draw.H \
-  ../FL/Fl_Image.H ../FL/Fl_Input_.H
-fl_line_style.o: fl_line_style.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-fl_open_uri.o: fl_open_uri.cxx ../FL/filename.H ../FL/Fl_Export.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-fl_oval_box.o: fl_oval_box.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H
-fl_overlay.o: fl_overlay.cxx ../FL/x.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/fl_draw.H
-fl_overlay_visual.o: fl_overlay_visual.cxx ../config.h
-fl_plastic.o: fl_plastic.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H \
-  ../config.h
-fl_read_image.o: fl_read_image.cxx ../FL/x.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
-fl_rect.o: fl_rect.cxx ../config.h ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H
-fl_round_box.o: fl_round_box.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H
-fl_rounded_box.o: fl_rounded_box.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H
-fl_set_font.o: fl_set_font.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H \
-  ../config.h Fl_Font.H
-fl_set_fonts.o: fl_set_fonts.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H Fl_Font.H ../config.h flstring.h ../FL/Fl_Export.H \
-  fl_set_fonts_xft.cxx
-fl_scroll_area.o: fl_scroll_area.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H
-fl_shadow_box.o: fl_shadow_box.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H
-fl_shortcut.o: fl_shortcut.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/Fl_Button.H ../FL/fl_draw.H \
-  flstring.h ../FL/Fl_Export.H ../config.h ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H
-fl_show_colormap.o: fl_show_colormap.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Single_Window.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  ../FL/fl_show_colormap.H ../config.h
-fl_symbols.o: fl_symbols.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/math.h flstring.h \
-  ../FL/Fl_Export.H ../config.h
-fl_vertex.o: fl_vertex.cxx ../config.h ../FL/fl_draw.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl.H ../FL/math.h
-screen_xywh.o: screen_xywh.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../config.h
-forms_compatability.o: forms_compatability.cxx ../FL/forms.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Window.H ../FL/fl_draw.H \
-  ../FL/Fl_FormsBitmap.H ../FL/Fl_Bitmap.H ../FL/Fl_Image.H \
-  ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H \
-  ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H \
-  ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H ../FL/Fl_Check_Button.H \
-  ../FL/Fl_Chart.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H ../FL/Fl_Counter.H \
-  ../FL/Fl_Dial.H ../FL/Fl_Free.H ../FL/fl_ask.H ../FL/fl_show_colormap.H \
-  ../FL/filename.H ../FL/Fl_File_Chooser.H ../FL/Fl.H \
-  ../FL/Fl_Double_Window.H ../FL/Fl_Group.H ../FL/Fl_Choice.H \
-  ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H ../FL/Fl_Preferences.H \
-  ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H \
-  ../FL/Fl_Box.H ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H \
-  ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H \
-  ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H \
-  ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H ../FL/Fl_Timer.H \
-  ../FL/Fl_Repeat_Button.H
-forms_bitmap.o: forms_bitmap.cxx ../FL/forms.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Window.H ../FL/fl_draw.H \
-  ../FL/Fl_FormsBitmap.H ../FL/Fl_Bitmap.H ../FL/Fl_Image.H \
-  ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H \
-  ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H \
-  ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H ../FL/Fl_Check_Button.H \
-  ../FL/Fl_Chart.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H ../FL/Fl_Counter.H \
-  ../FL/Fl_Dial.H ../FL/Fl_Free.H ../FL/fl_ask.H ../FL/fl_show_colormap.H \
-  ../FL/filename.H ../FL/Fl_File_Chooser.H ../FL/Fl.H \
-  ../FL/Fl_Double_Window.H ../FL/Fl_Group.H ../FL/Fl_Choice.H \
-  ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H ../FL/Fl_Preferences.H \
-  ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H \
-  ../FL/Fl_Box.H ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H \
-  ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H \
-  ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H \
-  ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H ../FL/Fl_Timer.H
-forms_free.o: forms_free.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Free.H ../FL/Fl_Widget.H
-forms_fselect.o: forms_fselect.cxx ../FL/forms.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Window.H ../FL/fl_draw.H \
-  ../FL/Fl_FormsBitmap.H ../FL/Fl_Bitmap.H ../FL/Fl_Image.H \
-  ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H \
-  ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H \
-  ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H ../FL/Fl_Check_Button.H \
-  ../FL/Fl_Chart.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H ../FL/Fl_Counter.H \
-  ../FL/Fl_Dial.H ../FL/Fl_Free.H ../FL/fl_ask.H ../FL/fl_show_colormap.H \
-  ../FL/filename.H ../FL/Fl_File_Chooser.H ../FL/Fl.H \
-  ../FL/Fl_Double_Window.H ../FL/Fl_Group.H ../FL/Fl_Choice.H \
-  ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H ../FL/Fl_Preferences.H \
-  ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H \
-  ../FL/Fl_Box.H ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H \
-  ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H \
-  ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H \
-  ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H ../FL/Fl_Timer.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-forms_pixmap.o: forms_pixmap.cxx ../FL/forms.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H ../FL/Fl_Window.H ../FL/fl_draw.H \
-  ../FL/Fl_FormsBitmap.H ../FL/Fl_Bitmap.H ../FL/Fl_Image.H \
-  ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H \
-  ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H \
-  ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H \
-  ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H ../FL/Fl_Check_Button.H \
-  ../FL/Fl_Chart.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H \
-  ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H ../FL/Fl_Counter.H \
-  ../FL/Fl_Dial.H ../FL/Fl_Free.H ../FL/fl_ask.H ../FL/fl_show_colormap.H \
-  ../FL/filename.H ../FL/Fl_File_Chooser.H ../FL/Fl.H \
-  ../FL/Fl_Double_Window.H ../FL/Fl_Group.H ../FL/Fl_Choice.H \
-  ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H ../FL/Fl_Preferences.H \
-  ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H \
-  ../FL/Fl_Box.H ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H \
-  ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H \
-  ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H \
-  ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H ../FL/Fl_Timer.H
-forms_timer.o: forms_timer.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Timer.H ../FL/Fl_Widget.H ../FL/fl_draw.H
-Fl_Gl_Choice.o: Fl_Gl_Choice.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H Fl_Gl_Choice.H ../FL/gl_draw.H \
-  ../FL/gl.h flstring.h ../FL/Fl_Export.H
-Fl_Gl_Overlay.o: Fl_Gl_Overlay.cxx ../config.h ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H Fl_Gl_Choice.H ../FL/Fl_Gl_Window.H
-Fl_Gl_Window.o: Fl_Gl_Window.cxx flstring.h ../FL/Fl_Export.H ../config.h \
-  ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H Fl_Gl_Choice.H \
-  ../FL/Fl_Gl_Window.H
-freeglut_geometry.o: freeglut_geometry.cxx ../FL/glut.H ../FL/gl.h \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/math.h
-freeglut_stroke_mono_roman.o: freeglut_stroke_mono_roman.cxx ../FL/glut.H \
-  ../FL/gl.h ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl.H \
-  ../FL/Fl_Gl_Window.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H
-freeglut_stroke_roman.o: freeglut_stroke_roman.cxx ../FL/glut.H \
-  ../FL/gl.h ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl.H \
-  ../FL/Fl_Gl_Window.H ../FL/Fl_Window.H ../FL/Fl_Group.H \
-  ../FL/Fl_Widget.H
-freeglut_teapot.o: freeglut_teapot.cxx ../FL/glut.H ../FL/gl.h \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  freeglut_teapot_data.h
-gl_draw.o: gl_draw.cxx flstring.h ../FL/Fl_Export.H ../config.h \
-  ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/gl.h ../FL/x.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H \
-  Fl_Gl_Choice.H Fl_Font.H
-gl_start.o: gl_start.cxx ../config.h ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H \
-  ../FL/x.H ../FL/Fl_Window.H ../FL/fl_draw.H Fl_Gl_Choice.H
-glut_compatability.o: glut_compatability.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/glut.H ../FL/gl.h ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H ../FL/Fl_Window.H \
-  ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H \
-  ../FL/Fl_Image.H
-glut_font.o: glut_font.cxx ../config.h ../FL/glut.H ../FL/gl.h \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
-fl_images_core.o: fl_images_core.cxx ../FL/Fl_Shared_Image.H \
-  ../FL/Fl_Image.H ../FL/Enumerations.H ../FL/Fl_Export.H \
-  ../FL/Fl_BMP_Image.H ../FL/Fl_GIF_Image.H ../FL/Fl_Pixmap.H \
-  ../FL/Fl_JPEG_Image.H ../FL/Fl_PNG_Image.H ../FL/Fl_PNM_Image.H \
-  flstring.h ../FL/Fl_Export.H ../config.h
-Fl_BMP_Image.o: Fl_BMP_Image.cxx ../FL/Fl_BMP_Image.H ../FL/Fl_Image.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../config.h
-Fl_File_Icon2.o: Fl_File_Icon2.cxx flstring.h ../FL/Fl_Export.H \
-  ../config.h ../FL/math.h ../FL/Fl_File_Icon.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Shared_Image.H \
-  ../FL/Fl_Image.H ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/filename.H
-Fl_GIF_Image.o: Fl_GIF_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_GIF_Image.H ../FL/Fl_Pixmap.H \
-  ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H ../config.h
-Fl_Help_Dialog.o: Fl_Help_Dialog.cxx ../FL/Fl_Help_Dialog.H ../FL/Fl.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Double_Window.H \
-  ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Group.H \
-  ../FL/Fl_Button.H ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Box.H \
-  ../FL/Fl_Help_View.H ../FL/Fl.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H \
-  ../FL/Fl_Valuator.H ../FL/fl_draw.H ../FL/Fl_Shared_Image.H \
-  ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H ../config.h \
-  ../FL/fl_ask.H
-Fl_JPEG_Image.o: Fl_JPEG_Image.cxx ../FL/Fl_JPEG_Image.H ../FL/Fl_Image.H \
-  ../FL/Enumerations.H ../FL/Fl_Export.H ../config.h
-Fl_PNG_Image.o: Fl_PNG_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_PNG_Image.H ../FL/Fl_Image.H ../config.h
-Fl_PNM_Image.o: Fl_PNM_Image.cxx ../FL/Fl.H ../FL/Enumerations.H \
-  ../FL/Fl_Export.H ../FL/Fl_PNM_Image.H ../FL/Fl_Image.H flstring.h \
-  ../FL/Fl_Export.H ../config.h
-fl_call_main.o: fl_call_main.c
-flstring.o: flstring.c flstring.h ../FL/Fl_Export.H ../config.h
-scandir.o: scandir.c flstring.h ../FL/Fl_Export.H ../config.h
-numericsort.o: numericsort.c ../config.h ../FL/filename.H \
-  ../FL/Fl_Export.H
-vsnprintf.o: vsnprintf.c flstring.h ../FL/Fl_Export.H ../config.h
+
+Fl.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Window.H
+Fl.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/x.H ../config.h
+Fl.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H ../FL/Fl_Tooltip.H
+Fl.o: ../FL/Fl_Widget.H flstring.h ../FL/Fl_Export.H ../FL/fl_draw.H
+Fl.o: Fl_directfb.cxx ../FL/Fl_Button.H ../FL/Fl_Box.H ../FL/Fl_Bitmap.H
+Fl.o: ../FL/Fl_Image.H
+Fl_Adjuster.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Adjuster.o: ../FL/Fl_Adjuster.H ../FL/Fl_Valuator.H ../FL/Fl_Widget.H
+Fl_Adjuster.o: ../FL/Fl_Bitmap.H ../FL/Fl_Image.H ../config.h ../FL/fl_draw.H
+Fl_Adjuster.o: fastarrow.h mediumarrow.h slowarrow.h
+Fl_Bitmap.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+Fl_Bitmap.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_Bitmap.o: ../FL/fl_draw.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H
+Fl_Bitmap.o: ../FL/Fl_Widget.H ../FL/Fl_Image.H ../FL/Fl_Bitmap.H flstring.h
+Fl_Bitmap.o: ../FL/Fl_Export.H
+Fl_Browser.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Browser.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Group.H
+Fl_Browser.o: ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H
+Fl_Browser.o: ../FL/Fl_Valuator.H ../FL/fl_draw.H flstring.h
+Fl_Browser.o: ../FL/Fl_Export.H ../config.h
+Fl_Browser_.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Browser_.o: ../FL/Fl_Widget.H ../FL/Fl_Browser_.H ../FL/Fl_Group.H
+Fl_Browser_.o: ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H
+Fl_Browser_.o: ../FL/Fl_Valuator.H ../FL/fl_draw.H
+Fl_Browser_load.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Browser_load.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Group.H
+Fl_Browser_load.o: ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H
+Fl_Browser_load.o: ../FL/Fl_Valuator.H
+Fl_Box.o: ../FL/Fl_Widget.H ../FL/Fl_Box.H
+Fl_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Button.o: ../FL/Fl_Button.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Button.o: ../FL/Fl_Window.H ../FL/Fl_Group.H
+Fl_Chart.o: ../FL/math.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Chart.o: ../FL/Fl_Chart.H ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h
+Fl_Chart.o: ../FL/Fl_Export.H ../config.h
+Fl_Check_Browser.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/fl_draw.H
+Fl_Check_Browser.o: ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Check_Browser.o: ../FL/Fl_Check_Browser.H ../FL/Fl.H ../FL/Fl_Browser_.H
+Fl_Check_Browser.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Scrollbar.H
+Fl_Check_Browser.o: ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_Check_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Check_Button.o: ../FL/Fl_Check_Button.H ../FL/Fl_Light_Button.H
+Fl_Check_Button.o: ../FL/Fl_Button.H ../FL/Fl_Widget.H
+Fl_Choice.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Choice.o: ../FL/Fl_Choice.H ../FL/Fl_Menu_.H ../FL/Fl_Widget.H
+Fl_Choice.o: ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../config.h
+Fl_Choice.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H
+Fl_Clock.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Clock.o: ../FL/Fl_Clock.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Color_Chooser.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Color_Chooser.o: ../FL/Fl_Color_Chooser.H ../FL/Fl_Group.H
+Fl_Color_Chooser.o: ../FL/Fl_Widget.H ../FL/Fl_Box.H ../FL/Fl_Return_Button.H
+Fl_Color_Chooser.o: ../FL/Fl_Button.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H
+Fl_Color_Chooser.o: ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../config.h
+Fl_Color_Chooser.o: ../FL/Fl_Value_Input.H ../FL/Fl_Valuator.H
+Fl_Color_Chooser.o: ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/fl_draw.H
+Fl_Color_Chooser.o: ../FL/math.h ../FL/Fl_Window.H ../FL/Fl_Group.H
+Fl_Counter.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Counter.o: ../FL/Fl_Counter.H ../FL/Fl_Valuator.H ../FL/Fl_Widget.H
+Fl_Counter.o: ../FL/fl_draw.H
+Fl_Dial.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Dial.H
+Fl_Dial.o: ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/math.h
+Fl_Double_Window.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H
+Fl_Double_Window.o: ../FL/Fl_Export.H ../FL/Fl_Double_Window.H
+Fl_Double_Window.o: ../FL/Fl_Window.H ../FL/x.H ../FL/DirectFB.H
+Fl_Double_Window.o: ../FL/xutils.h ../FL/fl_draw.H
+Fl_File_Browser.o: ../FL/Fl_File_Browser.H ../FL/Fl_Browser.H
+Fl_File_Browser.o: ../FL/Fl_Browser_.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_File_Browser.o: ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_File_Browser.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_File_Browser.o: ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/filename.H
+Fl_File_Browser.o: ../FL/fl_draw.H ../FL/filename.H flstring.h
+Fl_File_Browser.o: ../FL/Fl_Export.H ../config.h
+Fl_File_Chooser.o: ../FL/Fl_File_Chooser.H ../FL/Fl.H ../FL/Enumerations.H
+Fl_File_Chooser.o: ../FL/Fl_Export.H ../FL/Fl_Double_Window.H
+Fl_File_Chooser.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_File_Chooser.o: ../FL/Fl_Choice.H ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H
+Fl_File_Chooser.o: ../FL/Fl_Image.H ../config.h ../FL/Fl_Menu_Button.H
+Fl_File_Chooser.o: ../FL/Fl_Button.H ../FL/Fl_Preferences.H ../FL/Fl_Tile.H
+Fl_File_Chooser.o: ../FL/Fl_Group.H ../FL/Fl_File_Browser.H
+Fl_File_Chooser.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H
+Fl_File_Chooser.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_File_Chooser.o: ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/filename.H
+Fl_File_Chooser.o: ../FL/Fl_Box.H ../FL/Fl_Check_Button.H
+Fl_File_Chooser.o: ../FL/Fl_Light_Button.H ../FL/Fl_Button.H
+Fl_File_Chooser.o: ../FL/Fl_File_Input.H ../FL/Fl_Input.H ../FL/Fl_Input_.H
+Fl_File_Chooser.o: ../FL/Fl_Return_Button.H ../FL/fl_ask.H ../FL/fl_draw.H
+Fl_File_Chooser.o: ../FL/Fl_Bitmap.H
+Fl_File_Chooser2.o: ../FL/Fl_File_Chooser.H ../FL/Fl.H ../FL/Enumerations.H
+Fl_File_Chooser2.o: ../FL/Fl_Export.H ../FL/Fl_Double_Window.H
+Fl_File_Chooser2.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_File_Chooser2.o: ../FL/Fl_Choice.H ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H
+Fl_File_Chooser2.o: ../FL/Fl_Image.H ../config.h ../FL/Fl_Menu_Button.H
+Fl_File_Chooser2.o: ../FL/Fl_Button.H ../FL/Fl_Preferences.H ../FL/Fl_Tile.H
+Fl_File_Chooser2.o: ../FL/Fl_Group.H ../FL/Fl_File_Browser.H
+Fl_File_Chooser2.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H
+Fl_File_Chooser2.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H
+Fl_File_Chooser2.o: ../FL/Fl_Valuator.H ../FL/Fl_File_Icon.H ../FL/Fl.H
+Fl_File_Chooser2.o: ../FL/filename.H ../FL/Fl_Box.H ../FL/Fl_Check_Button.H
+Fl_File_Chooser2.o: ../FL/Fl_Light_Button.H ../FL/Fl_Button.H
+Fl_File_Chooser2.o: ../FL/Fl_File_Input.H ../FL/Fl_Input.H ../FL/Fl_Input_.H
+Fl_File_Chooser2.o: ../FL/Fl_Return_Button.H ../FL/fl_ask.H ../FL/filename.H
+Fl_File_Chooser2.o: ../FL/x.H ../FL/DirectFB.H ../FL/xutils.h
+Fl_File_Chooser2.o: ../FL/Fl_Shared_Image.H flstring.h ../FL/Fl_Export.H
+Fl_File_Icon.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl_File_Icon.H
+Fl_File_Icon.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_File_Icon.o: ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/filename.H
+Fl_File_Input.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_File_Input.o: ../FL/Fl_File_Input.H ../FL/Fl_Input.H ../FL/Fl_Input_.H
+Fl_File_Input.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_File_Input.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
+Fl_Group.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Group.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Window.H
+Fl_Group.o: ../FL/Fl_Group.H ../FL/fl_draw.H
+Fl_Help_View.o: ../FL/Fl_Help_View.H ../FL/Fl.H ../FL/Enumerations.H
+Fl_Help_View.o: ../FL/Fl_Export.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Help_View.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_Help_View.o: ../FL/fl_draw.H ../FL/Fl_Shared_Image.H ../FL/Fl_Image.H
+Fl_Help_View.o: ../config.h ../FL/Fl_Window.H ../FL/Fl_Pixmap.H ../FL/x.H
+Fl_Help_View.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H flstring.h
+Fl_Help_View.o: ../FL/Fl_Export.H
+Fl_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_draw.H
+Fl_Image.o: ../FL/x.H ../config.h ../FL/DirectFB.H ../FL/xutils.h
+Fl_Image.o: ../FL/Fl_Window.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H
+Fl_Image.o: ../FL/Fl_Widget.H ../FL/Fl_Image.H ../FL/Fl_Image.H flstring.h
+Fl_Image.o: ../FL/Fl_Export.H
+Fl_Input.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Input.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Input.o: ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/fl_draw.H ../FL/fl_ask.H
+Fl_Input.o: flstring.h ../FL/Fl_Export.H ../config.h
+Fl_Input_.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Input_.o: ../FL/Fl_Input_.H ../FL/Fl_Widget.H ../FL/Fl_Window.H
+Fl_Input_.o: ../FL/Fl_Group.H ../FL/fl_draw.H ../FL/fl_ask.H flstring.h
+Fl_Input_.o: ../FL/Fl_Export.H ../config.h
+Fl_Light_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Light_Button.o: ../FL/Fl_Light_Button.H ../FL/Fl_Button.H
+Fl_Light_Button.o: ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h
+Fl_Light_Button.o: ../FL/Fl_Export.H ../config.h
+Fl_Menu.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Menu.o: ../FL/Fl_Menu_Window.H ../FL/Fl_Single_Window.H ../FL/Fl_Window.H
+Fl_Menu.o: ../FL/Fl_Menu_.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H
+Fl_Menu.o: ../FL/Fl_Image.H ../config.h ../FL/fl_draw.H flstring.h
+Fl_Menu.o: ../FL/Fl_Export.H
+Fl_Menu_.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Menu_.o: ../FL/Fl_Menu_.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H
+Fl_Menu_.o: ../FL/Fl_Image.H ../config.h flstring.h ../FL/Fl_Export.H
+Fl_Menu_Bar.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Menu_Bar.o: ../FL/Fl_Menu_Bar.H ../FL/Fl_Menu_.H ../FL/Fl_Widget.H
+Fl_Menu_Bar.o: ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../config.h
+Fl_Menu_Bar.o: ../FL/fl_draw.H
+Fl_Menu_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Menu_Button.o: ../FL/Fl_Menu_Button.H ../FL/Fl_Menu_.H ../FL/Fl_Widget.H
+Fl_Menu_Button.o: ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H ../config.h
+Fl_Menu_Button.o: ../FL/fl_draw.H
+Fl_Menu_Window.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H
+Fl_Menu_Window.o: ../FL/Fl_Export.H ../FL/x.H ../FL/DirectFB.H ../FL/xutils.h
+Fl_Menu_Window.o: ../FL/Fl_Window.H ../FL/fl_draw.H ../FL/Fl_Menu_Window.H
+Fl_Menu_Window.o: ../FL/Fl_Single_Window.H
+Fl_Menu_add.o: ../FL/Fl_Menu_.H ../FL/Fl_Widget.H ../FL/Enumerations.H
+Fl_Menu_add.o: ../FL/Fl_Export.H ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H
+Fl_Menu_add.o: ../config.h flstring.h ../FL/Fl_Export.H
+Fl_Menu_global.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Menu_global.o: ../FL/Fl_Menu_.H ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H
+Fl_Menu_global.o: ../FL/Fl_Image.H ../config.h
+Fl_Multi_Label.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Multi_Label.o: ../FL/Fl_Widget.H ../FL/Fl_Menu_Item.H ../FL/Fl_Widget.H
+Fl_Multi_Label.o: ../FL/Fl_Image.H ../config.h ../FL/Fl_Multi_Label.H
+Fl_Overlay_Window.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H
+Fl_Overlay_Window.o: ../FL/Fl_Export.H ../FL/Fl_Overlay_Window.H
+Fl_Overlay_Window.o: ../FL/Fl_Double_Window.H ../FL/Fl_Window.H
+Fl_Overlay_Window.o: ../FL/fl_draw.H ../FL/x.H ../FL/DirectFB.H
+Fl_Overlay_Window.o: ../FL/xutils.h
+Fl_Pack.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Pack.H
+Fl_Pack.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Pixmap.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Pixmap.o: ../FL/fl_draw.H ../FL/x.H ../config.h ../FL/DirectFB.H
+Fl_Pixmap.o: ../FL/xutils.h ../FL/Fl_Window.H ../FL/Fl_Widget.H
+Fl_Pixmap.o: ../FL/Fl_Menu_Item.H ../FL/Fl_Widget.H ../FL/Fl_Image.H
+Fl_Pixmap.o: ../FL/Fl_Pixmap.H flstring.h ../FL/Fl_Export.H
+Fl_Positioner.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Positioner.o: ../FL/Fl_Positioner.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Preferences.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Preferences.o: ../FL/Fl_Preferences.H ../FL/filename.H flstring.h
+Fl_Preferences.o: ../FL/Fl_Export.H ../config.h
+Fl_Progress.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Progress.o: ../FL/Fl_Progress.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Repeat_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Repeat_Button.o: ../FL/Fl_Repeat_Button.H ../FL/Fl.H ../FL/Fl_Button.H
+Fl_Repeat_Button.o: ../FL/Fl_Widget.H
+Fl_Return_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Return_Button.o: ../FL/Fl_Return_Button.H ../FL/Fl_Button.H
+Fl_Return_Button.o: ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Roller.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Roller.o: ../FL/Fl_Roller.H ../FL/Fl_Valuator.H ../FL/Fl_Widget.H
+Fl_Roller.o: ../FL/fl_draw.H
+Fl_Round_Button.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Round_Button.o: ../FL/Fl_Round_Button.H ../FL/Fl_Light_Button.H
+Fl_Round_Button.o: ../FL/Fl_Button.H ../FL/Fl_Widget.H
+Fl_Scroll.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Scroll.o: ../FL/Fl_Tiled_Image.H ../FL/Fl_Image.H ../config.h
+Fl_Scroll.o: ../FL/Fl_Scroll.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Scroll.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_Scroll.o: ../FL/fl_draw.H
+Fl_Scrollbar.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Scrollbar.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_Scrollbar.o: ../FL/Fl_Widget.H ../FL/fl_draw.H flstring.h
+Fl_Scrollbar.o: ../FL/Fl_Export.H ../config.h
+Fl_Shared_Image.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H
+Fl_Shared_Image.o: ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Shared_Image.o: ../FL/Fl_Shared_Image.H ../FL/Fl_Image.H
+Fl_Shared_Image.o: ../FL/Fl_XBM_Image.H ../FL/Fl_Bitmap.H
+Fl_Shared_Image.o: ../FL/Fl_XPM_Image.H ../FL/Fl_Pixmap.H
+Fl_Single_Window.o: ../FL/Fl_Single_Window.H ../FL/Fl_Window.H
+Fl_Slider.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Slider.o: ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Widget.H
+Fl_Slider.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
+Fl_Tabs.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Tabs.H
+Fl_Tabs.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Tabs.o: ../FL/Fl_Tooltip.H ../FL/Fl_Widget.H
+Fl_Text_Buffer.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H
+Fl_Text_Buffer.o: ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Text_Buffer.o: ../FL/Fl_Text_Buffer.H
+Fl_Text_Display.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H
+Fl_Text_Display.o: ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Text_Display.o: ../FL/Fl_Text_Buffer.H ../FL/Fl_Text_Display.H
+Fl_Text_Display.o: ../FL/fl_draw.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Text_Display.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_Text_Display.o: ../FL/Fl_Text_Buffer.H ../FL/Fl_Window.H
+Fl_Text_Editor.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H
+Fl_Text_Editor.o: ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Window.H
+Fl_Text_Editor.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Text_Editor.H
+Fl_Text_Editor.o: ../FL/Fl_Text_Display.H ../FL/fl_draw.H
+Fl_Text_Editor.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+Fl_Text_Editor.o: ../FL/Fl_Text_Buffer.H ../FL/fl_ask.H
+Fl_Tile.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Tile.H
+Fl_Tile.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Window.H
+Fl_Tiled_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Tiled_Image.o: ../FL/Fl_Tiled_Image.H ../FL/Fl_Image.H ../config.h
+Fl_Tiled_Image.o: ../FL/fl_draw.H
+Fl_Tooltip.o: ../FL/Fl_Tooltip.H ../FL/Fl.H ../FL/Enumerations.H
+Fl_Tooltip.o: ../FL/Fl_Export.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Tooltip.o: ../FL/Fl_Menu_Window.H ../FL/Fl_Single_Window.H
+Fl_Tooltip.o: ../FL/Fl_Window.H
+Fl_Valuator.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Valuator.o: ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/math.h flstring.h
+Fl_Valuator.o: ../FL/Fl_Export.H ../config.h
+Fl_Value_Input.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Value_Input.o: ../FL/Fl_Value_Input.H ../FL/Fl_Valuator.H
+Fl_Value_Input.o: ../FL/Fl_Widget.H ../FL/Fl_Input.H ../FL/Fl_Input_.H
+Fl_Value_Input.o: ../FL/Fl_Group.H ../FL/math.h
+Fl_Value_Output.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Value_Output.o: ../FL/Fl_Value_Output.H ../FL/Fl_Valuator.H
+Fl_Value_Output.o: ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Value_Slider.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Value_Slider.o: ../FL/Fl_Value_Slider.H ../FL/Fl_Slider.H
+Fl_Value_Slider.o: ../FL/Fl_Valuator.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Widget.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Widget.o: ../FL/Fl_Widget.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Widget.o: ../FL/Fl_Tooltip.H ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H
+Fl_Widget.o: ../config.h
+Fl_Window.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Window.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H flstring.h
+Fl_Window.o: ../FL/Fl_Export.H ../config.h
+Fl_Window_fullscreen.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Window_fullscreen.o: ../FL/x.H ../config.h ../FL/DirectFB.H ../FL/xutils.h
+Fl_Window_fullscreen.o: ../FL/Fl_Window.H
+Fl_Window_hotspot.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_Window_hotspot.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Window_hotspot.o: ../FL/x.H ../config.h ../FL/DirectFB.H ../FL/xutils.h
+Fl_Window_hotspot.o: ../FL/Fl_Window.H
+Fl_Window_iconize.o: ../FL/x.H ../config.h ../FL/Enumerations.H
+Fl_Window_iconize.o: ../FL/Fl_Export.H ../FL/DirectFB.H ../FL/xutils.h
+Fl_Window_iconize.o: ../FL/Fl_Window.H
+Fl_Wizard.o: ../FL/Fl_Wizard.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Wizard.o: ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/Fl_Window.H
+Fl_Wizard.o: ../FL/Fl_Group.H ../FL/fl_draw.H
+Fl_XBM_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_XBM_Image.o: ../FL/Fl_XBM_Image.H ../FL/Fl_Bitmap.H ../FL/Fl_Image.H
+Fl_XBM_Image.o: ../config.h flstring.h ../FL/Fl_Export.H
+Fl_XPM_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_XPM_Image.o: ../FL/Fl_XPM_Image.H ../FL/Fl_Pixmap.H ../FL/Fl_Image.H
+Fl_XPM_Image.o: ../config.h flstring.h ../FL/Fl_Export.H
+Fl_abort.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H flstring.h
+Fl_abort.o: ../FL/Fl_Export.H ../config.h
+Fl_add_idle.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_arg.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+Fl_arg.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_arg.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_arg.o: ../FL/Fl_Tooltip.H ../FL/Fl_Widget.H ../FL/filename.H
+Fl_arg.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H
+Fl_compose.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_display.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H flstring.h
+Fl_display.o: ../FL/Fl_Export.H ../config.h
+Fl_get_key.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+Fl_get_key.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_get_system_colors.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H
+Fl_get_system_colors.o: ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H
+Fl_get_system_colors.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_get_system_colors.o: ../FL/math.h flstring.h ../FL/Fl_Export.H
+Fl_get_system_colors.o: ../FL/Fl_Pixmap.H ../FL/Fl_Image.H
+Fl_get_system_colors.o: ../FL/Fl_Tiled_Image.H tile.xpm
+Fl_grab.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_grab.o: ../FL/x.H ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_lock.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../config.h
+Fl_own_colormap.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H
+Fl_own_colormap.o: ../FL/Fl_Export.H ../FL/x.H ../FL/DirectFB.H
+Fl_own_colormap.o: ../FL/xutils.h ../FL/Fl_Window.H
+Fl_visual.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_visual.o: ../FL/x.H ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_x.o: ../config.h
+filename_absolute.o: ../FL/filename.H flstring.h ../FL/Fl_Export.H
+filename_absolute.o: ../config.h
+filename_expand.o: ../FL/filename.H flstring.h ../FL/Fl_Export.H ../config.h
+filename_ext.o: ../FL/filename.H
+filename_isdir.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/filename.H
+filename_list.o: ../FL/filename.H flstring.h ../FL/Fl_Export.H ../config.h
+filename_match.o: ../FL/filename.H
+filename_setext.o: ../FL/filename.H flstring.h ../FL/Fl_Export.H ../config.h
+fl_arc.o: ../FL/fl_draw.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/math.h
+fl_arci.o: ../FL/fl_draw.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+fl_arci.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+fl_arci.o: ../FL/math.h
+fl_ask.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H
+fl_ask.o: ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_ask.H
+fl_ask.o: ../FL/Fl_Box.H ../FL/Fl_Button.H ../FL/Fl_Return_Button.H
+fl_ask.o: ../FL/Fl_Button.H ../FL/Fl_Widget.H ../FL/Fl_Window.H
+fl_ask.o: ../FL/Fl_Group.H ../FL/Fl_Input.H ../FL/Fl_Input_.H
+fl_ask.o: ../FL/Fl_Secret_Input.H ../FL/Fl_Input.H ../FL/x.H ../FL/DirectFB.H
+fl_ask.o: ../FL/xutils.h ../FL/Fl_Window.H ../FL/fl_draw.H
+fl_boxtype.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_boxtype.o: ../FL/Fl_Widget.H ../FL/fl_draw.H ../config.h
+fl_color.o: ../config.h Fl_XColor.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_color.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/x.H ../FL/DirectFB.H
+fl_color.o: ../FL/xutils.h ../FL/Fl_Window.H ../FL/fl_draw.H fl_cmap.h
+fl_cursor.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_cursor.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/x.H
+fl_cursor.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+fl_cursor.o: ../FL/fl_draw.H
+fl_curve.o: ../FL/fl_draw.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_diamond_box.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_diamond_box.o: ../FL/fl_draw.H
+fl_dnd.o: fl_dnd_x.cxx ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_dnd.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/x.H
+fl_dnd.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+fl_dnd.o: flstring.h ../FL/Fl_Export.H
+fl_draw.o: ../FL/fl_draw.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_draw.o: ../FL/Fl_Image.H flstring.h ../FL/Fl_Export.H ../config.h
+fl_draw_image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_draw_image.o: ../FL/fl_draw.H ../FL/x.H ../config.h ../FL/DirectFB.H
+fl_draw_image.o: ../FL/xutils.h ../FL/Fl_Window.H Fl_XColor.H
+fl_draw_image.o: ../FL/Enumerations.H flstring.h ../FL/Fl_Export.H
+fl_draw_pixmap.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_draw_pixmap.o: ../FL/fl_draw.H ../FL/x.H ../config.h ../FL/DirectFB.H
+fl_draw_pixmap.o: ../FL/xutils.h ../FL/Fl_Window.H flstring.h
+fl_draw_pixmap.o: ../FL/Fl_Export.H
+fl_encoding_latin1.o: ../FL/fl_draw.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_encoding_latin1.o: ../FL/Enumerations.H flstring.h ../FL/Fl_Export.H
+fl_encoding_latin1.o: ../config.h
+fl_encoding_mac_roman.o: ../FL/fl_draw.H ../FL/Enumerations.H
+fl_encoding_mac_roman.o: ../FL/Fl_Export.H ../FL/Enumerations.H flstring.h
+fl_encoding_mac_roman.o: ../FL/Fl_Export.H ../config.h
+fl_engraved_label.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_engraved_label.o: ../FL/Fl_Widget.H ../FL/fl_draw.H
+fl_file_dir.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/filename.H
+fl_file_dir.o: ../FL/Fl_File_Chooser.H ../FL/Fl.H ../FL/Enumerations.H
+fl_file_dir.o: ../FL/Fl_Export.H ../FL/Fl_Double_Window.H ../FL/Fl_Window.H
+fl_file_dir.o: ../FL/Fl_Group.H ../FL/Fl_Widget.H ../FL/Fl_Choice.H
+fl_file_dir.o: ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H ../FL/Fl_Image.H
+fl_file_dir.o: ../FL/Fl_Menu_Button.H ../FL/Fl_Button.H
+fl_file_dir.o: ../FL/Fl_Preferences.H ../FL/Fl_Tile.H ../FL/Fl_Group.H
+fl_file_dir.o: ../FL/Fl_File_Browser.H ../FL/Fl_Browser.H ../FL/Fl_Browser_.H
+fl_file_dir.o: ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+fl_file_dir.o: ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/filename.H
+fl_file_dir.o: ../FL/Fl_Box.H ../FL/Fl_Check_Button.H ../FL/Fl_Light_Button.H
+fl_file_dir.o: ../FL/Fl_Button.H ../FL/Fl_File_Input.H ../FL/Fl_Input.H
+fl_file_dir.o: ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H ../FL/fl_ask.H
+fl_font.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/Fl.H
+fl_font.o: ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_draw.H ../FL/x.H
+fl_font.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H Fl_Font.H
+fl_font.o: fl_font_directfb.cxx
+fl_gtk.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/fl_draw.H
+fl_labeltype.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_labeltype.o: ../FL/Fl_Widget.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+fl_labeltype.o: ../FL/fl_draw.H ../FL/Fl_Image.H ../FL/Fl_Input_.H
+fl_line_style.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_line_style.o: ../FL/fl_draw.H ../FL/x.H ../config.h ../FL/DirectFB.H
+fl_line_style.o: ../FL/xutils.h ../FL/Fl_Window.H flstring.h
+fl_line_style.o: ../FL/Fl_Export.H
+fl_open_uri.o: ../FL/filename.H flstring.h ../FL/Fl_Export.H ../config.h
+fl_oval_box.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_oval_box.o: ../FL/fl_draw.H
+fl_overlay.o: ../FL/x.H ../config.h ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_overlay.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+fl_overlay.o: ../FL/fl_draw.H
+fl_overlay_visual.o: ../config.h
+fl_plastic.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_plastic.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H ../config.h
+fl_read_image.o: ../FL/x.H ../config.h ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_read_image.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H ../FL/Fl.H
+fl_read_image.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H
+fl_rect.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_rect.o: ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/x.H ../FL/DirectFB.H
+fl_rect.o: ../FL/xutils.h ../FL/Fl_Window.H
+fl_round_box.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_round_box.o: ../FL/fl_draw.H
+fl_rounded_box.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_rounded_box.o: ../FL/fl_draw.H
+fl_set_font.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+fl_set_font.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+fl_set_font.o: ../FL/fl_draw.H flstring.h ../FL/Fl_Export.H Fl_Font.H
+fl_set_fonts.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+fl_set_fonts.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+fl_set_fonts.o: Fl_Font.H flstring.h ../FL/Fl_Export.H fl_set_fonts_x.cxx
+fl_scroll_area.o: ../config.h ../FL/Fl.H ../FL/Enumerations.H
+fl_scroll_area.o: ../FL/Fl_Export.H ../FL/x.H ../FL/DirectFB.H ../FL/xutils.h
+fl_scroll_area.o: ../FL/Fl_Window.H ../FL/fl_draw.H
+fl_shadow_box.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_shadow_box.o: ../FL/fl_draw.H
+fl_shortcut.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_shortcut.o: ../FL/Fl_Widget.H ../FL/Fl_Button.H ../FL/fl_draw.H flstring.h
+fl_shortcut.o: ../FL/Fl_Export.H ../config.h ../FL/x.H ../FL/DirectFB.H
+fl_shortcut.o: ../FL/xutils.h ../FL/Fl_Window.H
+fl_show_colormap.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_show_colormap.o: ../FL/Fl_Single_Window.H ../FL/Fl_Window.H
+fl_show_colormap.o: ../FL/fl_draw.H ../FL/fl_show_colormap.H ../config.h
+fl_symbols.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+fl_symbols.o: ../FL/fl_draw.H ../FL/math.h flstring.h ../FL/Fl_Export.H
+fl_symbols.o: ../config.h
+fl_vertex.o: ../config.h ../FL/fl_draw.H ../FL/Enumerations.H
+fl_vertex.o: ../FL/Fl_Export.H ../FL/x.H ../FL/DirectFB.H ../FL/xutils.h
+fl_vertex.o: ../FL/Fl_Window.H ../FL/Fl.H ../FL/math.h
+screen_xywh.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H ../FL/x.H
+screen_xywh.o: ../config.h ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+xutils.o: ../config.h ../FL/x.H ../FL/Enumerations.H ../FL/Fl_Export.H
+xutils.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H _listfonts.cxx
+xutils.o: _loadfont.cxx _draw.cxx ../FL/fl_draw.H _arcpoly.cxx _colormap.cxx
+xutils.o: ../FL/Fl.H _image.cxx
+forms_compatability.o: ../FL/forms.H ../FL/Fl.H ../FL/Enumerations.H
+forms_compatability.o: ../FL/Fl_Export.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+forms_compatability.o: ../FL/Fl_Window.H ../FL/fl_draw.H
+forms_compatability.o: ../FL/Fl_FormsBitmap.H ../FL/Fl_Bitmap.H
+forms_compatability.o: ../FL/Fl_Image.H ../config.h ../FL/Fl_FormsPixmap.H
+forms_compatability.o: ../FL/Fl_Pixmap.H ../FL/Fl_Box.H ../FL/Fl_Browser.H
+forms_compatability.o: ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H
+forms_compatability.o: ../FL/Fl_Slider.H ../FL/Fl_Valuator.H
+forms_compatability.o: ../FL/Fl_Button.H ../FL/Fl_Light_Button.H
+forms_compatability.o: ../FL/Fl_Round_Button.H ../FL/Fl_Check_Button.H
+forms_compatability.o: ../FL/Fl_Chart.H ../FL/Fl_Choice.H ../FL/Fl_Menu_.H
+forms_compatability.o: ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H
+forms_compatability.o: ../FL/Fl_Counter.H ../FL/Fl_Dial.H ../FL/Fl_Free.H
+forms_compatability.o: ../FL/fl_ask.H ../FL/fl_show_colormap.H
+forms_compatability.o: ../FL/filename.H ../FL/Fl_File_Chooser.H ../FL/Fl.H
+forms_compatability.o: ../FL/Fl_Double_Window.H ../FL/Fl_Group.H
+forms_compatability.o: ../FL/Fl_Choice.H ../FL/Fl_Menu_Button.H
+forms_compatability.o: ../FL/Fl_Button.H ../FL/Fl_Preferences.H
+forms_compatability.o: ../FL/Fl_Tile.H ../FL/Fl_File_Browser.H
+forms_compatability.o: ../FL/Fl_File_Icon.H ../FL/Fl_Box.H
+forms_compatability.o: ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H
+forms_compatability.o: ../FL/Fl_Input.H ../FL/Fl_Input_.H
+forms_compatability.o: ../FL/Fl_Return_Button.H ../FL/fl_ask.H
+forms_compatability.o: ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H
+forms_compatability.o: ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H
+forms_compatability.o: ../FL/Fl_Timer.H ../FL/Fl_Repeat_Button.H
+forms_bitmap.o: ../FL/forms.H ../FL/Fl.H ../FL/Enumerations.H
+forms_bitmap.o: ../FL/Fl_Export.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+forms_bitmap.o: ../FL/Fl_Window.H ../FL/fl_draw.H ../FL/Fl_FormsBitmap.H
+forms_bitmap.o: ../FL/Fl_Bitmap.H ../FL/Fl_Image.H ../config.h
+forms_bitmap.o: ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H
+forms_bitmap.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H
+forms_bitmap.o: ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H
+forms_bitmap.o: ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H
+forms_bitmap.o: ../FL/Fl_Check_Button.H ../FL/Fl_Chart.H ../FL/Fl_Choice.H
+forms_bitmap.o: ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H
+forms_bitmap.o: ../FL/Fl_Counter.H ../FL/Fl_Dial.H ../FL/Fl_Free.H
+forms_bitmap.o: ../FL/fl_ask.H ../FL/fl_show_colormap.H ../FL/filename.H
+forms_bitmap.o: ../FL/Fl_File_Chooser.H ../FL/Fl.H ../FL/Fl_Double_Window.H
+forms_bitmap.o: ../FL/Fl_Group.H ../FL/Fl_Choice.H ../FL/Fl_Menu_Button.H
+forms_bitmap.o: ../FL/Fl_Button.H ../FL/Fl_Preferences.H ../FL/Fl_Tile.H
+forms_bitmap.o: ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H ../FL/Fl_Box.H
+forms_bitmap.o: ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H
+forms_bitmap.o: ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H
+forms_bitmap.o: ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H
+forms_bitmap.o: ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H
+forms_bitmap.o: ../FL/Fl_Timer.H
+forms_free.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+forms_free.o: ../FL/Fl_Free.H ../FL/Fl_Widget.H
+forms_fselect.o: ../FL/forms.H ../FL/Fl.H ../FL/Enumerations.H
+forms_fselect.o: ../FL/Fl_Export.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+forms_fselect.o: ../FL/Fl_Window.H ../FL/fl_draw.H ../FL/Fl_FormsBitmap.H
+forms_fselect.o: ../FL/Fl_Bitmap.H ../FL/Fl_Image.H ../config.h
+forms_fselect.o: ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H
+forms_fselect.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H
+forms_fselect.o: ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H
+forms_fselect.o: ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H
+forms_fselect.o: ../FL/Fl_Check_Button.H ../FL/Fl_Chart.H ../FL/Fl_Choice.H
+forms_fselect.o: ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H
+forms_fselect.o: ../FL/Fl_Counter.H ../FL/Fl_Dial.H ../FL/Fl_Free.H
+forms_fselect.o: ../FL/fl_ask.H ../FL/fl_show_colormap.H ../FL/filename.H
+forms_fselect.o: ../FL/Fl_File_Chooser.H ../FL/Fl.H ../FL/Fl_Double_Window.H
+forms_fselect.o: ../FL/Fl_Group.H ../FL/Fl_Choice.H ../FL/Fl_Menu_Button.H
+forms_fselect.o: ../FL/Fl_Button.H ../FL/Fl_Preferences.H ../FL/Fl_Tile.H
+forms_fselect.o: ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H ../FL/Fl_Box.H
+forms_fselect.o: ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H
+forms_fselect.o: ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H
+forms_fselect.o: ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H
+forms_fselect.o: ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H
+forms_fselect.o: ../FL/Fl_Timer.H flstring.h ../FL/Fl_Export.H
+forms_pixmap.o: ../FL/forms.H ../FL/Fl.H ../FL/Enumerations.H
+forms_pixmap.o: ../FL/Fl_Export.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+forms_pixmap.o: ../FL/Fl_Window.H ../FL/fl_draw.H ../FL/Fl_FormsBitmap.H
+forms_pixmap.o: ../FL/Fl_Bitmap.H ../FL/Fl_Image.H ../config.h
+forms_pixmap.o: ../FL/Fl_FormsPixmap.H ../FL/Fl_Pixmap.H ../FL/Fl_Box.H
+forms_pixmap.o: ../FL/Fl_Browser.H ../FL/Fl_Browser_.H ../FL/Fl_Scrollbar.H
+forms_pixmap.o: ../FL/Fl_Slider.H ../FL/Fl_Valuator.H ../FL/Fl_Button.H
+forms_pixmap.o: ../FL/Fl_Light_Button.H ../FL/Fl_Round_Button.H
+forms_pixmap.o: ../FL/Fl_Check_Button.H ../FL/Fl_Chart.H ../FL/Fl_Choice.H
+forms_pixmap.o: ../FL/Fl_Menu_.H ../FL/Fl_Menu_Item.H ../FL/Fl_Clock.H
+forms_pixmap.o: ../FL/Fl_Counter.H ../FL/Fl_Dial.H ../FL/Fl_Free.H
+forms_pixmap.o: ../FL/fl_ask.H ../FL/fl_show_colormap.H ../FL/filename.H
+forms_pixmap.o: ../FL/Fl_File_Chooser.H ../FL/Fl.H ../FL/Fl_Double_Window.H
+forms_pixmap.o: ../FL/Fl_Group.H ../FL/Fl_Choice.H ../FL/Fl_Menu_Button.H
+forms_pixmap.o: ../FL/Fl_Button.H ../FL/Fl_Preferences.H ../FL/Fl_Tile.H
+forms_pixmap.o: ../FL/Fl_File_Browser.H ../FL/Fl_File_Icon.H ../FL/Fl_Box.H
+forms_pixmap.o: ../FL/Fl_Check_Button.H ../FL/Fl_File_Input.H
+forms_pixmap.o: ../FL/Fl_Input.H ../FL/Fl_Input_.H ../FL/Fl_Return_Button.H
+forms_pixmap.o: ../FL/fl_ask.H ../FL/Fl_Input.H ../FL/Fl_Menu_Button.H
+forms_pixmap.o: ../FL/Fl_Positioner.H ../FL/Fl_Value_Slider.H
+forms_pixmap.o: ../FL/Fl_Timer.H
+forms_timer.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+forms_timer.o: ../FL/Fl_Timer.H ../FL/Fl_Widget.H ../FL/fl_draw.H
+Fl_Gl_Choice.o: ../config.h
+Fl_Gl_Overlay.o: ../config.h
+Fl_Gl_Window.o: flstring.h ../FL/Fl_Export.H ../config.h
+freeglut_geometry.o: ../FL/glut.H ../FL/gl.h ../FL/Enumerations.H
+freeglut_geometry.o: ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H
+freeglut_geometry.o: ../FL/Fl_Window.H ../FL/math.h
+freeglut_stroke_mono_roman.o: ../FL/glut.H ../FL/gl.h ../FL/Enumerations.H
+freeglut_stroke_mono_roman.o: ../FL/Fl_Export.H ../FL/Fl.H
+freeglut_stroke_mono_roman.o: ../FL/Fl_Gl_Window.H ../FL/Fl_Window.H
+freeglut_stroke_roman.o: ../FL/glut.H ../FL/gl.h ../FL/Enumerations.H
+freeglut_stroke_roman.o: ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H
+freeglut_stroke_roman.o: ../FL/Fl_Window.H
+freeglut_teapot.o: ../FL/glut.H ../FL/gl.h ../FL/Enumerations.H
+freeglut_teapot.o: ../FL/Fl_Export.H ../FL/Fl.H ../FL/Fl_Gl_Window.H
+freeglut_teapot.o: ../FL/Fl_Window.H freeglut_teapot_data.h
+gl_draw.o: flstring.h ../FL/Fl_Export.H ../config.h
+gl_start.o: ../config.h
+glut_compatability.o: flstring.h ../FL/Fl_Export.H ../config.h
+glut_font.o: ../config.h
+fl_images_core.o: ../FL/Fl_Shared_Image.H ../FL/Fl_Image.H
+fl_images_core.o: ../FL/Enumerations.H ../FL/Fl_Export.H ../config.h
+fl_images_core.o: ../FL/Fl_BMP_Image.H ../FL/Fl_GIF_Image.H ../FL/Fl_Pixmap.H
+fl_images_core.o: ../FL/Fl_JPEG_Image.H ../FL/Fl_PNG_Image.H
+fl_images_core.o: ../FL/Fl_PNM_Image.H flstring.h ../FL/Fl_Export.H
+Fl_BMP_Image.o: ../FL/Fl_BMP_Image.H ../FL/Fl_Image.H ../FL/Enumerations.H
+Fl_BMP_Image.o: ../FL/Fl_Export.H ../config.h
+Fl_File_Icon2.o: flstring.h ../FL/Fl_Export.H ../config.h ../FL/math.h
+Fl_File_Icon2.o: ../FL/Fl_File_Icon.H ../FL/Fl.H ../FL/Enumerations.H
+Fl_File_Icon2.o: ../FL/Fl_Export.H ../FL/Fl_Shared_Image.H ../FL/Fl_Image.H
+Fl_File_Icon2.o: ../FL/Fl_Widget.H ../FL/fl_draw.H ../FL/filename.H
+Fl_GIF_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_GIF_Image.o: ../FL/Fl_GIF_Image.H ../FL/Fl_Pixmap.H ../FL/Fl_Image.H
+Fl_GIF_Image.o: ../config.h flstring.h ../FL/Fl_Export.H ../FL/x.H
+Fl_GIF_Image.o: ../FL/DirectFB.H ../FL/xutils.h ../FL/Fl_Window.H
+Fl_Help_Dialog.o: ../FL/Fl_Help_Dialog.H ../FL/Fl.H ../FL/Enumerations.H
+Fl_Help_Dialog.o: ../FL/Fl_Export.H ../FL/Fl_Double_Window.H
+Fl_Help_Dialog.o: ../FL/Fl_Window.H ../FL/Fl_Group.H ../FL/Fl_Widget.H
+Fl_Help_Dialog.o: ../FL/Fl_Button.H ../FL/Fl_Input.H ../FL/Fl_Input_.H
+Fl_Help_Dialog.o: ../FL/Fl_Box.H ../FL/Fl_Help_View.H ../FL/Fl.H
+Fl_Help_Dialog.o: ../FL/Fl_Group.H ../FL/Fl_Scrollbar.H ../FL/Fl_Slider.H
+Fl_Help_Dialog.o: ../FL/Fl_Valuator.H ../FL/fl_draw.H ../FL/Fl_Shared_Image.H
+Fl_Help_Dialog.o: ../FL/Fl_Image.H ../config.h flstring.h ../FL/Fl_Export.H
+Fl_Help_Dialog.o: ../FL/fl_ask.H
+Fl_JPEG_Image.o: ../FL/Fl_JPEG_Image.H ../FL/Fl_Image.H ../FL/Enumerations.H
+Fl_JPEG_Image.o: ../FL/Fl_Export.H ../config.h ../FL/x.H ../FL/DirectFB.H
+Fl_JPEG_Image.o: ../FL/xutils.h ../FL/Fl_Window.H
+Fl_PNG_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_PNG_Image.o: ../FL/Fl_PNG_Image.H ../FL/Fl_Image.H ../config.h
+Fl_PNM_Image.o: ../FL/Fl.H ../FL/Enumerations.H ../FL/Fl_Export.H
+Fl_PNM_Image.o: ../FL/Fl_PNM_Image.H ../FL/Fl_Image.H ../config.h flstring.h
+Fl_PNM_Image.o: ../FL/Fl_Export.H
+flstring.o: flstring.h ../FL/Fl_Export.H ../config.h
+scandir.o: flstring.h ../FL/Fl_Export.H ../config.h
+numericsort.o: ../config.h ../FL/filename.H
+vsnprintf.o: flstring.h ../FL/Fl_Export.H ../config.h
diff -Nwrup -x.git fltk-1.1.9/src/Makefile FLTK_1.x-DirectFB/src/Makefile
--- fltk-1.1.9/src/Makefile	2008-02-27 10:00:31.000000000 -0500
+++ FLTK_1.x-DirectFB/src/Makefile	2009-11-28 15:48:05.982153769 -0500
@@ -153,7 +153,8 @@ CPPFILES = \
 	fl_show_colormap.cxx \
 	fl_symbols.cxx \
 	fl_vertex.cxx \
-	screen_xywh.cxx
+	screen_xywh.cxx\
+	xutils.cxx
 
 FLCPPFILES = \
 	forms_compatability.cxx \
diff -Nwrup -x.git fltk-1.1.9/src/xutils.cxx FLTK_1.x-DirectFB/src/xutils.cxx
--- fltk-1.1.9/src/xutils.cxx	1969-12-31 19:00:00.000000000 -0500
+++ FLTK_1.x-DirectFB/src/xutils.cxx	2009-11-28 15:48:06.004155016 -0500
@@ -0,0 +1,872 @@
+//
+// "$Id: xutils.cxx 16 2007-03-09 13:23:55Z nikego $"
+//
+// DirectFB-specific code for the Fast Light Tool Kit (FLTK).
+//
+// Copyright 1998-2005 by Bill Spitzak and others.
+// Written by Nikita Egorov (nikego@gmail.com)
+//
+// This library is free software; you can redistribute it and/or
+// modify it under the terms of the GNU Library General Public
+// License as published by the Free Software Foundation; either
+// version 2 of the License, or (at your option) any later version.
+//
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+// Library General Public License for more details.
+//
+// You should have received a copy of the GNU Library General Public
+// License along with this library; if not, write to the Free Software
+// Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
+// USA.
+//
+// Please report all bugs and problems on the following page:
+//
+//     http://www.fltk.org/str.php
+//
+// This file contains colormap-specific code for fltk which is always linked
+// in.  Search other files for "DIRECTFB" or filenames ending in _directfb.cxx
+// for other system-specific code.
+//
+ 
+#include <config.h>
+
+#ifdef DIRECTFB
+#include "FL/x.H" 
+#include <stdlib.h>
+#include <stdio.h>
+#include <string.h>
+
+static void
+strlwr(char* buf){
+  while(*buf){
+    *buf = __tolower(*buf); 
+    buf++;
+  }
+}
+#define sqr(a) ((a)*(a))
+
+/*******************
+ * XListFonts()
+ * XFreeFontNames()
+ * XSetFontPath()
+ * XGetFontPath()
+ * XFreeFontPath()
+*/ 	
+#include "_listfonts.cxx"
+/*******************
+ * XLoadFont
+*/
+#include "_loadfont.cxx"
+/*******************
+ * XDrawLine()
+ * XDrawLines()
+ * XDrawRectangle()
+ * XFillRectangle()
+ * work with non ascii font charset. cyrillic added only...
+ * draw_string()
+ * _GetStringWidth()
+ * implementation of class direct_draw
+ * ---- experimental smooth drawing functions
+ * draw_smooth_line()
+ * SmoothPoly()
+ * fl_filter_offscreen()
+ * fl_filter_widget()
+*/
+#include "_draw.cxx"
+/********************
+ * GdEllipse()
+ * GdArc()
+ * GdFillPoly()   
+ */ 
+#include "_arcpoly.cxx"
+/*********************
+ * XSetForeground()
+ * XFreeColors()
+ * XFlushColormap() - my function
+ * XAllocColor()
+ * XCreateColormap()
+ * XFreeColormap()
+ * XQueryColor()
+ * XQueryColors()
+*/
+#include "_colormap.cxx"
+/**********************
+ * XPutImage()
+ * XCreateBitmapFromData()
+ * XDestroyImage()
+ * XCreatePixmapCursor()
+ * XRecolorCursor()
+ * XCreateFontCursor()
+ * XDefineCursor()
+ * XFreeCursor()  
+ * fl_create_alphamask()
+ * SetColor* functions group
+*/
+#include "_image.cxx"
+
+/**********************/
+ 
+typedef struct __gc_item__{
+  GC                  gc;
+  struct __gc_item__  *next;
+}gc_item;
+
+static gc_item   list_head  = {0};
+static int       gc_cnt     =  0,
+                 win_cnt    =  0;
+
+const int max_regions = 32;
+
+static inline void
+push_gc(GC gc)
+{
+    gc_item *item   = (gc_item*)Xcalloc(sizeof(gc_item), 1);
+    item->next      = list_head.next;
+    item->gc        = gc;
+    list_head.next  = item;
+    gc_cnt++;
+}
+
+static inline int
+remove_gc(GC gc)
+{
+  if (gc_cnt > 0){ 
+    gc_item *citem = list_head.next;
+    gc_item *pitem = &list_head;
+    for (;citem;citem=citem->next){
+      if (citem->gc == gc){
+         pitem->next = citem->next;
+         Xfree(citem);
+         gc_cnt--;
+         return 0;             
+      }
+      pitem = citem;
+    }
+  }
+  return -1;
+}
+
+void 
+for_each_gc( int (cb)(GC gc,void* param),void* param)
+{
+  for (gc_item *citem = list_head.next; citem ; citem=citem->next) {
+    if (cb(citem->gc,param))
+      break;
+  }
+}
+
+int
+print_gc(GC gc,void*)
+{
+  int w,h;
+  get_size(gc, &w, &h);
+  D_INFO("width = %d\theight = %d\tpixel format %s\n",\
+      w, h, pixelformat_name(get_pixel_format(gc)));
+  return 0;
+}
+
+void
+print_gc_list()
+{
+  D_INFO("list of surfaces:\n");
+  for_each_gc(print_gc,0);
+}
+
+void
+free_gc_list()
+{
+  gc_item *pitem = &list_head;
+  for (gc_item *citem = pitem->next; citem; citem = pitem->next){
+    release(citem->gc->surface);
+    Xfree(citem->gc);
+    pitem->next = citem->next;
+    Xfree(citem);
+    gc_cnt--;
+  }
+}
+
+GC
+create_gc(const DFBSurfaceDescription* desc)
+{
+  if (fl_dfb){
+    GC gc = (GC)Xcalloc(sizeof(surface_context),1);
+    D_ASSERT( gc );
+    DFBCHECK(fl_dfb->CreateSurface(fl_dfb, desc, &gc->surface));
+    if (gc->surface){
+      push_gc(gc);
+      if(!(desc->flags & DSDESC_PREALLOCATED))
+        clear_gc(gc,0,0,0,255);
+      return gc;
+    }else
+      Xfree( gc );
+  }
+  return 0;
+}
+
+void
+release_gc(GC gc)
+{
+  if (remove_gc(gc) && fl_dfb)
+    D_WARN("no such surface %p", gc);
+  else
+  {
+    /*try*/
+    {
+      if (fl_dfb){
+        release(gc->surface);
+        Xfree(gc);
+      }
+    }
+    /*catch(...)
+    {
+      D_WARN("Oops!");
+    }*/
+  }
+  return;
+}
+
+GC
+create_mem_gc(int w, int h, int pf/*=-1*/)
+{
+  DFBSurfaceDescription desc;
+  desc.caps      = DSCAPS_SYSTEMONLY; 
+  desc.flags     =(DFBSurfaceDescriptionFlags)(DSDESC_CAPS|DSDESC_WIDTH|DSDESC_HEIGHT|DSDESC_PIXELFORMAT);
+  desc.height    = h;
+  desc.width     = w;
+    
+  if (pf == -1)
+    desc.pixelformat = (DFBSurfacePixelFormat)pixel_format();
+  else
+    desc.pixelformat = (DFBSurfacePixelFormat)pf;
+    
+  GC gc = create_gc(&desc);
+  return gc;
+}
+
+GC
+create_gc(IDirectFBWindow* window)
+{
+  GC gc = 0;
+  Fl_Window* w1 =  fl_find(window);
+  if (w1){
+     CreatedWindow* w2 = CreatedWindow::i(w1);
+     if (w2)  
+       gc = w2->gc;
+  }
+  if (!gc){
+    gc = (GC)Xcalloc(sizeof(surface_context),1);
+    DFBCHECK(window->GetSurface(window, &gc->surface));
+    DFBRegion *regions = (DFBRegion *)Xmalloc(sizeof(DFBRegion) * max_regions);
+    dfb_updates_init(&gc->updates, regions, max_regions);
+    D_DEBUG("gc was created!\n");
+  }else{
+      gc->surface->AddRef(gc->surface);
+  }
+  push_gc(gc);
+  return gc;
+}
+
+GC
+create_gc(GC parent_gc, const DFBRectangle *rect)
+{
+  GC gc = (GC)Xcalloc(sizeof(surface_context),1);
+  if (DFB_OK == parent_gc->surface->GetSubSurface(parent_gc->surface, rect, &gc->surface)){
+	push_gc(gc);
+  }
+  return gc;
+}
+
+GC
+create_gc(int caps, int flags, int pixelformat, int width, int height)
+{
+  DFBSurfaceDescription desc;
+  desc.caps         = (DFBSurfaceCapabilities)caps;
+  desc.flags        = (DFBSurfaceDescriptionFlags)flags;
+  desc.pixelformat  = (DFBSurfacePixelFormat)pixelformat;
+  desc.height       = height;
+  desc.width        = width;
+
+  return create_gc(&desc);
+}
+
+Pixmap
+create_pixmap(int w ,int h, int pf/* = -1*/)
+{
+  return (Pixmap)create_mem_gc(w,h,pf);
+}
+
+void
+release_window(IDirectFBWindow *window)
+{
+  win_cnt--;
+  release(window);
+}
+
+
+IDirectFBWindow* 
+create_window(const DFBWindowDescription* desc)
+{
+  if (display_layer){
+    win_cnt++;
+    IDirectFBWindow* ret_win = 0;
+    DFBResult err = display_layer->CreateWindow(display_layer, desc, &ret_win);
+    if (DFB_OK == err){
+      return ret_win;
+    }else{
+      D_WARN("Can't create the window ! %s", DirectFBErrorString(err));
+      return 0;
+    }
+  }else
+    D_WARN("Display layer is absent!\n");
+  return 0;
+}
+
+//FIXME in fact, I can't use GetWindow()
+//I receive an other interface instead gotten one by CreateWindow()
+IDirectFBWindow*
+get_window(DFBWindowID xid)
+{
+  if (display_layer){
+    IDirectFBWindow* ret_win;
+    if (DFB_OK == display_layer->GetWindow(display_layer,xid,&ret_win)){
+      return ret_win;
+    }
+  }
+  return 0;
+}
+
+Region
+XCreateRegion()
+{
+  Region r = (Region)Xmalloc(sizeof(DFBRegion));
+  r->x1=r->y1=1;
+  r->x2=r->y2=0;
+  return r;
+}
+ 
+int
+XDestroyRegion(Region r)
+{ 
+  Xfree(r);
+  return Success;
+}
+
+int
+XRectInRegion(Region r, int x, int y, int w, int h)
+{
+  if (dfb_region_intersects(r, DFB_REGION_VALS_FROM_RECTANGLE_VALS(x, y, w+1, h+1)))
+    return RectangleIn;
+
+  if (DFB_REGION_CONTAINS_POINT(r, x, y) ||\
+      DFB_REGION_CONTAINS_POINT(r, x + w , y) ||\
+      DFB_REGION_CONTAINS_POINT(r, x, y + h) ||\
+      DFB_REGION_CONTAINS_POINT(r, x + w , y + h))
+    return RectanglePart;
+      
+  return RectangleOut;  
+}
+
+Region 
+XRectangleRegion(int x, int y, int w, int h)
+{
+  Region r = XCreateRegion();
+  *r = DFB_REGION_INIT_FROM_RECTANGLE_VALS(x,y,w+1,h+1);
+  return r;
+}
+
+void
+XClipBox(Region r, XRectangle* rect)
+{
+    dfb_rectangle_from_region((DFBRectangle*)rect , r);
+    rect->w--;
+    rect->h--;
+}
+
+void 
+update_region(GC gc, Region r)
+{
+  int caps = get_caps(gc);
+  
+  if (!((caps & DSCAPS_DOUBLE) || (caps & DSCAPS_TRIPLE)))
+    return;
+  
+  if (!r){
+    static DFBRegion region;
+    int w,h;
+    get_size(gc, &w, &h);
+    region = DFB_REGION_INIT_FROM_RECTANGLE_VALS(0,0,w,h);
+    r = &region;
+  }
+  if (r->x2 < r->x1)
+      swap(r->x2, r->x1);
+  if (r->y2 < r->y1)
+        swap(r->y2, r->y1);
+  r->x2++; r->y2++;//FIXME
+  //D_INFO("update_region(%p,{%d,%d,%d,%d})\n",gc->surface,r->x1,r->y1,r->x2,r->y2);
+
+  if (!gc->updates.regions) {
+    DFBRegion *regions = (DFBRegion *)Xmalloc(sizeof(DFBRegion)*max_regions);
+    dfb_updates_init(&gc->updates, regions, max_regions);
+  }
+  dfb_updates_add(&gc->updates, r);
+}
+
+void
+update_region(GC gc,int x1,int y1,int x2,int y2)
+{
+	if (x1>x2){int tmp=x1;x1=x2;x2=tmp;}
+	if (y1>y2){int tmp=y1;y1=y2;y2=tmp;}
+	
+	DFBRegion reg = {x1,y1,x2,y2};	
+    
+	update_region(gc, &reg);
+}
+
+void 
+updates_reset(GC gc)
+{
+  if (gc) {
+    dfb_updates_reset(&gc->updates);
+    gc->updates.magic = 0;
+  } else
+    D_WARN("gc is NULL!");
+}
+
+void 
+remove_updates(GC gc)
+{
+  if (gc) {
+    if (gc->updates.regions) {
+        dfb_updates_reset(&gc->updates);
+        gc->updates.magic = 0;
+        Xfree(gc->updates.regions);
+        gc->updates.regions = 0;
+    }
+  }else
+    D_WARN("gc is NULL!");
+}
+
+void 
+flip_updates(GC gc)
+{
+  int total,bounding;
+  if (gc) {
+    DFBUpdates* updates = &gc->updates;
+    if (updates->num_regions){
+      dfb_updates_stat(updates, &total, &bounding);
+
+      if (bounding <= total)
+        fl_flip(gc, &updates->bounding);
+      else{
+        int j = 0;
+        for (j=0; j<updates->num_regions; j++)
+          fl_flip(gc, updates->regions+j);
+      }
+      if (updates->regions)
+        dfb_updates_reset(updates);
+    }
+  }else
+    D_WARN("gc is NULL!");
+}
+
+void
+XSetClipMask(Display* display, GC gc, Pixmap pixmap)
+{
+  if (pixmap == 0){
+    if (gc)
+      XSetRegion(display, gc, 0);
+  }
+  if (gc)
+    gc->clip_mask = (surface_context*)pixmap;
+}
+
+//set region for clip
+void 
+XSetRegion(Display* display, GC surface, Region r, int _set_clip)
+{
+  if (!surface)
+    return;
+
+  if (!r) {
+    static DFBRegion region;
+    int w,h;
+    get_size(surface, &w, &h);
+    region = DFB_REGION_INIT_FROM_RECTANGLE_VALS(0,0,w+1,h+1);
+    r = &region;
+  }
+  //DirectFB's function to clip the region
+  if (_set_clip)
+    set_clip(surface, r);
+}
+
+int
+XWindowEvent(Display* display, Window w, long event_mask, XEvent * ev)
+{
+    /* FLTK hack*/
+    if (event_mask == ExposureMask)
+        ev->type = NoExpose;
+
+    return 0;
+}
+
+int
+XIntersectRegion(Region r1, Region r2, Region newReg)
+{
+  *newReg = r1 ? *r1 : *r2;
+  return dfb_region_region_intersect(newReg, r2 ? r2 : r1);
+}
+
+int
+XSetClipOrigin(Display* display, GC gc, int clip_x_origin, int clip_y_origin){
+  D_ONCE("XSetClipOrigin() not implemented.");
+  return 1;
+}
+
+int
+XUnionRectWithRegion(XRectangle* rect, Region src_reg, Region dst_reg)
+{
+  static DFBRegion region;
+  dfb_region_from_rectangle(&region, rect);
+  region.x2++;region.y2++;
+  dfb_region_region_union(&region, src_reg);
+  *dst_reg = region;
+  return 1;
+}
+
+int
+XSubtractRegion(Region sra,Region srb,Region dr_return)
+{
+    D_ONCE("XSubtractRegion() not implemented.");
+    return 0;
+}
+
+int
+XParseGeometry(const char *parsestring, int *x_return, int 
+	*y_return, unsigned int *width_return, unsigned int *height_return)
+{
+	return 0;	
+}
+
+void
+XDestroyWindow(Display* display , dfbWindow xid)
+{
+  ungrab_pointer(xid);
+  DFBCHECK(xid->Destroy(xid));
+  release_window(xid);
+}
+
+int
+XIconifyWindow(Display*, Window xid, void*)
+{
+	Fl_Window* win = fl_find(xid);
+	CreatedWindow::i(win)->set_minimize();
+	return 0;
+}
+
+//extern int handle(const DFBWindowEvent& thisevent);
+int
+XMapWindow(Display*, Window xid)
+{
+#if 1 
+    D_ONCE("XMapWindow() not implemented.");
+#else
+    Fl_Window* win = fl_find(xid);
+    CreatedWindow* i = CreatedWindow::i(win);
+    if (i) {
+      if (!i->first_draw) { 
+        set_opacity(i->_xid, 255);
+      }
+      if (i->minimize()) {
+        i->delete_icon();
+      }
+      i->wait_for_expose = 0;
+      redraw();
+    }
+#endif
+    return Success;     
+}
+
+int
+XUnmapWindow(Display* d, Window xid)
+{
+#if 1 
+    D_ONCE("XUnmapWindow() not implemented.");
+#else
+    Fl_Window* win = fl_find(xid);
+    CreatedWindow* i = CreatedWindow::i(win);
+    if (i){ 
+      set_opacity(i->_xid, 0);
+      i->wait_for_expose = 1;
+    }
+#endif
+    return Success;
+}
+
+int
+XMapRaised(Display* d, Window xid)
+{
+#if 1 
+    D_ONCE("XMapRaised() not implemented.");
+#else
+    Fl_Window* win = fl_find(xid);
+    CreatedWindow* i = CreatedWindow::i(win);
+    if (i && i->minimize()){
+        i->delete_icon();
+        redraw();
+    }
+    raise_to_top(i->_xid); 
+    i->wait_for_expose = 0;
+#endif
+    return Success;
+}
+
+char*
+XGetDefault(Display* display, _Xconst char*	program, _Xconst char*)
+{
+  D_ONCE("XGetDefault not implemented."); 
+  return 0;
+}
+
+GC 
+XCreateGC(Display* display, Drawable d, unsigned long valuemask, void* values)
+{
+  D_ONCE("XCreateGC() not implemented."); 
+  return Success;
+}
+
+int 
+XBell(Display*, int)
+{
+  D_ONCE("XBell() not implemented."); 
+  return Success;
+}
+
+int
+XFreeFont( Display* d, XFont font)
+{
+	if (font)
+    font->Release(font);
+  return 0;    
+}
+
+
+int
+flip_gc(GC gc,void*)
+{
+  flip_updates(gc);
+  return Success;
+}
+
+int
+XFlush(Display* display)
+{
+  for_each_gc(flip_gc, 0);
+
+#if USE_COLORMAP
+  // DirectFB's palette function SetEntries() sometimes is very slooow
+  // I upload current colormap to the palette when it's needed
+  if (have_lut())
+    XFlushColormap(fl_display, fl_colormap);
+#endif
+#ifdef DEBUG
+  extern ulong flip_size_sum;
+  if (flip_size_sum){
+    _TRACE("flip pixels %lu\n", flip_size_sum);
+    flip_size_sum=0;
+  }
+#endif
+  return Success;
+}
+
+/****************************************************************************
+ * Key mapping functions
+ */
+ 
+extern DFBInputDeviceID keyboard_id;
+
+static const struct {unsigned short id, fltk; const char* s;} idtab[] = {
+	{DIKI_UNKNOWN,0,""},
+	{DIKI_A,			'a',		"A"},
+    {DIKI_B,			'b',		"B"},
+    {DIKI_C,			'c',		"C"},
+    {DIKI_D,			'd',		"D"},
+    {DIKI_E,			'e',		"E"},
+    {DIKI_F,			'f',		"F"},
+    {DIKI_G,			'g',		"G"},
+    {DIKI_H,			'h',		"H"},
+    {DIKI_I,			'i',		"I"},
+    {DIKI_J,			'j',		"A"},
+    {DIKI_K,			'k',		"A"},
+    {DIKI_L,			'l',		"A"},
+    {DIKI_M,			'm',		"A"},
+    {DIKI_N,			'n',		"A"},
+    {DIKI_O,			'o',		"A"},
+    {DIKI_P,			'p',		"A"},
+    {DIKI_Q,			'q',		"A"},
+    {DIKI_R,			'r',		"A"},
+    {DIKI_S,			's',		"A"},
+    {DIKI_T,			't',		"A"},
+    {DIKI_U,			'u',		"A"},
+    {DIKI_V,			'v',		"A"},
+    {DIKI_W,			'w',		"A"},
+    {DIKI_X,			'x',		"A"},
+    {DIKI_Y,			'y',		"A"},
+    {DIKI_Z,			'z',		"A"},
+    {DIKI_0,			'0',		"A"},
+    {DIKI_1,			'1',		"A"},
+    {DIKI_2,			'2',		"A"},
+    {DIKI_3,			'3',		"A"},
+    {DIKI_4,			'4',		"A"},
+    {DIKI_5,			'5',		"A"},
+    {DIKI_6,			'6',		"A"},
+    {DIKI_7,			'7',		"A"},
+    {DIKI_8,			'8',		"A"},
+    {DIKI_9,			'9',		"A"},
+	{DIKI_F1,			FL_F+1,		"FL_F+1"},
+    {DIKI_F2,			FL_F+2,		"FL_F+2"},
+    {DIKI_F3,			FL_F+3,		"FL_F+3"},
+    {DIKI_F4,			FL_F+4,		"FL_F+4"},
+    {DIKI_F5,			FL_F+5,		"FL_F+5"},
+    {DIKI_F6,			FL_F+6,		"FL_F+6"},
+    {DIKI_F7,			FL_F+7,		"FL_F+7"},
+    {DIKI_F8,			FL_F+8,		"FL_F+8"},
+    {DIKI_F9,			FL_F+9,		"FL_F+9"},
+    {DIKI_F10,			FL_F+10,	"FL_F+10"},
+    {DIKI_F11,			FL_F+11,	"FL_F+11"},
+    {DIKI_F12,			FL_F+12,	"FL_F+12"},
+    {DIKI_SHIFT_L,		FL_Shift_L,	"FL_Shift_L"},
+    {DIKI_SHIFT_R,		FL_Shift_R,	"FL_Shift_R"},
+    {DIKI_CONTROL_L,	FL_Control_L,"FL_Control_L"},
+    {DIKI_CONTROL_R,	FL_Control_R,"FL_Control_R"},
+    {DIKI_ALT_L,		FL_Alt_L,	"FL_Alt_L"},
+	{DIKI_ALT_R,		FL_Alt_R,	"FL_Alt_R"},
+    //{DIKI_ALTGR,		FL_Alt_R,	"FL_Alt_Gr"},
+    {DIKI_META_L,		FL_Meta_L,	"FL_Meta_L"},
+    {DIKI_META_R,		FL_Meta_R,	"FL_Meta_R"},
+    {DIKI_SUPER_L,		0,			"0"},
+    {DIKI_SUPER_R,		FL_Menu,	"0"},
+    {DIKI_HYPER_L,		0,			"0"},
+    {DIKI_HYPER_R,		0,			"0"},
+    {DIKI_CAPS_LOCK,	FL_Caps_Lock,"FL_Caps_Lock"},
+    {DIKI_NUM_LOCK,		FL_Num_Lock,"FL_Num_Lock"},
+    {DIKI_SCROLL_LOCK,	FL_Scroll_Lock,"FL_Scroll_Lock"},
+    {DIKI_ESCAPE,		FL_Escape,	"FL_Escape"},
+    {DIKI_LEFT,			FL_Left,	"FL_Left"},
+    {DIKI_RIGHT,		FL_Right,	"FL_Right"},
+    {DIKI_UP,			FL_Up,		"FL_Up"},
+    {DIKI_DOWN,			FL_Down,	"FL_Down"},
+    {DIKI_TAB,			FL_Tab,		"FL_Tab"},
+    {DIKI_ENTER,		FL_Enter,	"FL_Enter"},
+    {DIKI_SPACE,		0x20,		" "},
+    {DIKI_BACKSPACE,	FL_BackSpace,"FL_BackSpace"},
+    {DIKI_INSERT,		FL_Insert,	"FL_Insert"},
+    {DIKI_DELETE,		FL_Delete,	"FL_Delete"},
+    {DIKI_HOME,			FL_Home,	"FL_Home"},
+    {DIKI_END,			FL_End,		"FL_End"},
+    {DIKI_PAGE_UP,		FL_Page_Up,	"FL_Page_Up"},
+    {DIKI_PAGE_DOWN,	FL_Page_Down,"FL_Page_Down"},
+    {DIKI_PRINT,		FL_Print,	"FL_Print"},
+    {DIKI_PAUSE,		FL_Pause,	"FL_Pause"},
+    {DIKI_QUOTE_LEFT,   '{',		"{"},
+    {DIKI_MINUS_SIGN,   '-',		"-"},
+    {DIKI_EQUALS_SIGN,  '=',		"="},
+    {DIKI_BRACKET_LEFT, '[',		"["},
+    {DIKI_BRACKET_RIGHT,']',		"]"},
+    {DIKI_BACKSLASH,    '|',		"|"},
+    {DIKI_SEMICOLON,    ';',		";"},
+    {DIKI_QUOTE_RIGHT,  '\'',		"\'"},
+    {DIKI_COMMA,        ',',		","},
+    {DIKI_PERIOD,       '.',		"."},
+    {DIKI_SLASH,        '/',		"/"},
+    {DIKI_LESS_SIGN,    '<',		"<"},
+    {DIKI_KP_DIV,		FL_KP+'/',	""},
+    {DIKI_KP_MULT,		FL_KP+'*',	""},
+    {DIKI_KP_MINUS,		FL_KP+'-',	""},
+    {DIKI_KP_PLUS,		FL_KP+'+',	""},
+    {DIKI_KP_ENTER,		FL_KP_Enter,""},
+    {DIKI_KP_SPACE,		FL_KP+' ',	""},
+    {DIKI_KP_TAB,		FL_KP+'\t',	""},
+//  {DIKI_KP_F1,		FL_KP+'/',	""},
+//  {DIKI_KP_F2,		FL_KP+'/',	""},
+//  {DIKI_KP_F3,		FL_KP+'/',	""},
+//  {DIKI_KP_F4,		FL_KP+'/',	""},
+    {DIKI_KP_EQUAL,		FL_KP+'=',	""},
+    {DIKI_KP_SEPARATOR,	FL_KP+'|',	""},
+    {DIKI_KP_DECIMAL,	FL_KP+'.',	"Fl_Delete"},
+    {DIKI_KP_0,			FL_KP+'0',	"FL_Insert"},
+    {DIKI_KP_1,			FL_KP+'1',	"FL_End"},
+    {DIKI_KP_2,			FL_KP+'2',	"FL_Down"},
+    {DIKI_KP_3,			FL_KP+'3',	"FL_Page_Down"},
+    {DIKI_KP_4,			FL_KP+'4',	"FL_Left"},
+    {DIKI_KP_5,			FL_KP+'5',	"FL_KP+5"},
+    {DIKI_KP_6,			FL_KP+'6',	"FL_Right"},
+    {DIKI_KP_7,			FL_KP+'7',	"FL_Home"},
+    {DIKI_KP_8,			FL_KP+'8',	"FL_Up"},
+    {DIKI_KP_9,			FL_KP+'9',	"FL_Page_Up"},    {0,0}
+};
+
+int
+id2fltk(int id)
+{
+	for (int i = 0; idtab[i].id; i++)
+		if (idtab[i].id == id){
+			return idtab[i].fltk;
+		}
+	return 0;
+} 
+
+int
+fltk2id(int sym)
+{
+	for (int i = 0; idtab[i].id; i++)
+		if (idtab[i].fltk == sym){
+			return idtab[i].id;
+		}
+	return 0;
+} 
+
+int
+XKeysymToKeycode(Display* d, KeySym ks)
+{
+	DFBInputDeviceKeymapEntry entry;
+	IDirectFBInputDevice* kbd = 0;
+	int code = 0, id = fltk2id(ks);
+	fl_dfb->GetInputDevice(fl_dfb, keyboard_id, &kbd);
+	for (int i = 0; i < 255; i++) {
+		kbd->GetKeymapEntry(kbd, i, &entry);
+		if (id != 0){
+			if (entry.identifier==id) {
+				code = entry.code;
+				break;
+			}
+		} else {
+			for (int j = 0; j <= DIKSI_LAST; j++) {
+				if (entry.symbols[j] == (int)ks) {
+					code = entry.code;
+					break;
+				}
+			}
+		}
+	}
+	release(kbd);
+	return code; 
+}
+
+char* 
+XKeysymToString(KeySym keysym)
+{
+    D_ONCE("XKeysymToString not implemented."); 
+    return Success;
+}
+
+int
+XQueryKeymap(Display* d, char s[32])
+{
+    D_ONCE("XQueryKeymap not implemented."); 
+    return Success;
+} 
+
+
+#endif
diff -Nwrup -x.git fltk-1.1.9/test/color_chooser.cxx FLTK_1.x-DirectFB/test/color_chooser.cxx
--- fltk-1.1.9/test/color_chooser.cxx	2006-10-10 23:12:15.000000000 -0400
+++ FLTK_1.x-DirectFB/test/color_chooser.cxx	2009-11-28 15:48:06.013175545 -0500
@@ -37,10 +37,23 @@
 
 #include <stdlib.h>
 #include <stdio.h>
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
 #include "list_visuals.cxx"
 #endif
 
+void timeout_cb(void *) {
+    static int old_x=0,timeout=0; 
+    if( Fl::event_x() != old_x ){
+        old_x = Fl::event_x();
+        timeout = 0;
+    }else{
+        if( timeout++ == 5 )
+            Fl::fatal("timeout");
+    }
+    Fl::repeat_timeout(1.0, timeout_cb);   
+}
+
+
 int width = 75;
 int height = 75;
 uchar *image;
@@ -117,7 +130,7 @@ int main(int argc, char ** argv) {
 	   " - : default visual\n"
 	   " r : call Fl::visual(FL_RGB)\n"
 	   " c : call Fl::own_colormap()\n",argv[0]);
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
     printf(" # : use this visual with an empty colormap:\n");
     list_visuals();
 #endif
@@ -129,7 +142,7 @@ int main(int argc, char ** argv) {
   } else if (argv[i][0] == 'c') {
     Fl::own_colormap();
   } else if (argv[i][0] != '-') {
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
     int visid = atoi(argv[i]);
     fl_open_display();
     XVisualInfo templt; int num;
@@ -144,6 +157,7 @@ int main(int argc, char ** argv) {
 #endif
   }
   window.show(argc,argv);
+//  Fl::add_timeout(1.0, timeout_cb);   
   return Fl::run();
 }
 
diff -Nwrup -x.git fltk-1.1.9/test/image.cxx FLTK_1.x-DirectFB/test/image.cxx
--- fltk-1.1.9/test/image.cxx	2006-10-10 23:12:15.000000000 -0400
+++ FLTK_1.x-DirectFB/test/image.cxx	2009-11-28 15:48:06.019154352 -0500
@@ -37,6 +37,18 @@
 #include <stdlib.h>
 #include <math.h>
 
+void timeout_cb(void *) {
+    static int old_x=0,timeout=0; 
+    if( Fl::event_x() != old_x ){
+        old_x = Fl::event_x();
+        timeout = 0;
+    }else{
+        if( timeout++ == 5 )
+            Fl::fatal("timeout");
+    }
+    Fl::repeat_timeout(1.0, timeout_cb);   
+}
+
 int width = 100;
 int height = 100;
 uchar *image;
@@ -82,7 +94,7 @@ void button_cb(Fl_Widget *,void *) {
 }
 
 #include <FL/x.H>
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
 #include "list_visuals.cxx"
 #endif
 
@@ -98,7 +110,7 @@ int arg(int argc, char **argv, int &i) {
 }
 
 int main(int argc, char **argv) {
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB)
   int i = 1;
 
   Fl::args(argc,argv,i,arg);
@@ -123,7 +135,7 @@ int main(int argc, char **argv) {
 
   Fl_Window window(400,400); ::w = &window;
   window.color(FL_WHITE);
-  Fl_Button b(140,160,120,120,"Image w/Alpha"); ::b = &b;
+  Fl_Button b(140,140,140,170,"Image w/Alpha"); ::b = &b;
 
   Fl_RGB_Image *rgb;
   Fl_Image *dergb;
@@ -153,6 +165,9 @@ int main(int argc, char **argv) {
   window.resizable(window);
   window.end();
   window.show(argc, argv);
+//  window.size(640,480);
+//  window.position(0,0);
+//  Fl::add_timeout(1.0, timeout_cb);  
   return Fl::run();
 }
 
diff -Nwrup -x.git fltk-1.1.9/test/list_visuals.cxx FLTK_1.x-DirectFB/test/list_visuals.cxx
--- fltk-1.1.9/test/list_visuals.cxx	2006-10-10 23:12:15.000000000 -0400
+++ FLTK_1.x-DirectFB/test/list_visuals.cxx	2009-11-28 15:48:06.020153293 -0500
@@ -33,7 +33,8 @@
 //     http://www.fltk.org/str.php
 //
 
-#if defined(WIN32) || defined(__APPLE__)
+#include <config.h>
+#if defined(WIN32) || defined(__APPLE__) || defined(DIRECTFB)
 #include <FL/Fl.H>
 #include <FL/fl_message.H>
 
diff -Nwrup -x.git fltk-1.1.9/test/sudoku.cxx FLTK_1.x-DirectFB/test/sudoku.cxx
--- fltk-1.1.9/test/sudoku.cxx	2008-02-26 15:37:01.000000000 -0500
+++ FLTK_1.x-DirectFB/test/sudoku.cxx	2009-11-28 15:48:06.028155034 -0500
@@ -434,7 +434,8 @@ void SudokuSound::play(char note) {
 
     Sleep(50);
   } else Beep(frequencies[note - 'A'], 50);
-
+#elif defined(DIRECTFB)
+//do nothing.... yet
 #else
 #  ifdef HAVE_ALSA_ASOUNDLIB_H
   if (handle) {
diff -Nwrup -x.git fltk-1.1.9/test/tiled_image.cxx FLTK_1.x-DirectFB/test/tiled_image.cxx
--- fltk-1.1.9/test/tiled_image.cxx	2006-10-10 23:12:15.000000000 -0400
+++ FLTK_1.x-DirectFB/test/tiled_image.cxx	2009-11-28 15:48:06.029154070 -0500
@@ -44,7 +44,7 @@ void button_cb(Fl_Widget *,void *) {
 }
 
 #include <FL/x.H>
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB) 
 #include "list_visuals.cxx"
 #endif
 
@@ -60,7 +60,7 @@ int arg(int argc, char **argv, int &i) {
 }
 
 int main(int argc, char **argv) {
-#if !defined(WIN32) && !defined(__APPLE__)
+#if !defined(WIN32) && !defined(__APPLE__) && !defined(DIRECTFB) 
   int i = 1;
 
   Fl::args(argc,argv,i,arg);
