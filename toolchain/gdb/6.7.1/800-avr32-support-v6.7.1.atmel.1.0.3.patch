diff -Nrup gdb-6.7.1/bfd/archures.c gdb-6.7.1-atmel/bfd/archures.c
--- gdb-6.7.1/bfd/archures.c	2007-07-03 16:26:39.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/archures.c	2008-04-03 15:00:37.000000000 +0200
@@ -345,7 +345,12 @@ DESCRIPTION
 .#define bfd_mach_avr3		3
 .#define bfd_mach_avr4		4
 .#define bfd_mach_avr5		5
-.#define bfd_mach_avr6		6
+.#define bfd_mach_avr6      6
+.  bfd_arch_avr32,     {* Atmel AVR32 *}
+.#define bfd_mach_avr32_ap	7000
+.#define bfd_mach_avr32_uc      3000
+.#define bfd_mach_avr32_ucr1    3001
+.#define bfd_mach_avr32_ucr2    3002
 .  bfd_arch_bfin,        {* ADI Blackfin *}
 .#define bfd_mach_bfin          1
 .  bfd_arch_cr16,       {* National Semiconductor CompactRISC (ie CR16). *}
@@ -438,6 +443,7 @@ extern const bfd_arch_info_type bfd_alph
 extern const bfd_arch_info_type bfd_arc_arch;
 extern const bfd_arch_info_type bfd_arm_arch;
 extern const bfd_arch_info_type bfd_avr_arch;
+extern const bfd_arch_info_type bfd_avr32_arch;
 extern const bfd_arch_info_type bfd_bfin_arch;
 extern const bfd_arch_info_type bfd_cr16_arch;
 extern const bfd_arch_info_type bfd_cr16c_arch;
@@ -509,6 +515,7 @@ static const bfd_arch_info_type * const 
     &bfd_arc_arch,
     &bfd_arm_arch,
     &bfd_avr_arch,
+    &bfd_avr32_arch,
     &bfd_bfin_arch,
     &bfd_cr16_arch,
     &bfd_cr16c_arch,
diff -Nrup gdb-6.7.1/bfd/bfd-in2.h gdb-6.7.1-atmel/bfd/bfd-in2.h
--- gdb-6.7.1/bfd/bfd-in2.h	2007-10-25 23:38:23.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/bfd-in2.h	2008-04-03 15:00:37.000000000 +0200
@@ -2016,6 +2016,8 @@ enum bfd_architecture
 #define bfd_mach_avr4          4
 #define bfd_mach_avr5          5
 #define bfd_mach_avr6          6
+  bfd_arch_avr32,     /* Atmel AVR32 */
+#define bfd_mach_at32ap7000    7000
   bfd_arch_bfin,        /* ADI Blackfin */
 #define bfd_mach_bfin          1
   bfd_arch_cr16,       /* National Semiconductor CompactRISC (ie CR16). */
@@ -3757,6 +3759,87 @@ instructions  */
 instructions  */
   BFD_RELOC_AVR_6_ADIW,
 
+/* Difference between two labels: L2 - L1. The value of L1 is encoded
+as sym + addend, while the initial difference after assembly is
+inserted into the object file by the assembler.  */
+  BFD_RELOC_AVR32_DIFF32,
+  BFD_RELOC_AVR32_DIFF16,
+  BFD_RELOC_AVR32_DIFF8,
+
+/* Reference to a symbol through the Global Offset Table. The linker
+will allocate an entry for symbol in the GOT and insert the offset
+of this entry as the relocation value.  */
+  BFD_RELOC_AVR32_GOT32,
+  BFD_RELOC_AVR32_GOT16,
+  BFD_RELOC_AVR32_GOT8,
+
+/* Normal (non-pc-relative) code relocations. Alignment and signedness
+is indicated by the suffixes. S means signed, U means unsigned. W
+means word-aligned, H means halfword-aligned, neither means
+byte-aligned (no alignment.) SUB5 is the same relocation as 16S.  */
+  BFD_RELOC_AVR32_21S,
+  BFD_RELOC_AVR32_16U,
+  BFD_RELOC_AVR32_16S,
+  BFD_RELOC_AVR32_SUB5,
+  BFD_RELOC_AVR32_8S_EXT,
+  BFD_RELOC_AVR32_8S,
+
+/* PC-relative relocations are signed if neither 'U' nor 'S' is
+specified. However, we explicitly tack on a 'B' to indicate no
+alignment, to avoid confusion with data relocs. All of these resolve
+to sym + addend - offset, except the one with 'N' (negated) suffix.
+This particular one resolves to offset - sym - addend.  */
+  BFD_RELOC_AVR32_22H_PCREL,
+  BFD_RELOC_AVR32_18W_PCREL,
+  BFD_RELOC_AVR32_16B_PCREL,
+  BFD_RELOC_AVR32_16N_PCREL,
+  BFD_RELOC_AVR32_14UW_PCREL,
+  BFD_RELOC_AVR32_11H_PCREL,
+  BFD_RELOC_AVR32_10UW_PCREL,
+  BFD_RELOC_AVR32_9H_PCREL,
+  BFD_RELOC_AVR32_9UW_PCREL,
+
+/* Subtract the link-time address of the GOT from (symbol + addend)
+and insert the result.  */
+  BFD_RELOC_AVR32_GOTPC,
+
+/* Reference to a symbol through the GOT. The linker will allocate an
+entry for symbol in the GOT and insert the offset of this entry as
+the relocation value. addend must be zero. As usual, 'S' means
+signed, 'W' means word-aligned, etc.  */
+  BFD_RELOC_AVR32_GOTCALL,
+  BFD_RELOC_AVR32_LDA_GOT,
+  BFD_RELOC_AVR32_GOT21S,
+  BFD_RELOC_AVR32_GOT18SW,
+  BFD_RELOC_AVR32_GOT16S,
+
+/* 32-bit constant pool entry. I don't think 8- and 16-bit entries make
+a whole lot of sense.  */
+  BFD_RELOC_AVR32_32_CPENT,
+
+/* Constant pool references. Some of these relocations are signed,
+others are unsigned. It doesn't really matter, since the constant
+pool always comes after the code that references it.  */
+  BFD_RELOC_AVR32_CPCALL,
+  BFD_RELOC_AVR32_16_CP,
+  BFD_RELOC_AVR32_9W_CP,
+
+/* sym must be the absolute symbol. The addend specifies the alignment
+order, e.g. if addend is 2, the linker must add padding so that the
+next address is aligned to a 4-byte boundary.  */
+  BFD_RELOC_AVR32_ALIGN,
+
+/* Code relocations that will never make it to the output file.  */
+  BFD_RELOC_AVR32_14UW,
+  BFD_RELOC_AVR32_10UW,
+  BFD_RELOC_AVR32_10SW,
+  BFD_RELOC_AVR32_STHH_W,
+  BFD_RELOC_AVR32_7UW,
+  BFD_RELOC_AVR32_6S,
+  BFD_RELOC_AVR32_6UW,
+  BFD_RELOC_AVR32_4UH,
+  BFD_RELOC_AVR32_3U,
+
 /* Direct 12 bit.  */
   BFD_RELOC_390_12,
 
diff -Nrup gdb-6.7.1/bfd/config.bfd gdb-6.7.1-atmel/bfd/config.bfd
--- gdb-6.7.1/bfd/config.bfd	2007-08-28 13:02:55.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/config.bfd	2008-04-03 15:00:38.000000000 +0200
@@ -335,6 +335,10 @@ case "${targ}" in
     targ_underscore=yes
     ;;
 
+  avr32-*-*)
+    targ_defvec=bfd_elf32_avr32_vec
+    ;;
+
   c30-*-*aout* | tic30-*-*aout*)
     targ_defvec=tic30_aout_vec
     ;;
diff -Nrup gdb-6.7.1/bfd/configure.in gdb-6.7.1-atmel/bfd/configure.in
--- gdb-6.7.1/bfd/configure.in	2007-08-28 13:02:55.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/configure.in	2008-04-03 15:00:38.000000000 +0200
@@ -619,6 +619,7 @@ do
     bfd_efi_app_ia64_vec)	tb="$tb efi-app-ia64.lo pepigen.lo cofflink.lo"; target_size=64 ;;
     bfd_elf32_am33lin_vec)	tb="$tb elf32-am33lin.lo elf32.lo $elf" ;;
     bfd_elf32_avr_vec)		tb="$tb elf32-avr.lo elf32.lo $elf" ;;
+    bfd_elf32_avr32_vec)	tb="$tb elf32-avr32.lo elf32.lo $elf" ;;
     bfd_elf32_bfin_vec)		tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_bfinfdpic_vec)	tb="$tb elf32-bfin.lo elf32.lo $elf" ;;
     bfd_elf32_big_generic_vec) 	tb="$tb elf32-gen.lo elf32.lo $elf" ;;
diff -Nrup gdb-6.7.1/bfd/cpu-avr32.c gdb-6.7.1-atmel/bfd/cpu-avr32.c
--- gdb-6.7.1/bfd/cpu-avr32.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/bfd/cpu-avr32.c	2008-04-03 15:00:38.000000000 +0200
@@ -0,0 +1,52 @@
+/* BFD library support routines for AVR32.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "libbfd.h"
+
+#define N(machine, print, default, next)            \
+  {                             \
+    32,                 /* 32 bits in a word */     \
+    32,                 /* 32 bits in an address */ \
+    8,                  /* 8 bits in a byte */      \
+    bfd_arch_avr32,     /* architecture */      \
+    machine,            /* machine */           \
+    "avr32",            /* arch name */         \
+    print,              /* printable name */        \
+    1,                  /* section align power */   \
+    default,            /* the default machine? */  \
+    bfd_default_compatible,                 \
+    bfd_default_scan,                       \
+    next,                           \
+  }
+
+static const bfd_arch_info_type cpu_info[] =
+{
+  N(bfd_mach_avr32_ap, "avr32:ap", FALSE, &cpu_info[1]),
+  N(bfd_mach_avr32_uc, "avr32:uc", FALSE, &cpu_info[2]),
+  N(bfd_mach_avr32_ucr1, "avr32:ucr1", FALSE, &cpu_info[3]),
+  N(bfd_mach_avr32_ucr2, "avr32:ucr2", FALSE, NULL),
+};
+
+const bfd_arch_info_type bfd_avr32_arch =
+  N(bfd_mach_avr32_ap, "avr32", TRUE, &cpu_info[0]);
+
diff -Nrup gdb-6.7.1/bfd/doc/Makefile.in gdb-6.7.1-atmel/bfd/doc/Makefile.in
--- gdb-6.7.1/bfd/doc/Makefile.in	2007-07-02 09:12:49.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/doc/Makefile.in	2008-04-03 15:01:24.000000000 +0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -13,15 +13,11 @@
 # PARTICULAR PURPOSE.
 
 @SET_MAKE@
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = ..
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -81,16 +77,22 @@ TEXI2PDF = $(TEXI2DVI) --pdf --batch
 MAKEINFOHTML = $(MAKEINFO) --html
 AM_MAKEINFOHTMLFLAGS = $(AM_MAKEINFOFLAGS)
 DVIPS = dvips
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = `echo $$p | sed -e 's|^.*/||'`;
 ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AR = @AR@
 AUTOCONF = @AUTOCONF@
 AUTOHEADER = @AUTOHEADER@
 AUTOMAKE = @AUTOMAKE@
 AWK = @AWK@
+BFD_HOSTPTR_T = @BFD_HOSTPTR_T@
 BFD_HOST_64BIT_LONG = @BFD_HOST_64BIT_LONG@
+BFD_HOST_64BIT_LONG_LONG = @BFD_HOST_64BIT_LONG_LONG@
 BFD_HOST_64_BIT = @BFD_HOST_64_BIT@
 BFD_HOST_64_BIT_DEFINED = @BFD_HOST_64_BIT_DEFINED@
 BFD_HOST_LONG_LONG = @BFD_HOST_LONG_LONG@
@@ -119,15 +121,12 @@ EXEEXT = @EXEEXT@
 EXEEXT_FOR_BUILD = @EXEEXT_FOR_BUILD@
 FGREP = @FGREP@
 GENCAT = @GENCAT@
-GENINSRC_NEVER_FALSE = @GENINSRC_NEVER_FALSE@
-GENINSRC_NEVER_TRUE = @GENINSRC_NEVER_TRUE@
 GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 HDEFINES = @HDEFINES@
 INCINTL = @INCINTL@
+INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
-INSTALL_LIBBFD_FALSE = @INSTALL_LIBBFD_FALSE@
-INSTALL_LIBBFD_TRUE = @INSTALL_LIBBFD_TRUE@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
@@ -142,9 +141,8 @@ LIBTOOL = @LIBTOOL@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
 MAINT = @MAINT@
-MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
-MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
 MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
 MKINSTALLDIRS = @MKINSTALLDIRS@
 MSGFMT = @MSGFMT@
 MSGMERGE = @MSGMERGE@
@@ -174,14 +172,13 @@ WARN_CFLAGS = @WARN_CFLAGS@
 WIN32LDFLAGS = @WIN32LDFLAGS@
 WIN32LIBADD = @WIN32LIBADD@
 XGETTEXT = @XGETTEXT@
-ac_ct_AR = @ac_ct_AR@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-ac_ct_RANLIB = @ac_ct_RANLIB@
-ac_ct_STRIP = @ac_ct_STRIP@
 all_backends = @all_backends@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -201,9 +198,11 @@ build_alias = @build_alias@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
+builddir = @builddir@
 datadir = @datadir@
 datarootdir = @datarootdir@
 docdir = @docdir@
+dvidir = @dvidir@
 exec_prefix = @exec_prefix@
 host = @host@
 host_alias = @host_alias@
@@ -217,15 +216,19 @@ infodir = @infodir@
 install_sh = @install_sh@
 libdir = @libdir@
 libexecdir = @libexecdir@
+localedir = @localedir@
 localstatedir = @localstatedir@
 lt_ECHO = @lt_ECHO@
 mandir = @mandir@
 mkdir_p = @mkdir_p@
 oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
 prefix = @prefix@
 program_transform_name = @program_transform_name@
+psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
@@ -234,6 +237,8 @@ target_noncanonical = @target_noncanonic
 target_os = @target_os@
 target_vendor = @target_vendor@
 tdefaults = @tdefaults@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
 wordsize = @wordsize@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 DOCFILES = aoutx.texi  archive.texi archures.texi \
@@ -354,9 +359,9 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --cygnus  doc/Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  doc/Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --cygnus  doc/Makefile
+	  $(AUTOMAKE) --foreign  doc/Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
@@ -381,9 +386,6 @@ mostlyclean-libtool:
 clean-libtool:
 	-rm -rf .libs _libs
 
-distclean-libtool:
-	-rm -f libtool
-
 bfd.info: bfd.texinfo $(bfd_TEXINFOS)
 	restore=: && backupdir="$(am__leading_dot)am$$$$" && \
 	rm -rf $$backupdir && mkdir $$backupdir && \
@@ -429,9 +431,26 @@ bfd.html: bfd.texinfo $(bfd_TEXINFOS) 
 	TEXINPUTS="$(am__TEXINFO_TEX_DIR)$(PATH_SEPARATOR)$$TEXINPUTS" \
 	$(DVIPS) -o $@ $<
 
+uninstall-dvi-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(DVIS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(dvidir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(dvidir)/$$f"; \
+	done
+
+uninstall-html-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(HTMLS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -rf '$(DESTDIR)$(htmldir)/$$f'"; \
+	  rm -rf "$(DESTDIR)$(htmldir)/$$f"; \
+	done
+
 uninstall-info-am:
 	@$(PRE_UNINSTALL)
-	@if (install-info --version && \
+	@if test -d '$(DESTDIR)$(infodir)' && \
+	    (install-info --version && \
 	     install-info --version 2>&1 | sed 1q | grep -i -v debian) >/dev/null 2>&1; then \
 	  list='$(INFO_DEPS)'; \
 	  for file in $$list; do \
@@ -445,12 +464,28 @@ uninstall-info-am:
 	for file in $$list; do \
 	  relfile=`echo "$$file" | sed 's|^.*/||'`; \
 	  relfile_i=`echo "$$relfile" | sed 's|\.info$$||;s|$$|.i|'`; \
-	  (if cd "$(DESTDIR)$(infodir)"; then \
+	  (if test -d "$(DESTDIR)$(infodir)" && cd "$(DESTDIR)$(infodir)"; then \
 	     echo " cd '$(DESTDIR)$(infodir)' && rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]"; \
 	     rm -f $$relfile $$relfile-[0-9] $$relfile-[0-9][0-9] $$relfile_i[0-9] $$relfile_i[0-9][0-9]; \
 	   else :; fi); \
 	done
 
+uninstall-pdf-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(PDFS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(pdfdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(pdfdir)/$$f"; \
+	done
+
+uninstall-ps-am:
+	@$(NORMAL_UNINSTALL)
+	@list='$(PSS)'; for p in $$list; do \
+	  f=$(am__strip_dir) \
+	  echo " rm -f '$(DESTDIR)$(psdir)/$$f'"; \
+	  rm -f "$(DESTDIR)$(psdir)/$$f"; \
+	done
+
 dist-info: $(INFO_DEPS)
 	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
 	list='$(INFO_DEPS)'; \
@@ -459,10 +494,13 @@ dist-info: $(INFO_DEPS)
 	    $(srcdir)/*) base=`echo "$$base" | sed "s|^$$srcdirstrip/||"`;; \
 	  esac; \
 	  if test -f $$base; then d=.; else d=$(srcdir); fi; \
-	  for file in $$d/$$base*; do \
-	    relfile=`expr "$$file" : "$$d/\(.*\)"`; \
-	    test -f $(distdir)/$$relfile || \
-	      cp -p $$file $(distdir)/$$relfile; \
+	  base_i=`echo "$$base" | sed 's|\.info$$||;s|$$|.i|'`; \
+	  for file in $$d/$$base $$d/$$base-[0-9] $$d/$$base-[0-9][0-9] $$d/$$base_i[0-9] $$d/$$base_i[0-9][0-9]; do \
+	    if test -f $$file; then \
+	      relfile=`expr "$$file" : "$$d/\(.*\)"`; \
+	      test -f $(distdir)/$$relfile || \
+		cp -p $$file $(distdir)/$$relfile; \
+	    else :; fi; \
 	  done; \
 	done
 
@@ -522,7 +560,7 @@ clean-am: clean-generic clean-libtool mo
 
 distclean: distclean-am
 	-rm -f Makefile
-distclean-am: clean-am distclean-generic distclean-libtool
+distclean-am: clean-am distclean-generic
 
 dvi: dvi-am
 
@@ -538,13 +576,24 @@ info-am: $(INFO_DEPS)
 
 install-data-am:
 
+install-dvi: install-dvi-am
+
+install-dvi-am: $(DVIS)
+	@$(NORMAL_INSTALL)
+	test -z "$(dvidir)" || $(MKDIR_P) "$(DESTDIR)$(dvidir)"
+	@list='$(DVIS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(dvidir)/$$f'"; \
+	  $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(dvidir)/$$f"; \
+	done
 install-exec-am:
 
 install-info: install-info-am
 
 install-info-am: $(INFO_DEPS)
 	@$(NORMAL_INSTALL)
-	test -z "$(infodir)" || $(mkdir_p) "$(DESTDIR)$(infodir)"
+	test -z "$(infodir)" || $(MKDIR_P) "$(DESTDIR)$(infodir)"
 	@srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`; \
 	list='$(INFO_DEPS)'; \
 	for file in $$list; do \
@@ -574,6 +623,28 @@ install-info-am: $(INFO_DEPS)
 	else : ; fi
 install-man:
 
+install-pdf: install-pdf-am
+
+install-pdf-am: $(PDFS)
+	@$(NORMAL_INSTALL)
+	test -z "$(pdfdir)" || $(MKDIR_P) "$(DESTDIR)$(pdfdir)"
+	@list='$(PDFS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/$$f'"; \
+	  $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(pdfdir)/$$f"; \
+	done
+install-ps: install-ps-am
+
+install-ps-am: $(PSS)
+	@$(NORMAL_INSTALL)
+	test -z "$(psdir)" || $(MKDIR_P) "$(DESTDIR)$(psdir)"
+	@list='$(PSS)'; for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  f=$(am__strip_dir) \
+	  echo " $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(psdir)/$$f'"; \
+	  $(INSTALL_DATA) "$$d$$p" "$(DESTDIR)$(psdir)/$$f"; \
+	done
 installcheck-am:
 
 maintainer-clean: maintainer-clean-am
@@ -594,18 +665,24 @@ ps: ps-am
 
 ps-am: $(PSS)
 
-uninstall-am:
+uninstall-am: uninstall-dvi-am uninstall-html-am uninstall-info-am \
+	uninstall-pdf-am uninstall-ps-am
+
+.MAKE: install-am install-strip
 
 .PHONY: all all-am check check-am clean clean-generic clean-info \
 	clean-libtool dist-info distclean distclean-generic \
 	distclean-libtool dvi dvi-am html html-am info info-am install \
-	install-am install-data install-data-am install-exec \
-	install-exec-am install-info install-info-am install-man \
+	install-am install-data install-data-am install-dvi \
+	install-dvi-am install-exec install-exec-am install-html \
+	install-html-am install-info install-info-am install-man \
+	install-pdf install-pdf-am install-ps install-ps-am \
 	install-strip installcheck installcheck-am installdirs \
 	maintainer-clean maintainer-clean-aminfo \
 	maintainer-clean-generic mostlyclean mostlyclean-aminfo \
 	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
-	uninstall uninstall-am uninstall-info-am
+	uninstall uninstall-am uninstall-dvi-am uninstall-html-am \
+	uninstall-info-am uninstall-pdf-am uninstall-ps-am
 
 
 $(MKDOC): $(srcdir)/chew.c
diff -Nrup gdb-6.7.1/bfd/elf32-avr32.c gdb-6.7.1-atmel/bfd/elf32-avr32.c
--- gdb-6.7.1/bfd/elf32-avr32.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/bfd/elf32-avr32.c	2008-04-03 15:00:37.000000000 +0200
@@ -0,0 +1,3909 @@
+/* AVR32-specific support for 32-bit ELF.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+#include "bfd.h"
+#include "sysdep.h"
+#include "bfdlink.h"
+#include "libbfd.h"
+#include "elf-bfd.h"
+#include "elf/avr32.h"
+#include "elf32-avr32.h"
+
+#define xDEBUG
+#define xRELAX_DEBUG
+
+#ifdef DEBUG
+# define pr_debug(fmt, args...) fprintf(stderr, fmt, ##args)
+#else
+# define pr_debug(fmt, args...) do { } while (0)
+#endif
+
+#ifdef RELAX_DEBUG
+# define RDBG(fmt, args...) fprintf(stderr, fmt, ##args)
+#else
+# define RDBG(fmt, args...) do { } while (0)
+#endif
+
+/* When things go wrong, we want it to blow up, damnit! */
+#undef BFD_ASSERT
+#undef abort
+#define BFD_ASSERT(expr)                    \
+  do                                \
+    {                               \
+      if (!(expr))                      \
+    {                           \
+      bfd_assert(__FILE__, __LINE__);           \
+      abort();                      \
+    }                           \
+    }                               \
+  while (0)
+
+/* The name of the dynamic interpreter. This is put in the .interp section. */
+#define ELF_DYNAMIC_INTERPRETER     "/lib/ld.so.1"
+
+#define AVR32_GOT_HEADER_SIZE       8
+#define AVR32_FUNCTION_STUB_SIZE    8
+
+#define ELF_R_INFO(x, y) ELF32_R_INFO(x, y)
+#define ELF_R_TYPE(x) ELF32_R_TYPE(x)
+#define ELF_R_SYM(x) ELF32_R_SYM(x)
+
+#define NOP_OPCODE 0xd703
+
+
+/* Mapping between BFD relocations and ELF relocations */
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup(bfd *abfd, bfd_reloc_code_real_type code);
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup(bfd *abfd, const char *r_name);
+
+static void
+avr32_info_to_howto (bfd *abfd, arelent *cache_ptr, Elf_Internal_Rela *dst);
+
+/* Generic HOWTO */
+#define GENH(name, align, size, bitsize, pcrel, bitpos, complain, mask) \
+  HOWTO(name, align, size, bitsize, pcrel, bitpos,          \
+    complain_overflow_##complain, bfd_elf_generic_reloc, #name, \
+    FALSE, 0, mask, pcrel)
+
+static reloc_howto_type elf_avr32_howto_table[] = {
+  /*   NAME      ALN SZ BSZ PCREL  BP COMPLAIN  MASK        */
+  GENH(R_AVR32_NONE,      0, 0, 0,  FALSE, 0, dont, 0x00000000),
+
+  GENH(R_AVR32_32,    0, 2, 32, FALSE, 0, dont, 0xffffffff),
+  GENH(R_AVR32_16,    0, 1, 16, FALSE, 0, bitfield, 0x0000ffff),
+  GENH(R_AVR32_8,     0, 0,  8, FALSE, 0, bitfield, 0x000000ff),
+  GENH(R_AVR32_32_PCREL,  0, 2, 32, TRUE,  0, signed,   0xffffffff),
+  GENH(R_AVR32_16_PCREL,  0, 1, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_8_PCREL,   0, 0,  8, TRUE,  0, signed,   0x000000ff),
+
+  /* Difference between two symbol (sym2 - sym1).  The reloc encodes
+     the value of sym1.  The field contains the difference before any
+     relaxing is done.  */
+  GENH(R_AVR32_DIFF32,    0, 2, 32, FALSE, 0, dont, 0xffffffff),
+  GENH(R_AVR32_DIFF16,    0, 1, 16, FALSE, 0, signed,   0x0000ffff),
+  GENH(R_AVR32_DIFF8,     0, 0,  8, FALSE, 0, signed,   0x000000ff),
+
+  GENH(R_AVR32_GOT32,     0, 2, 32, FALSE, 0, signed,   0xffffffff),
+  GENH(R_AVR32_GOT16,     0, 1, 16, FALSE, 0, signed,   0x0000ffff),
+  GENH(R_AVR32_GOT8,      0, 0,  8, FALSE, 0, signed,   0x000000ff),
+
+  GENH(R_AVR32_21S,   0, 2, 21, FALSE, 0, signed,   0x1e10ffff),
+  GENH(R_AVR32_16U,   0, 2, 16, FALSE, 0, unsigned, 0x0000ffff),
+  GENH(R_AVR32_16S,   0, 2, 16, FALSE, 0, signed,   0x0000ffff),
+  GENH(R_AVR32_8S,    0, 1,  8, FALSE, 4, signed,   0x00000ff0),
+  GENH(R_AVR32_8S_EXT,    0, 2,  8, FALSE, 0, signed,   0x000000ff),
+
+  GENH(R_AVR32_22H_PCREL, 1, 2, 21, TRUE,  0, signed,   0x1e10ffff),
+  GENH(R_AVR32_18W_PCREL, 2, 2, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_16B_PCREL, 0, 2, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_16N_PCREL, 0, 2, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_14UW_PCREL, 2, 2, 12, TRUE, 0, unsigned, 0x0000f0ff),
+  GENH(R_AVR32_11H_PCREL, 1, 1, 10, TRUE,  4, signed,   0x00000ff3),
+  GENH(R_AVR32_10UW_PCREL, 2, 2, 8, TRUE,  0, unsigned, 0x000000ff),
+  GENH(R_AVR32_9H_PCREL,  1, 1,  8, TRUE,  4, signed,   0x00000ff0),
+  GENH(R_AVR32_9UW_PCREL, 2, 1,  7, TRUE,  4, unsigned, 0x000007f0),
+
+  GENH(R_AVR32_HI16,     16, 2, 16, FALSE, 0, dont, 0x0000ffff),
+  GENH(R_AVR32_LO16,      0, 2, 16, FALSE, 0, dont, 0x0000ffff),
+
+  GENH(R_AVR32_GOTPC,     0, 2, 32, FALSE, 0, dont, 0xffffffff),
+  GENH(R_AVR32_GOTCALL,   2, 2, 21, FALSE, 0, signed,   0x1e10ffff),
+  GENH(R_AVR32_LDA_GOT,   2, 2, 21, FALSE, 0, signed,   0x1e10ffff),
+  GENH(R_AVR32_GOT21S,    0, 2, 21, FALSE, 0, signed,   0x1e10ffff),
+  GENH(R_AVR32_GOT18SW,   2, 2, 16, FALSE, 0, signed,   0x0000ffff),
+  GENH(R_AVR32_GOT16S,    0, 2, 16, FALSE, 0, signed,   0x0000ffff),
+  GENH(R_AVR32_GOT7UW,    2, 1,  5, FALSE, 4, unsigned, 0x000001f0),
+
+  GENH(R_AVR32_32_CPENT,  0, 2, 32, FALSE, 0, dont, 0xffffffff),
+  GENH(R_AVR32_CPCALL,    2, 2, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_16_CP,     0, 2, 16, TRUE,  0, signed,   0x0000ffff),
+  GENH(R_AVR32_9W_CP,     2, 1,  7, TRUE,  4, unsigned, 0x000007f0),
+
+  GENH(R_AVR32_RELATIVE,  0, 2, 32, FALSE, 0, signed,   0xffffffff),
+  GENH(R_AVR32_GLOB_DAT,  0, 2, 32, FALSE, 0, dont, 0xffffffff),
+  GENH(R_AVR32_JMP_SLOT,  0, 2, 32, FALSE, 0, dont, 0xffffffff),
+
+  GENH(R_AVR32_ALIGN,    0,  1, 0,  FALSE, 0, unsigned, 0x00000000),
+};
+
+struct elf_reloc_map
+{
+  bfd_reloc_code_real_type bfd_reloc_val;
+  unsigned char elf_reloc_val;
+};
+
+static const struct elf_reloc_map avr32_reloc_map[] =
+{
+  { BFD_RELOC_NONE,         R_AVR32_NONE },
+
+  { BFD_RELOC_32,           R_AVR32_32 },
+  { BFD_RELOC_16,           R_AVR32_16 },
+  { BFD_RELOC_8,            R_AVR32_8 },
+  { BFD_RELOC_32_PCREL,         R_AVR32_32_PCREL },
+  { BFD_RELOC_16_PCREL,         R_AVR32_16_PCREL },
+  { BFD_RELOC_8_PCREL,          R_AVR32_8_PCREL },
+  { BFD_RELOC_AVR32_DIFF32,     R_AVR32_DIFF32 },
+  { BFD_RELOC_AVR32_DIFF16,     R_AVR32_DIFF16 },
+  { BFD_RELOC_AVR32_DIFF8,      R_AVR32_DIFF8 },
+  { BFD_RELOC_AVR32_GOT32,      R_AVR32_GOT32 },
+  { BFD_RELOC_AVR32_GOT16,      R_AVR32_GOT16 },
+  { BFD_RELOC_AVR32_GOT8,       R_AVR32_GOT8 },
+
+  { BFD_RELOC_AVR32_21S,        R_AVR32_21S },
+  { BFD_RELOC_AVR32_16U,        R_AVR32_16U },
+  { BFD_RELOC_AVR32_16S,        R_AVR32_16S },
+  { BFD_RELOC_AVR32_SUB5,       R_AVR32_16S },
+  { BFD_RELOC_AVR32_8S_EXT,     R_AVR32_8S_EXT },
+  { BFD_RELOC_AVR32_8S,         R_AVR32_8S },
+
+  { BFD_RELOC_AVR32_22H_PCREL,      R_AVR32_22H_PCREL },
+  { BFD_RELOC_AVR32_18W_PCREL,      R_AVR32_18W_PCREL },
+  { BFD_RELOC_AVR32_16B_PCREL,      R_AVR32_16B_PCREL },
+  { BFD_RELOC_AVR32_16N_PCREL,      R_AVR32_16N_PCREL },
+  { BFD_RELOC_AVR32_11H_PCREL,      R_AVR32_11H_PCREL },
+  { BFD_RELOC_AVR32_10UW_PCREL,     R_AVR32_10UW_PCREL },
+  { BFD_RELOC_AVR32_9H_PCREL,       R_AVR32_9H_PCREL },
+  { BFD_RELOC_AVR32_9UW_PCREL,      R_AVR32_9UW_PCREL },
+
+  { BFD_RELOC_HI16,         R_AVR32_HI16 },
+  { BFD_RELOC_LO16,         R_AVR32_LO16 },
+
+  { BFD_RELOC_AVR32_GOTPC,      R_AVR32_GOTPC },
+  { BFD_RELOC_AVR32_GOTCALL,        R_AVR32_GOTCALL },
+  { BFD_RELOC_AVR32_LDA_GOT,        R_AVR32_LDA_GOT },
+  { BFD_RELOC_AVR32_GOT21S,     R_AVR32_GOT21S },
+  { BFD_RELOC_AVR32_GOT18SW,        R_AVR32_GOT18SW },
+  { BFD_RELOC_AVR32_GOT16S,     R_AVR32_GOT16S },
+  /* GOT7UW should never be generated by the assembler */
+
+  { BFD_RELOC_AVR32_32_CPENT,       R_AVR32_32_CPENT },
+  { BFD_RELOC_AVR32_CPCALL,     R_AVR32_CPCALL },
+  { BFD_RELOC_AVR32_16_CP,      R_AVR32_16_CP },
+  { BFD_RELOC_AVR32_9W_CP,      R_AVR32_9W_CP },
+
+  { BFD_RELOC_AVR32_ALIGN,      R_AVR32_ALIGN },
+};
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_type_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                 bfd_reloc_code_real_type code)
+{
+  unsigned int i;
+
+  for (i = 0; i < sizeof(avr32_reloc_map) / sizeof(struct elf_reloc_map); i++)
+    {
+      if (avr32_reloc_map[i].bfd_reloc_val == code)
+    return &elf_avr32_howto_table[avr32_reloc_map[i].elf_reloc_val];
+    }
+
+  return NULL;
+}
+
+static reloc_howto_type *
+bfd_elf32_bfd_reloc_name_lookup (bfd *abfd ATTRIBUTE_UNUSED,
+                 const char *r_name)
+{
+  unsigned int i;
+
+  for (i = 0;
+       i < sizeof (elf_avr32_howto_table) / sizeof (elf_avr32_howto_table[0]);
+       i++)
+    if (elf_avr32_howto_table[i].name != NULL
+    && strcasecmp (elf_avr32_howto_table[i].name, r_name) == 0)
+      return &elf_avr32_howto_table[i];
+
+  return NULL;
+}
+
+/* Set the howto pointer for an AVR32 ELF reloc.  */
+static void
+avr32_info_to_howto (bfd *abfd ATTRIBUTE_UNUSED,
+             arelent *cache_ptr,
+             Elf_Internal_Rela *dst)
+{
+  unsigned int r_type;
+
+  r_type = ELF32_R_TYPE (dst->r_info);
+  BFD_ASSERT (r_type < (unsigned int) R_AVR32_max);
+  cache_ptr->howto = &elf_avr32_howto_table[r_type];
+}
+
+
+/* AVR32 ELF linker hash table and associated hash entries. */
+
+static struct bfd_hash_entry *
+avr32_elf_link_hash_newfunc(struct bfd_hash_entry *entry,
+                struct bfd_hash_table *table,
+                const char *string);
+static void
+avr32_elf_copy_indirect_symbol(struct bfd_link_info *info,
+                   struct elf_link_hash_entry *dir,
+                   struct elf_link_hash_entry *ind);
+static struct bfd_link_hash_table *
+avr32_elf_link_hash_table_create(bfd *abfd);
+
+/*
+  Try to limit memory usage to something reasonable when sorting the
+  GOT.  If just a couple of entries end up getting more references
+  than this, it won't affect performance at all, but if there are many
+  of them, we could end up with the wrong symbols being assigned the
+  first GOT entries.
+*/
+#define MAX_NR_GOT_HOLES    2048
+
+/*
+  AVR32 GOT entry.  We need to keep track of refcounts and offsets
+  simultaneously, since we need the offsets during relaxation, and we
+  also want to be able to drop GOT entries during relaxation. In
+  addition to this, we want to keep the list of GOT entries sorted so
+  that we can keep the most-used entries at the lowest offsets.
+*/
+struct got_entry
+{
+  struct got_entry *next;
+  struct got_entry **pprev;
+  int refcount;
+  bfd_signed_vma offset;
+};
+
+struct elf_avr32_link_hash_entry
+{
+  struct elf_link_hash_entry root;
+
+  /* Number of runtime relocations against this symbol.  */
+  unsigned int possibly_dynamic_relocs;
+
+  /* If there are anything but R_AVR32_GOT18 relocations against this
+     symbol, it means that someone may be taking the address of the
+     function, and we should therefore not create a stub.  */
+  bfd_boolean no_fn_stub;
+
+  /* If there is a R_AVR32_32 relocation in a read-only section
+     against this symbol, we could be in trouble. If we're linking a
+     shared library or this symbol is defined in one, it means we must
+     emit a run-time reloc for it and that's not allowed in read-only
+     sections.  */
+  asection *readonly_reloc_sec;
+  bfd_vma readonly_reloc_offset;
+
+  /* Record which frag (if any) contains the symbol.  This is used
+     during relaxation in order to avoid having to update all symbols
+     whenever we move something.  For local symbols, this information
+     is in the local_sym_frag member of struct elf_obj_tdata.  */
+  struct fragment *sym_frag;
+};
+#define avr32_elf_hash_entry(ent) ((struct elf_avr32_link_hash_entry *)(ent))
+
+struct elf_avr32_link_hash_table
+{
+  struct elf_link_hash_table root;
+
+  /* Shortcuts to get to dynamic linker sections.  */
+  asection *sgot;
+  asection *srelgot;
+  asection *sstub;
+
+  /* We use a variation of Pigeonhole Sort to sort the GOT.  After the
+     initial refcounts have been determined, we initialize
+     nr_got_holes to the highest refcount ever seen and allocate an
+     array of nr_got_holes entries for got_hole.  Each GOT entry is
+     then stored in this array at the index given by its refcount.
+
+     When a GOT entry has its refcount decremented during relaxation,
+     it is moved to a lower index in the got_hole array.
+   */
+  struct got_entry **got_hole;
+  int nr_got_holes;
+
+  /* Dynamic relocations to local symbols.  Only used when linking a
+     shared library and -Bsymbolic is not given.  */
+  unsigned int local_dynamic_relocs;
+
+  bfd_boolean relocations_analyzed;
+  bfd_boolean symbols_adjusted;
+  bfd_boolean repeat_pass;
+  bfd_boolean direct_data_refs;
+  unsigned int relax_iteration;
+  unsigned int relax_pass;
+};
+#define avr32_elf_hash_table(p)             \
+  ((struct elf_avr32_link_hash_table *)((p)->hash))
+
+static struct bfd_hash_entry *
+avr32_elf_link_hash_newfunc(struct bfd_hash_entry *entry,
+                struct bfd_hash_table *table,
+                const char *string)
+{
+  struct elf_avr32_link_hash_entry *ret = avr32_elf_hash_entry(entry);
+
+  /* Allocate the structure if it hasn't already been allocated by a
+     subclass */
+  if (ret == NULL)
+    ret = (struct elf_avr32_link_hash_entry *)
+      bfd_hash_allocate(table, sizeof(struct elf_avr32_link_hash_entry));
+
+  if (ret == NULL)
+    return NULL;
+
+  memset(ret, 0, sizeof(struct elf_avr32_link_hash_entry));
+
+  /* Give the superclass a chance */
+  ret = (struct elf_avr32_link_hash_entry *)
+    _bfd_elf_link_hash_newfunc((struct bfd_hash_entry *)ret, table, string);
+
+  return (struct bfd_hash_entry *)ret;
+}
+
+/* Copy data from an indirect symbol to its direct symbol, hiding the
+   old indirect symbol.  Process additional relocation information.
+   Also called for weakdefs, in which case we just let
+   _bfd_elf_link_hash_copy_indirect copy the flags for us.  */
+
+static void
+avr32_elf_copy_indirect_symbol(struct bfd_link_info *info,
+                   struct elf_link_hash_entry *dir,
+                   struct elf_link_hash_entry *ind)
+{
+  struct elf_avr32_link_hash_entry *edir, *eind;
+
+  _bfd_elf_link_hash_copy_indirect (info, dir, ind);
+
+  if (ind->root.type != bfd_link_hash_indirect)
+    return;
+
+  edir = (struct elf_avr32_link_hash_entry *)dir;
+  eind = (struct elf_avr32_link_hash_entry *)ind;
+
+  edir->possibly_dynamic_relocs += eind->possibly_dynamic_relocs;
+  edir->no_fn_stub = edir->no_fn_stub || eind->no_fn_stub;
+}
+
+static struct bfd_link_hash_table *
+avr32_elf_link_hash_table_create(bfd *abfd)
+{
+  struct elf_avr32_link_hash_table *ret;
+
+  ret = bfd_zmalloc(sizeof(*ret));
+  if (ret == NULL)
+    return NULL;
+
+  if (! _bfd_elf_link_hash_table_init(&ret->root, abfd,
+                      avr32_elf_link_hash_newfunc,
+                      sizeof (struct elf_avr32_link_hash_entry)))
+    {
+      free(ret);
+      return NULL;
+    }
+
+  /* Prevent the BFD core from creating bogus got_entry pointers */
+  ret->root.init_got_refcount.glist = NULL;
+  ret->root.init_plt_refcount.glist = NULL;
+  ret->root.init_got_offset.glist = NULL;
+  ret->root.init_plt_offset.glist = NULL;
+
+  return &ret->root.root;
+}
+
+
+/* Initial analysis and creation of dynamic sections and symbols */
+
+static asection *
+create_dynamic_section(bfd *dynobj, const char *name, flagword flags,
+               unsigned int align_power);
+static struct elf_link_hash_entry *
+create_dynamic_symbol(bfd *dynobj, struct bfd_link_info *info,
+              const char *name, asection *sec,
+              bfd_vma offset);
+static bfd_boolean
+avr32_elf_create_got_section (bfd *dynobj, struct bfd_link_info *info);
+static bfd_boolean
+avr32_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info);
+static bfd_boolean
+avr32_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
+            const Elf_Internal_Rela *relocs);
+static bfd_boolean
+avr32_elf_adjust_dynamic_symbol(struct bfd_link_info *info,
+                struct elf_link_hash_entry *h);
+
+static asection *
+create_dynamic_section(bfd *dynobj, const char *name, flagword flags,
+               unsigned int align_power)
+{
+  asection *sec;
+
+  sec = bfd_make_section(dynobj, name);
+  if (!sec
+      || !bfd_set_section_flags(dynobj, sec, flags)
+      || !bfd_set_section_alignment(dynobj, sec, align_power))
+    return NULL;
+
+  return sec;
+}
+
+static struct elf_link_hash_entry *
+create_dynamic_symbol(bfd *dynobj, struct bfd_link_info *info,
+              const char *name, asection *sec,
+              bfd_vma offset)
+{
+  struct bfd_link_hash_entry *bh = NULL;
+  struct elf_link_hash_entry *h;
+  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+
+  if (!(_bfd_generic_link_add_one_symbol
+    (info, dynobj, name, BSF_GLOBAL, sec, offset, NULL, FALSE,
+     bed->collect, &bh)))
+    return NULL;
+
+  h = (struct elf_link_hash_entry *)bh;
+  h->def_regular = 1;
+  h->type = STT_OBJECT;
+  h->other = STV_HIDDEN;
+
+  return h;
+}
+
+static bfd_boolean
+avr32_elf_create_got_section (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  flagword flags;
+  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+
+  htab = avr32_elf_hash_table(info);
+  flags = bed->dynamic_sec_flags;
+
+  if (htab->sgot)
+    return TRUE;
+
+  htab->sgot = create_dynamic_section(dynobj, ".got", flags, 2);
+  if (!htab->srelgot)
+    htab->srelgot = create_dynamic_section(dynobj, ".rela.got",
+                       flags | SEC_READONLY, 2);
+
+  if (!htab->sgot || !htab->srelgot)
+    return FALSE;
+
+  htab->root.hgot = create_dynamic_symbol(dynobj, info, "_GLOBAL_OFFSET_TABLE_",
+                      htab->sgot, 0);
+  if (!htab->root.hgot)
+    return FALSE;
+
+  /* Make room for the GOT header */
+  htab->sgot->size += bed->got_header_size;
+
+  return TRUE;
+}
+
+/* (1) Create all dynamic (i.e. linker generated) sections that we may
+   need during the link */
+
+static bfd_boolean
+avr32_elf_create_dynamic_sections (bfd *dynobj, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  flagword flags;
+  const struct elf_backend_data *bed = get_elf_backend_data (dynobj);
+
+  pr_debug("(1) create dynamic sections\n");
+
+  htab = avr32_elf_hash_table(info);
+  flags = bed->dynamic_sec_flags;
+
+  if (!avr32_elf_create_got_section (dynobj, info))
+    return FALSE;
+
+  if (!htab->sstub)
+    htab->sstub = create_dynamic_section(dynobj, ".stub",
+                     flags | SEC_READONLY | SEC_CODE, 2);
+
+  if (!htab->sstub)
+    return FALSE;
+
+  return TRUE;
+}
+
+/* (2) Go through all the relocs and count any potential GOT- or
+   PLT-references to each symbol */
+
+static bfd_boolean
+avr32_check_relocs (bfd *abfd, struct bfd_link_info *info, asection *sec,
+            const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_avr32_link_hash_table *htab;
+  struct elf_link_hash_entry **sym_hashes;
+  const Elf_Internal_Rela *rel, *rel_end;
+  struct got_entry **local_got_ents;
+  struct got_entry *got;
+  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
+  asection *sgot;
+  bfd *dynobj;
+
+  pr_debug("(2) check relocs for %s:<%s> (size 0x%lx)\n",
+       abfd->filename, sec->name, sec->size);
+
+  if (info->relocatable)
+    return TRUE;
+
+  dynobj = elf_hash_table(info)->dynobj;
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes(abfd);
+  htab = avr32_elf_hash_table(info);
+  local_got_ents = elf_local_got_ents(abfd);
+  sgot = htab->sgot;
+
+  rel_end = relocs + sec->reloc_count;
+  for (rel = relocs; rel < rel_end; rel++)
+    {
+      unsigned long r_symndx, r_type;
+      struct elf_avr32_link_hash_entry *h;
+
+      r_symndx = ELF32_R_SYM(rel->r_info);
+      r_type = ELF32_R_TYPE(rel->r_info);
+
+      /* Local symbols use local_got_ents, while others store the same
+     information in the hash entry */
+      if (r_symndx < symtab_hdr->sh_info)
+    {
+      pr_debug("  (2a) processing local symbol %lu\n", r_symndx);
+      h = NULL;
+    }
+      else
+    {
+      h = (struct elf_avr32_link_hash_entry *)
+        sym_hashes[r_symndx - symtab_hdr->sh_info];
+      while (h->root.type == bfd_link_hash_indirect
+         || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_avr32_link_hash_entry *)h->root.root.u.i.link;
+      pr_debug("  (2a) processing symbol %s\n", h->root.root.root.string);
+    }
+
+      /* Some relocs require special sections to be created.  */
+      switch (r_type)
+    {
+    case R_AVR32_GOT32:
+    case R_AVR32_GOT16:
+    case R_AVR32_GOT8:
+    case R_AVR32_GOT21S:
+    case R_AVR32_GOT18SW:
+    case R_AVR32_GOT16S:
+    case R_AVR32_GOT7UW:
+    case R_AVR32_LDA_GOT:
+    case R_AVR32_GOTCALL:
+      if (rel->r_addend)
+        {
+          if (info->callbacks->reloc_dangerous
+          (info, _("Non-zero addend on GOT-relative relocation"),
+           abfd, sec, rel->r_offset) == FALSE)
+        return FALSE;
+        }
+      /* fall through */
+    case R_AVR32_GOTPC:
+      if (dynobj == NULL)
+        elf_hash_table(info)->dynobj = dynobj = abfd;
+      if (sgot == NULL && !avr32_elf_create_got_section(dynobj, info))
+        return FALSE;
+      break;
+    case R_AVR32_32:
+      /* We may need to create .rela.dyn later on.  */
+      if (dynobj == NULL
+          && (info->shared || h != NULL)
+          && (sec->flags & SEC_ALLOC))
+        elf_hash_table(info)->dynobj = dynobj = abfd;
+      break;
+    }
+
+      if (h != NULL && r_type != R_AVR32_GOT18SW)
+    h->no_fn_stub = TRUE;
+
+      switch (r_type)
+    {
+    case R_AVR32_GOT32:
+    case R_AVR32_GOT16:
+    case R_AVR32_GOT8:
+    case R_AVR32_GOT21S:
+    case R_AVR32_GOT18SW:
+    case R_AVR32_GOT16S:
+    case R_AVR32_GOT7UW:
+    case R_AVR32_LDA_GOT:
+    case R_AVR32_GOTCALL:
+      if (h != NULL)
+        {
+          got = h->root.got.glist;
+          if (!got)
+        {
+          got = bfd_zalloc(abfd, sizeof(struct got_entry));
+          if (!got)
+            return FALSE;
+          h->root.got.glist = got;
+        }
+        }
+      else
+        {
+          if (!local_got_ents)
+        {
+          bfd_size_type size;
+          bfd_size_type i;
+          struct got_entry *tmp_entry;
+
+          size = symtab_hdr->sh_info;
+          size *= sizeof(struct got_entry *) + sizeof(struct got_entry);
+          local_got_ents = bfd_zalloc(abfd, size);
+          if (!local_got_ents)
+            return FALSE;
+
+          elf_local_got_ents(abfd) = local_got_ents;
+
+          tmp_entry = (struct got_entry *)(local_got_ents
+                           + symtab_hdr->sh_info);
+          for (i = 0; i < symtab_hdr->sh_info; i++)
+            local_got_ents[i] = &tmp_entry[i];
+        }
+
+          got = local_got_ents[r_symndx];
+        }
+
+      got->refcount++;
+      if (got->refcount > htab->nr_got_holes)
+        htab->nr_got_holes = got->refcount;
+      break;
+
+    case R_AVR32_32:
+      if ((info->shared || h != NULL)
+          && (sec->flags & SEC_ALLOC))
+        {
+          if (htab->srelgot == NULL)
+        {
+          htab->srelgot = create_dynamic_section(dynobj, ".rela.got",
+                             bed->dynamic_sec_flags
+                             | SEC_READONLY, 2);
+          if (htab->srelgot == NULL)
+            return FALSE;
+        }
+
+          if (sec->flags & SEC_READONLY
+          && !h->readonly_reloc_sec)
+        {
+          h->readonly_reloc_sec = sec;
+          h->readonly_reloc_offset = rel->r_offset;
+        }
+
+          if (h != NULL)
+        {
+          pr_debug("Non-GOT reference to symbol %s\n",
+               h->root.root.root.string);
+          h->possibly_dynamic_relocs++;
+        }
+          else
+        {
+          pr_debug("Non-GOT reference to local symbol %lu\n",
+               r_symndx);
+          htab->local_dynamic_relocs++;
+        }
+        }
+
+      break;
+
+      /* TODO: GNU_VTINHERIT and GNU_VTENTRY */
+    }
+    }
+
+  return TRUE;
+}
+
+/* (3) Adjust a symbol defined by a dynamic object and referenced by a
+   regular object.  The current definition is in some section of the
+   dynamic object, but we're not including those sections.  We have to
+   change the definition to something the rest of the link can
+   understand.  */
+
+static bfd_boolean
+avr32_elf_adjust_dynamic_symbol(struct bfd_link_info *info,
+                struct elf_link_hash_entry *h)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct elf_avr32_link_hash_entry *havr;
+  bfd *dynobj;
+
+  pr_debug("(3) adjust dynamic symbol %s\n", h->root.root.string);
+
+  htab = avr32_elf_hash_table(info);
+  havr = (struct elf_avr32_link_hash_entry *)h;
+  dynobj = elf_hash_table(info)->dynobj;
+
+  /* Make sure we know what is going on here.  */
+  BFD_ASSERT (dynobj != NULL
+          && (h->u.weakdef != NULL
+          || (h->def_dynamic
+              && h->ref_regular
+              && !h->def_regular)));
+
+  /* We don't want dynamic relocations in read-only sections. */
+  if (havr->readonly_reloc_sec)
+    {
+      if (info->callbacks->reloc_dangerous
+      (info, _("dynamic relocation in read-only section"),
+       havr->readonly_reloc_sec->owner, havr->readonly_reloc_sec,
+       havr->readonly_reloc_offset) == FALSE)
+    return FALSE;
+    }
+
+  /* If this is a function, create a stub if possible and set the
+     symbol to the stub location.  */
+  if (0 && !havr->no_fn_stub)
+    {
+      if (!h->def_regular)
+    {
+      asection *s = htab->sstub;
+
+      BFD_ASSERT(s != NULL);
+
+      h->root.u.def.section = s;
+      h->root.u.def.value = s->size;
+      h->plt.offset = s->size;
+      s->size += AVR32_FUNCTION_STUB_SIZE;
+
+      return TRUE;
+    }
+    }
+  else if (h->type == STT_FUNC)
+    {
+      /* This will set the entry for this symbol in the GOT to 0, and
+     the dynamic linker will take care of this. */
+      h->root.u.def.value = 0;
+      return TRUE;
+    }
+
+  /* If this is a weak symbol, and there is a real definition, the
+     processor independent code will have arranged for us to see the
+     real definition first, and we can just use the same value.  */
+  if (h->u.weakdef != NULL)
+    {
+      BFD_ASSERT(h->u.weakdef->root.type == bfd_link_hash_defined
+         || h->u.weakdef->root.type == bfd_link_hash_defweak);
+      h->root.u.def.section = h->u.weakdef->root.u.def.section;
+      h->root.u.def.value = h->u.weakdef->root.u.def.value;
+      return TRUE;
+    }
+
+  /* This is a reference to a symbol defined by a dynamic object which
+     is not a function.  */
+
+  return TRUE;
+}
+
+
+/* Garbage-collection of unused sections */
+
+static asection *
+avr32_elf_gc_mark_hook(asection *sec,
+               struct bfd_link_info *info ATTRIBUTE_UNUSED,
+               Elf_Internal_Rela *rel,
+               struct elf_link_hash_entry *h,
+               Elf_Internal_Sym *sym)
+{
+  if (h)
+    {
+      switch (ELF32_R_TYPE(rel->r_info))
+    {
+      /* TODO: VTINHERIT/VTENTRY */
+    default:
+      switch (h->root.type)
+        {
+        case bfd_link_hash_defined:
+        case bfd_link_hash_defweak:
+          return h->root.u.def.section;
+
+        case bfd_link_hash_common:
+          return h->root.u.c.p->section;
+
+        default:
+          break;
+        }
+    }
+    }
+  else
+    return bfd_section_from_elf_index(sec->owner, sym->st_shndx);
+
+  return NULL;
+}
+
+/* Update the GOT entry reference counts for the section being removed. */
+static bfd_boolean
+avr32_elf_gc_sweep_hook(bfd *abfd,
+            struct bfd_link_info *info ATTRIBUTE_UNUSED,
+            asection *sec,
+            const Elf_Internal_Rela *relocs)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  struct elf_avr32_link_hash_entry **sym_hashes;
+  struct got_entry **local_got_ents;
+  const Elf_Internal_Rela *rel, *relend;
+
+  if (!(sec->flags & SEC_ALLOC))
+    return TRUE;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  sym_hashes = (struct elf_avr32_link_hash_entry **)elf_sym_hashes(abfd);
+  local_got_ents = elf_local_got_ents(abfd);
+
+  relend = relocs + sec->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_symndx;
+      unsigned int r_type;
+      struct elf_avr32_link_hash_entry *h = NULL;
+
+      r_symndx = ELF32_R_SYM(rel->r_info);
+      if (r_symndx >= symtab_hdr->sh_info)
+    {
+      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+      while (h->root.root.type == bfd_link_hash_indirect
+         || h->root.root.type == bfd_link_hash_warning)
+        h = (struct elf_avr32_link_hash_entry *)h->root.root.u.i.link;
+    }
+
+      r_type = ELF32_R_TYPE(rel->r_info);
+
+      switch (r_type)
+    {
+    case R_AVR32_GOT32:
+    case R_AVR32_GOT16:
+    case R_AVR32_GOT8:
+    case R_AVR32_GOT21S:
+    case R_AVR32_GOT18SW:
+    case R_AVR32_GOT16S:
+    case R_AVR32_GOT7UW:
+    case R_AVR32_LDA_GOT:
+    case R_AVR32_GOTCALL:
+      if (h)
+        h->root.got.glist->refcount--;
+      else
+        local_got_ents[r_symndx]->refcount--;
+      break;
+
+    case R_AVR32_32:
+      if (info->shared || h)
+        {
+          if (h)
+        h->possibly_dynamic_relocs--;
+          else
+        avr32_elf_hash_table(info)->local_dynamic_relocs--;
+        }
+
+    default:
+      break;
+    }
+    }
+
+  return TRUE;
+}
+
+/* Sizing and refcounting of dynamic sections */
+
+static void
+insert_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got);
+static void
+unref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got);
+static void
+ref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got);
+static bfd_boolean
+assign_got_offsets(struct elf_avr32_link_hash_table *htab);
+static bfd_boolean
+allocate_dynrelocs(struct elf_link_hash_entry *h, void *_info);
+static bfd_boolean
+avr32_elf_size_dynamic_sections (bfd *output_bfd,
+                 struct bfd_link_info *info);
+
+static void
+insert_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
+{
+  /* Any entries with got_refcount > htab->nr_got_holes end up in the
+   * last pigeonhole without any sorting. We expect the number of such
+   * entries to be small, so it is very unlikely to affect
+   * performance.  */
+  int entry = got->refcount;
+
+  if (entry > htab->nr_got_holes)
+    entry = htab->nr_got_holes;
+
+  got->pprev = &htab->got_hole[entry];
+  got->next = htab->got_hole[entry];
+  if (got->next)
+    got->next->pprev = &got->next;
+  htab->got_hole[entry] = got;
+}
+
+/* Decrement the refcount of a GOT entry and update its position in
+   the pigeonhole array.  */
+static void
+unref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
+{
+  BFD_ASSERT(got->refcount > 0);
+
+  if (got->next)
+    got->next->pprev = got->pprev;
+
+  *(got->pprev) = got->next;
+  got->refcount--;
+  insert_got_entry(htab, got);
+}
+
+static void
+ref_got_entry(struct elf_avr32_link_hash_table *htab, struct got_entry *got)
+{
+  if (got->next)
+    got->next->pprev = got->pprev;
+
+  *(got->pprev) = got->next;
+  got->refcount++;
+  insert_got_entry(htab, got);
+
+  BFD_ASSERT(got->refcount > 0);
+}
+
+/* Assign offsets to all GOT entries we intend to keep.  The entries
+   that are referenced most often are placed at low offsets so that we
+   can use compact instructions as much as possible.
+
+   Returns TRUE if any offsets or the total size of the GOT changed.  */
+
+static bfd_boolean
+assign_got_offsets(struct elf_avr32_link_hash_table *htab)
+{
+  struct got_entry *got;
+  bfd_size_type got_size = 0;
+  bfd_boolean changed = FALSE;
+  bfd_signed_vma offset;
+  int i;
+
+  /* The GOT header provides the address of the DYNAMIC segment, so
+     we need that even if the GOT is otherwise empty.  */
+  if (htab->root.dynamic_sections_created)
+    got_size = AVR32_GOT_HEADER_SIZE;
+
+  for (i = htab->nr_got_holes; i > 0; i--)
+    {
+      got = htab->got_hole[i];
+      while (got)
+    {
+      if (got->refcount > 0)
+        {
+          offset = got_size;
+          if (got->offset != offset)
+        {
+          RDBG("GOT offset changed: %ld -> %ld\n",
+               got->offset, offset);
+          changed = TRUE;
+        }
+          got->offset = offset;
+          got_size += 4;
+        }
+      got = got->next;
+    }
+    }
+
+  if (htab->sgot->size != got_size)
+    {
+      RDBG("GOT size changed: %lu -> %lu\n", htab->sgot->size,
+       got_size);
+      changed = TRUE;
+    }
+  htab->sgot->size = got_size;
+
+  RDBG("assign_got_offsets: total size %lu (%s)\n",
+       got_size, changed ? "changed" : "no change");
+
+  return changed;
+}
+
+static bfd_boolean
+allocate_dynrelocs(struct elf_link_hash_entry *h, void *_info)
+{
+  struct bfd_link_info *info = _info;
+  struct elf_avr32_link_hash_table *htab;
+  struct elf_avr32_link_hash_entry *havr;
+  struct got_entry *got;
+
+  pr_debug("  (4b) allocate_dynrelocs: %s\n", h->root.root.string);
+
+  if (h->root.type == bfd_link_hash_indirect)
+    return TRUE;
+
+  if (h->root.type == bfd_link_hash_warning)
+    /* When warning symbols are created, they **replace** the "real"
+       entry in the hash table, thus we never get to see the real
+       symbol in a hash traversal.  So look at it now.  */
+    h = (struct elf_link_hash_entry *) h->root.u.i.link;
+
+  htab = avr32_elf_hash_table(info);
+  havr = (struct elf_avr32_link_hash_entry *)h;
+
+  got = h->got.glist;
+
+  /* If got is NULL, the symbol is never referenced through the GOT */
+  if (got && got->refcount > 0)
+    {
+      insert_got_entry(htab, got);
+
+      /* Shared libraries need relocs for all GOT entries unless the
+     symbol is forced local or -Bsymbolic is used.  Others need
+     relocs for everything that is not guaranteed to be defined in
+     a regular object.  */
+      if ((info->shared
+       && !info->symbolic
+       && h->dynindx != -1)
+      || (htab->root.dynamic_sections_created
+          && h->def_dynamic
+          && !h->def_regular))
+    htab->srelgot->size += sizeof(Elf32_External_Rela);
+    }
+
+  if (havr->possibly_dynamic_relocs
+      && (info->shared
+      || (elf_hash_table(info)->dynamic_sections_created
+          && h->def_dynamic
+          && !h->def_regular)))
+    {
+      pr_debug("Allocating %d dynamic reloc against symbol %s...\n",
+           havr->possibly_dynamic_relocs, h->root.root.string);
+      htab->srelgot->size += (havr->possibly_dynamic_relocs
+                  * sizeof(Elf32_External_Rela));
+    }
+
+  return TRUE;
+}
+
+/* (4) Calculate the sizes of the linker-generated sections and
+   allocate memory for them.  */
+
+static bfd_boolean
+avr32_elf_size_dynamic_sections (bfd *output_bfd,
+                 struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  bfd *dynobj;
+  asection *s;
+  bfd *ibfd;
+  bfd_boolean relocs;
+
+  pr_debug("(4) size dynamic sections\n");
+
+  htab = avr32_elf_hash_table(info);
+  dynobj = htab->root.dynobj;
+  BFD_ASSERT(dynobj != NULL);
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Initialize the contents of the .interp section to the name of
+     the dynamic loader */
+      if (info->executable)
+    {
+      s = bfd_get_section_by_name(dynobj, ".interp");
+      BFD_ASSERT(s != NULL);
+      s->size = sizeof(ELF_DYNAMIC_INTERPRETER);
+      s->contents = (unsigned char *)ELF_DYNAMIC_INTERPRETER;
+    }
+    }
+
+  if (htab->nr_got_holes > 0)
+    {
+      /* Allocate holes for the pigeonhole sort algorithm */
+      pr_debug("Highest GOT refcount: %d\n", htab->nr_got_holes);
+
+      /* Limit the memory usage by clipping the number of pigeonholes
+       * at a predefined maximum. All entries with a higher refcount
+       * will end up in the last pigeonhole.  */
+      if (htab->nr_got_holes >= MAX_NR_GOT_HOLES)
+    {
+     htab->nr_got_holes = MAX_NR_GOT_HOLES - 1;
+
+     pr_debug("Limiting maximum number of GOT pigeonholes to %u\n",
+                htab->nr_got_holes);
+    }
+      htab->got_hole = bfd_zalloc(output_bfd,
+                  sizeof(struct got_entry *)
+                  * (htab->nr_got_holes + 1));
+      if (!htab->got_hole)
+    return FALSE;
+
+      /* Set up .got offsets for local syms.  */
+      for (ibfd = info->input_bfds; ibfd != NULL; ibfd = ibfd->link_next)
+    {
+      struct got_entry **local_got;
+      struct got_entry **end_local_got;
+      Elf_Internal_Shdr *symtab_hdr;
+      bfd_size_type locsymcount;
+
+      pr_debug("  (4a) processing file %s...\n", ibfd->filename);
+
+      BFD_ASSERT(bfd_get_flavour(ibfd) == bfd_target_elf_flavour);
+
+      local_got = elf_local_got_ents(ibfd);
+      if (!local_got)
+        continue;
+
+      symtab_hdr = &elf_tdata(ibfd)->symtab_hdr;
+      locsymcount = symtab_hdr->sh_info;
+      end_local_got = local_got + locsymcount;
+
+      for (; local_got < end_local_got; ++local_got)
+        insert_got_entry(htab, *local_got);
+    }
+    }
+
+  /* Allocate global sym .got entries and space for global sym
+     dynamic relocs */
+  elf_link_hash_traverse(&htab->root, allocate_dynrelocs, info);
+
+  /* Now that we have sorted the GOT entries, we are ready to
+     assign offsets and determine the initial size of the GOT. */
+  if (htab->sgot)
+    assign_got_offsets(htab);
+
+  /* Allocate space for local sym dynamic relocs */
+  BFD_ASSERT(htab->local_dynamic_relocs == 0 || info->shared);
+  if (htab->local_dynamic_relocs)
+    htab->srelgot->size += (htab->local_dynamic_relocs
+                * sizeof(Elf32_External_Rela));
+
+  /* We now have determined the sizes of the various dynamic
+     sections. Allocate memory for them. */
+  relocs = FALSE;
+  for (s = dynobj->sections; s; s = s->next)
+    {
+      if ((s->flags & SEC_LINKER_CREATED) == 0)
+    continue;
+
+      if (s == htab->sgot
+      || s == htab->sstub)
+    {
+      /* Strip this section if we don't need it */
+    }
+      else if (strncmp (bfd_get_section_name(dynobj, s), ".rela", 5) == 0)
+    {
+      if (s->size != 0)
+        relocs = TRUE;
+
+      s->reloc_count = 0;
+    }
+      else
+    {
+      /* It's not one of our sections */
+      continue;
+    }
+
+      if (s->size == 0)
+    {
+      /* Strip unneeded sections */
+      pr_debug("Stripping section %s from output...\n", s->name);
+      /* deleted function in 2.17
+      _bfd_strip_section_from_output(info, s);
+      */
+      continue;
+    }
+
+      s->contents = bfd_zalloc(dynobj, s->size);
+      if (s->contents == NULL)
+    return FALSE;
+    }
+
+  if (htab->root.dynamic_sections_created)
+    {
+      /* Add some entries to the .dynamic section.  We fill in the
+     values later, in sh_elf_finish_dynamic_sections, but we
+     must add the entries now so that we get the correct size for
+     the .dynamic section.  The DT_DEBUG entry is filled in by the
+     dynamic linker and used by the debugger.  */
+#define add_dynamic_entry(TAG, VAL) _bfd_elf_add_dynamic_entry(info, TAG, VAL)
+
+      if (!add_dynamic_entry(DT_PLTGOT, 0))
+    return FALSE;
+      if (!add_dynamic_entry(DT_AVR32_GOTSZ, 0))
+    return FALSE;
+
+      if (info->executable)
+    {
+      if (!add_dynamic_entry(DT_DEBUG, 0))
+        return FALSE;
+    }
+      if (relocs)
+    {
+      if (!add_dynamic_entry(DT_RELA, 0)
+          || !add_dynamic_entry(DT_RELASZ, 0)
+          || !add_dynamic_entry(DT_RELAENT,
+                    sizeof(Elf32_External_Rela)))
+        return FALSE;
+    }
+    }
+#undef add_dynamic_entry
+
+  return TRUE;
+}
+
+
+/* Access to internal relocations, section contents and symbols.
+   (stolen from the xtensa port)  */
+
+static Elf_Internal_Rela *
+retrieve_internal_relocs (bfd *abfd, asection *sec, bfd_boolean keep_memory);
+static void
+pin_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs);
+static void
+release_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs);
+static bfd_byte *
+retrieve_contents (bfd *abfd, asection *sec, bfd_boolean keep_memory);
+/*
+static void
+pin_contents (asection *sec, bfd_byte *contents);
+*/
+static void
+release_contents (asection *sec, bfd_byte *contents);
+static Elf_Internal_Sym *
+retrieve_local_syms (bfd *input_bfd, bfd_boolean keep_memory);
+/*
+static void
+pin_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf);
+*/
+static void
+release_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf);
+
+/* During relaxation, we need to modify relocations, section contents,
+   and symbol definitions, and we need to keep the original values from
+   being reloaded from the input files, i.e., we need to "pin" the
+   modified values in memory.  We also want to continue to observe the
+   setting of the "keep-memory" flag.  The following functions wrap the
+   standard BFD functions to take care of this for us.  */
+
+static Elf_Internal_Rela *
+retrieve_internal_relocs (bfd *abfd, asection *sec, bfd_boolean keep_memory)
+{
+  /* _bfd_elf_link_read_relocs knows about caching, so no need for us
+     to be clever here.  */
+  return _bfd_elf_link_read_relocs(abfd, sec, NULL, NULL, keep_memory);
+}
+
+static void
+pin_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs)
+{
+  elf_section_data (sec)->relocs = internal_relocs;
+}
+
+static void
+release_internal_relocs (asection *sec, Elf_Internal_Rela *internal_relocs)
+{
+  if (internal_relocs
+      && elf_section_data (sec)->relocs != internal_relocs)
+    free (internal_relocs);
+}
+
+static bfd_byte *
+retrieve_contents (bfd *abfd, asection *sec, bfd_boolean keep_memory)
+{
+  bfd_byte *contents;
+  bfd_size_type sec_size;
+
+  sec_size = bfd_get_section_limit (abfd, sec);
+  contents = elf_section_data (sec)->this_hdr.contents;
+
+  if (contents == NULL && sec_size != 0)
+    {
+      if (!bfd_malloc_and_get_section (abfd, sec, &contents))
+    {
+      if (contents)
+        free (contents);
+      return NULL;
+    }
+      if (keep_memory)
+    elf_section_data (sec)->this_hdr.contents = contents;
+    }
+  return contents;
+}
+
+/*
+static void
+pin_contents (asection *sec, bfd_byte *contents)
+{
+  elf_section_data (sec)->this_hdr.contents = contents;
+}
+*/
+static void
+release_contents (asection *sec, bfd_byte *contents)
+{
+  if (contents && elf_section_data (sec)->this_hdr.contents != contents)
+    free (contents);
+}
+
+static Elf_Internal_Sym *
+retrieve_local_syms (bfd *input_bfd, bfd_boolean keep_memory)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Sym *isymbuf;
+  size_t locsymcount;
+
+  symtab_hdr = &elf_tdata (input_bfd)->symtab_hdr;
+  locsymcount = symtab_hdr->sh_info;
+
+  isymbuf = (Elf_Internal_Sym *) symtab_hdr->contents;
+  if (isymbuf == NULL && locsymcount != 0)
+    {
+      isymbuf = bfd_elf_get_elf_syms (input_bfd, symtab_hdr, locsymcount, 0,
+                      NULL, NULL, NULL);
+      if (isymbuf && keep_memory)
+    symtab_hdr->contents = (unsigned char *) isymbuf;
+    }
+
+  return isymbuf;
+}
+
+/*
+static void
+pin_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf)
+{
+  elf_tdata (input_bfd)->symtab_hdr.contents = (unsigned char *)isymbuf;
+}
+
+*/
+static void
+release_local_syms (bfd *input_bfd, Elf_Internal_Sym *isymbuf)
+{
+  if (isymbuf && (elf_tdata (input_bfd)->symtab_hdr.contents
+          != (unsigned char *)isymbuf))
+    free (isymbuf);
+}
+
+/* Data structures used during relaxation. */
+
+enum relax_state_id {
+  RS_ERROR = -1,
+  RS_NONE = 0,
+  RS_ALIGN,
+  RS_CPENT,
+  RS_PIC_CALL,
+  RS_PIC_MCALL,
+  RS_PIC_RCALL2,
+  RS_PIC_RCALL1,
+  RS_PIC_LDA,
+  RS_PIC_LDW4,
+  RS_PIC_LDW3,
+  RS_PIC_SUB5,
+  RS_NOPIC_MCALL,
+  RS_NOPIC_RCALL2,
+  RS_NOPIC_RCALL1,
+  RS_NOPIC_LDW4,
+  RS_NOPIC_LDDPC,
+  RS_NOPIC_SUB5,
+  RS_NOPIC_MOV2,
+  RS_NOPIC_MOV1,
+  RS_RCALL2,
+  RS_RCALL1,
+  RS_BRC2,
+  RS_BRC1,
+  RS_BRAL,
+  RS_RJMP,
+  RS_MAX,
+};
+
+enum reference_type {
+  REF_ABSOLUTE,
+  REF_PCREL,
+  REF_CPOOL,
+  REF_GOT,
+};
+
+struct relax_state
+{
+  const char *name;
+  enum relax_state_id id;
+  enum relax_state_id direct;
+  enum relax_state_id next;
+  enum relax_state_id prev;
+
+  enum reference_type reftype;
+
+  unsigned int r_type;
+
+  bfd_vma opcode;
+  bfd_vma opcode_mask;
+
+  bfd_signed_vma range_min;
+  bfd_signed_vma range_max;
+
+  bfd_size_type size;
+};
+
+/*
+ * This is for relocs that
+ *   a) has an addend or is of type R_AVR32_DIFF32, and
+ *   b) references a different section than it's in, and
+ *   c) references a section that is relaxable
+ *
+ * as well as relocs that references the constant pool, in which case
+ * the add_frag member points to the frag containing the constant pool
+ * entry.
+ *
+ * Such relocs must be fixed up whenever we delete any code. Sections
+ * that don't have any relocs with all of the above properties don't
+ * have any additional reloc data, but sections that do will have
+ * additional data for all its relocs.
+ */
+struct avr32_reloc_data
+{
+  struct fragment *add_frag;
+  struct fragment *sub_frag;
+};
+
+/*
+ * A 'fragment' is a relaxable entity, that is, code may be added or
+ * deleted at the end of a fragment. When this happens, all subsequent
+ * fragments in the list will have their offsets updated.
+ */
+struct fragment
+{
+  enum relax_state_id state;
+  enum relax_state_id initial_state;
+
+  Elf_Internal_Rela *rela;
+  bfd_size_type size;
+  bfd_vma offset;
+  int size_adjust;
+  int offset_adjust;
+  bfd_boolean has_grown;
+
+  /* Only used by constant pool entries.  When this drops to zero, the
+     frag is discarded (i.e. size_adjust is set to -4.)  */
+  int refcount;
+};
+
+struct avr32_relax_data
+{
+  unsigned int frag_count;
+  struct fragment *frag;
+  struct avr32_reloc_data *reloc_data;
+
+  /* TRUE if this section has one or more relaxable relocations */
+  bfd_boolean is_relaxable;
+  unsigned int iteration;
+};
+
+struct avr32_section_data
+{
+  struct bfd_elf_section_data elf;
+  struct avr32_relax_data relax_data;
+};
+
+/* Relax state definitions */
+
+#define PIC_MOV2_OPCODE     0xe0600000
+#define PIC_MOV2_MASK       0xe1e00000
+#define PIC_MOV2_RANGE_MIN  (-1048576 * 4)
+#define PIC_MOV2_RANGE_MAX  (1048575 * 4)
+#define PIC_MCALL_OPCODE    0xf0160000
+#define PIC_MCALL_MASK      0xffff0000
+#define PIC_MCALL_RANGE_MIN (-131072)
+#define PIC_MCALL_RANGE_MAX (131068)
+#define RCALL2_OPCODE       0xe0a00000
+#define RCALL2_MASK     0xe1ef0000
+#define RCALL2_RANGE_MIN    (-2097152)
+#define RCALL2_RANGE_MAX    (2097150)
+#define RCALL1_OPCODE       0xc00c0000
+#define RCALL1_MASK     0xf00c0000
+#define RCALL1_RANGE_MIN    (-1024)
+#define RCALL1_RANGE_MAX    (1022)
+#define PIC_LDW4_OPCODE     0xecf00000
+#define PIC_LDW4_MASK       0xfff00000
+#define PIC_LDW4_RANGE_MIN  (-32768)
+#define PIC_LDW4_RANGE_MAX  (32767)
+#define PIC_LDW3_OPCODE     0x6c000000
+#define PIC_LDW3_MASK       0xfe000000
+#define PIC_LDW3_RANGE_MIN  (0)
+#define PIC_LDW3_RANGE_MAX  (124)
+#define SUB5_PC_OPCODE      0xfec00000
+#define SUB5_PC_MASK        0xfff00000
+#define SUB5_PC_RANGE_MIN   (-32768)
+#define SUB5_PC_RANGE_MAX   (32767)
+#define NOPIC_MCALL_OPCODE  0xf01f0000
+#define NOPIC_MCALL_MASK    0xffff0000
+#define NOPIC_MCALL_RANGE_MIN   PIC_MCALL_RANGE_MIN
+#define NOPIC_MCALL_RANGE_MAX   PIC_MCALL_RANGE_MAX
+#define NOPIC_LDW4_OPCODE   0xfef00000
+#define NOPIC_LDW4_MASK     0xfff00000
+#define NOPIC_LDW4_RANGE_MIN    PIC_LDW4_RANGE_MIN
+#define NOPIC_LDW4_RANGE_MAX    PIC_LDW4_RANGE_MAX
+#define LDDPC_OPCODE        0x48000000
+#define LDDPC_MASK      0xf8000000
+#define LDDPC_RANGE_MIN     0
+#define LDDPC_RANGE_MAX     508
+
+#define NOPIC_MOV2_OPCODE  0xe0600000
+#define NOPIC_MOV2_MASK        0xe1e00000
+#define NOPIC_MOV2_RANGE_MIN   (-1048576)
+#define NOPIC_MOV2_RANGE_MAX   (1048575)
+#define NOPIC_MOV1_OPCODE  0x30000000
+#define NOPIC_MOV1_MASK        0xf0000000
+#define NOPIC_MOV1_RANGE_MIN   (-128)
+#define NOPIC_MOV1_RANGE_MAX   (127)
+
+/* Only brc2 variants with cond[3] == 0 is considered, since the
+   others are not relaxable.  bral is a special case and is handled
+   separately.  */
+#define BRC2_OPCODE     0xe0800000
+#define BRC2_MASK       0xe1e80000
+#define BRC2_RANGE_MIN      (-2097152)
+#define BRC2_RANGE_MAX      (2097150)
+#define BRC1_OPCODE     0xc0000000
+#define BRC1_MASK       0xf0080000
+#define BRC1_RANGE_MIN      (-256)
+#define BRC1_RANGE_MAX      (254)
+#define BRAL_OPCODE     0xe08f0000
+#define BRAL_MASK       0xe1ef0000
+#define BRAL_RANGE_MIN      BRC2_RANGE_MIN
+#define BRAL_RANGE_MAX      BRC2_RANGE_MAX
+#define RJMP_OPCODE     0xc0080000
+#define RJMP_MASK       0xf00c0000
+#define RJMP_RANGE_MIN      (-1024)
+#define RJMP_RANGE_MAX      (1022)
+
+/* Define a relax state using the GOT  */
+#define RG(id, dir, next, prev, r_type, opc, size)          \
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_GOT,     \
+      R_AVR32_##r_type, opc##_OPCODE, opc##_MASK,           \
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+/* Define a relax state using the Constant Pool  */
+#define RC(id, dir, next, prev, r_type, opc, size)          \
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_CPOOL,   \
+      R_AVR32_##r_type, opc##_OPCODE, opc##_MASK,           \
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+
+/* Define a relax state using pc-relative direct reference  */
+#define RP(id, dir, next, prev, r_type, opc, size)          \
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_PCREL,   \
+      R_AVR32_##r_type, opc##_OPCODE, opc##_MASK,           \
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+
+/* Define a relax state using non-pc-relative direct reference */
+#define RD(id, dir, next, prev, r_type, opc, size)         \
+  { "RS_"#id, RS_##id, RS_##dir, RS_##next, RS_##prev, REF_ABSOLUTE,   \
+      R_AVR32_##r_type,    opc##_OPCODE, opc##_MASK,           \
+      opc##_RANGE_MIN, opc##_RANGE_MAX, size }
+
+/* Define a relax state that will be handled specially  */
+#define RS(id, r_type, size)                        \
+  { "RS_"#id, RS_##id, RS_NONE, RS_NONE, RS_NONE, REF_ABSOLUTE,     \
+      R_AVR32_##r_type, 0, 0, 0, 0, size }
+
+const struct relax_state relax_state[RS_MAX] = {
+  RS(NONE, NONE, 0),
+  RS(ALIGN, ALIGN, 0),
+  RS(CPENT, 32_CPENT, 4),
+
+  RG(PIC_CALL, PIC_RCALL1, PIC_MCALL, NONE, GOTCALL, PIC_MOV2, 10),
+  RG(PIC_MCALL, PIC_RCALL1, NONE, PIC_CALL, GOT18SW, PIC_MCALL, 4),
+  RP(PIC_RCALL2, NONE, PIC_RCALL1, PIC_MCALL, 22H_PCREL, RCALL2, 4),
+  RP(PIC_RCALL1, NONE, NONE, PIC_RCALL2, 11H_PCREL, RCALL1, 2),
+
+  RG(PIC_LDA, PIC_SUB5, PIC_LDW4, NONE, LDA_GOT, PIC_MOV2, 8),
+  RG(PIC_LDW4, PIC_SUB5, PIC_LDW3, PIC_LDA, GOT16S, PIC_LDW4, 4),
+  RG(PIC_LDW3, PIC_SUB5, NONE, PIC_LDW4, GOT7UW, PIC_LDW3, 2),
+  RP(PIC_SUB5, NONE, NONE, PIC_LDW3, 16N_PCREL, SUB5_PC, 4),
+
+  RC(NOPIC_MCALL, NOPIC_RCALL1, NONE, NONE, CPCALL, NOPIC_MCALL, 4),
+  RP(NOPIC_RCALL2, NONE, NOPIC_RCALL1, NOPIC_MCALL, 22H_PCREL, RCALL2, 4),
+  RP(NOPIC_RCALL1, NONE, NONE, NOPIC_RCALL2, 11H_PCREL, RCALL1, 2),
+
+  RC(NOPIC_LDW4, NOPIC_MOV1, NOPIC_LDDPC, NONE, 16_CP, NOPIC_LDW4, 4),
+  RC(NOPIC_LDDPC, NOPIC_MOV1, NONE, NOPIC_LDW4, 9W_CP, LDDPC, 2),
+  RP(NOPIC_SUB5, NOPIC_MOV1, NONE, NOPIC_LDDPC, 16N_PCREL, SUB5_PC, 4),
+  RD(NOPIC_MOV2, NONE, NOPIC_MOV1, NOPIC_SUB5, 21S, NOPIC_MOV2, 4),
+  RD(NOPIC_MOV1, NONE, NONE, NOPIC_MOV2, 8S, NOPIC_MOV1, 2),
+
+  RP(RCALL2, NONE, RCALL1, NONE, 22H_PCREL, RCALL2, 4),
+  RP(RCALL1, NONE, NONE, RCALL2, 11H_PCREL, RCALL1, 2),
+  RP(BRC2, NONE, BRC1, NONE, 22H_PCREL, BRC2, 4),
+  RP(BRC1, NONE, NONE, BRC2, 9H_PCREL, BRC1, 2),
+  RP(BRAL, NONE, RJMP, NONE, 22H_PCREL, BRAL, 4),
+  RP(RJMP, NONE, NONE, BRAL, 11H_PCREL, RJMP, 2),
+};
+
+static bfd_boolean
+avr32_elf_new_section_hook(bfd *abfd, asection *sec)
+{
+  struct avr32_section_data *sdata;
+
+  sdata = bfd_zalloc(abfd, sizeof(struct avr32_section_data));
+  if (!sdata)
+    return FALSE;
+
+  sec->used_by_bfd = sdata;
+  return _bfd_elf_new_section_hook(abfd, sec);
+}
+
+static struct avr32_relax_data *
+avr32_relax_data(asection *sec)
+{
+  struct avr32_section_data *sdata;
+
+  BFD_ASSERT(sec->used_by_bfd);
+
+  sdata = (struct avr32_section_data *)elf_section_data(sec);
+  return &sdata->relax_data;
+}
+
+/* Link-time relaxation */
+
+static bfd_boolean
+avr32_elf_relax_section(bfd *abfd, asection *sec,
+            struct bfd_link_info *info, bfd_boolean *again);
+
+enum relax_pass_id {
+  RELAX_PASS_SIZE_FRAGS,
+  RELAX_PASS_MOVE_DATA,
+};
+
+/* Stolen from the xtensa port */
+static int
+internal_reloc_compare (const void *ap, const void *bp)
+{
+  const Elf_Internal_Rela *a = (const Elf_Internal_Rela *) ap;
+  const Elf_Internal_Rela *b = (const Elf_Internal_Rela *) bp;
+
+  if (a->r_offset != b->r_offset)
+    return (a->r_offset - b->r_offset);
+
+  /* We don't need to sort on these criteria for correctness,
+     but enforcing a more strict ordering prevents unstable qsort
+     from behaving differently with different implementations.
+     Without the code below we get correct but different results
+     on Solaris 2.7 and 2.8.  We would like to always produce the
+     same results no matter the host.  */
+
+  if (a->r_info != b->r_info)
+    return (a->r_info - b->r_info);
+
+  return (a->r_addend - b->r_addend);
+}
+
+static enum relax_state_id
+get_pcrel22_relax_state(bfd *abfd, asection *sec, struct bfd_link_info *info,
+            const Elf_Internal_Rela *rela)
+{
+  bfd_byte *contents;
+  bfd_vma insn;
+  enum relax_state_id rs = RS_NONE;
+
+  contents = retrieve_contents(abfd, sec, info->keep_memory);
+  if (!contents)
+    return RS_ERROR;
+
+  insn = bfd_get_32(abfd, contents + rela->r_offset);
+  if ((insn & RCALL2_MASK) == RCALL2_OPCODE)
+    rs = RS_RCALL2;
+  else if ((insn & BRAL_MASK) == BRAL_OPCODE)
+    /* Optimizing bral -> rjmp gets us into all kinds of
+       trouble with jump tables. Better not do it.  */
+    rs = RS_NONE;
+  else if ((insn & BRC2_MASK) == BRC2_OPCODE)
+    rs = RS_BRC2;
+
+  release_contents(sec, contents);
+
+  return rs;
+}
+
+static enum relax_state_id
+get_initial_relax_state(bfd *abfd, asection *sec, struct bfd_link_info *info,
+            const Elf_Internal_Rela *rela)
+{
+  switch (ELF_R_TYPE(rela->r_info))
+    {
+    case R_AVR32_GOTCALL:
+      return RS_PIC_CALL;
+    case R_AVR32_GOT18SW:
+      return RS_PIC_MCALL;
+    case R_AVR32_LDA_GOT:
+      return RS_PIC_LDA;
+    case R_AVR32_GOT16S:
+      return RS_PIC_LDW4;
+    case R_AVR32_CPCALL:
+      return RS_NOPIC_MCALL;
+    case R_AVR32_16_CP:
+      return RS_NOPIC_LDW4;
+    case R_AVR32_9W_CP:
+      return RS_NOPIC_LDDPC;
+    case R_AVR32_ALIGN:
+      return RS_ALIGN;
+    case R_AVR32_32_CPENT:
+      return RS_CPENT;
+    case R_AVR32_22H_PCREL:
+      return get_pcrel22_relax_state(abfd, sec, info, rela);
+    case R_AVR32_9H_PCREL:
+      return RS_BRC1;
+    default:
+      return RS_NONE;
+    }
+}
+
+static bfd_boolean
+reloc_is_cpool_ref(const Elf_Internal_Rela *rela)
+{
+  switch (ELF_R_TYPE(rela->r_info))
+    {
+    case R_AVR32_CPCALL:
+    case R_AVR32_16_CP:
+    case R_AVR32_9W_CP:
+      return TRUE;
+    default:
+      return FALSE;
+    }
+}
+
+static struct fragment *
+new_frag(bfd *abfd ATTRIBUTE_UNUSED, asection *sec,
+     struct avr32_relax_data *rd, enum relax_state_id state,
+     Elf_Internal_Rela *rela)
+{
+  struct fragment *frag;
+  bfd_size_type r_size;
+  bfd_vma r_offset;
+  unsigned int i = rd->frag_count;
+
+  BFD_ASSERT(state >= RS_NONE && state < RS_MAX);
+
+  rd->frag_count++;
+  frag = bfd_realloc(rd->frag, sizeof(struct fragment) * rd->frag_count);
+  if (!frag)
+    return NULL;
+  rd->frag = frag;
+
+  frag += i;
+  memset(frag, 0, sizeof(struct fragment));
+
+  if (state == RS_ALIGN)
+    r_size = (((rela->r_offset + (1 << rela->r_addend) - 1)
+           & ~((1 << rela->r_addend) - 1)) - rela->r_offset);
+  else
+    r_size = relax_state[state].size;
+
+  if (rela)
+    r_offset = rela->r_offset;
+  else
+    r_offset = sec->size;
+
+  if (i == 0)
+    {
+      frag->offset = 0;
+      frag->size = r_offset + r_size;
+    }
+  else
+    {
+      frag->offset = rd->frag[i - 1].offset + rd->frag[i - 1].size;
+      frag->size = r_offset + r_size - frag->offset;
+    }
+
+  if (state != RS_CPENT)
+    /* Make sure we don't discard this frag */
+    frag->refcount = 1;
+
+  frag->initial_state = frag->state = state;
+  frag->rela = rela;
+
+  return frag;
+}
+
+static struct fragment *
+find_frag(asection *sec, bfd_vma offset)
+{
+  struct fragment *first, *last;
+  struct avr32_relax_data *rd = avr32_relax_data(sec);
+
+  if (rd->frag_count == 0)
+    return NULL;
+
+  first = &rd->frag[0];
+  last = &rd->frag[rd->frag_count - 1];
+
+  /* This may be a reloc referencing the end of a section.  The last
+     frag will never have a reloc associated with it, so its size will
+     never change, thus the offset adjustment of the last frag will
+     always be the same as the offset adjustment of the end of the
+     section.  */
+  if (offset == sec->size)
+    {
+      BFD_ASSERT(last->offset + last->size == sec->size);
+      BFD_ASSERT(!last->rela);
+      return last;
+    }
+
+  while (first <= last)
+    {
+      struct fragment *mid;
+
+      mid = (last - first) / 2 + first;
+      if ((mid->offset + mid->size) <= offset)
+    first = mid + 1;
+      else if (mid->offset > offset)
+    last = mid - 1;
+      else
+    return mid;
+    }
+
+  return NULL;
+}
+
+/* Look through all relocs in a section and determine if any relocs
+   may be affected by relaxation in other sections.  If so, allocate
+   an array of additional relocation data which links the affected
+   relocations to the frag(s) where the relaxation may occur.
+
+   This function also links cpool references to cpool entries and
+   increments the refcount of the latter when this happens.  */
+
+static bfd_boolean
+allocate_reloc_data(bfd *abfd, asection *sec, Elf_Internal_Rela *relocs,
+            struct bfd_link_info *info)
+{
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Sym *isymbuf = NULL;
+  struct avr32_relax_data *rd;
+  unsigned int i;
+  bfd_boolean ret = FALSE;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  rd = avr32_relax_data(sec);
+
+  RDBG("%s<%s>: allocate_reloc_data\n", abfd->filename, sec->name);
+
+  for (i = 0; i < sec->reloc_count; i++)
+    {
+      Elf_Internal_Rela *rel = &relocs[i];
+      asection *sym_sec;
+      unsigned long r_symndx;
+      bfd_vma sym_value;
+
+      if (!rel->r_addend && ELF_R_TYPE(rel->r_info) != R_AVR32_DIFF32
+      && !reloc_is_cpool_ref(rel))
+    continue;
+
+      r_symndx = ELF_R_SYM(rel->r_info);
+
+      if (r_symndx < symtab_hdr->sh_info)
+    {
+      Elf_Internal_Sym *isym;
+
+      if (!isymbuf)
+        isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+      if (!isymbuf)
+        return FALSE;
+
+      isym = &isymbuf[r_symndx];
+      sym_sec = bfd_section_from_elf_index(abfd, isym->st_shndx);
+      sym_value = isym->st_value;
+    }
+      else
+    {
+      struct elf_link_hash_entry *h;
+
+      h = elf_sym_hashes(abfd)[r_symndx - symtab_hdr->sh_info];
+
+      while (h->root.type == bfd_link_hash_indirect
+         || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+      if (h->root.type != bfd_link_hash_defined
+          && h->root.type != bfd_link_hash_defweak)
+        continue;
+
+      sym_sec = h->root.u.def.section;
+      sym_value = h->root.u.def.value;
+    }
+
+      if (sym_sec && avr32_relax_data(sym_sec)->is_relaxable)
+    {
+      bfd_size_type size;
+      struct fragment *frag;
+
+      if (!rd->reloc_data)
+        {
+          size = sizeof(struct avr32_reloc_data) * sec->reloc_count;
+          rd->reloc_data = bfd_zalloc(abfd, size);
+          if (!rd->reloc_data)
+        goto out;
+        }
+
+      RDBG("[%3d] 0x%04lx: target: 0x%lx + 0x%lx",
+           i, rel->r_offset, sym_value, rel->r_addend);
+
+      frag = find_frag(sym_sec, sym_value + rel->r_addend);
+      BFD_ASSERT(frag);
+      rd->reloc_data[i].add_frag = frag;
+
+      RDBG(" -> %s<%s>:%04lx\n", sym_sec->owner->filename, sym_sec->name,
+           frag->rela ? frag->rela->r_offset : sym_sec->size);
+
+      if (reloc_is_cpool_ref(rel))
+        {
+          BFD_ASSERT(ELF_R_TYPE(frag->rela->r_info) == R_AVR32_32_CPENT);
+          frag->refcount++;
+        }
+
+      if (ELF_R_TYPE(rel->r_info) == R_AVR32_DIFF32)
+        {
+          bfd_byte *contents;
+          bfd_signed_vma diff;
+
+          contents = retrieve_contents(abfd, sec, info->keep_memory);
+          if (!contents)
+        goto out;
+
+          diff = bfd_get_signed_32(abfd, contents + rel->r_offset);
+          frag = find_frag(sym_sec, sym_value + rel->r_addend + diff);
+          BFD_ASSERT(frag);
+          rd->reloc_data[i].sub_frag = frag;
+
+          release_contents(sec, contents);
+        }
+    }
+    }
+
+  ret = TRUE;
+
+ out:
+  release_local_syms(abfd, isymbuf);
+  return ret;
+}
+
+static bfd_boolean
+global_sym_set_frag(struct elf_avr32_link_hash_entry *havr,
+            struct bfd_link_info *info ATTRIBUTE_UNUSED)
+{
+  struct fragment *frag;
+  asection *sec;
+
+  if (havr->root.root.type != bfd_link_hash_defined
+      && havr->root.root.type != bfd_link_hash_defweak)
+    return TRUE;
+
+  sec = havr->root.root.u.def.section;
+  if (bfd_is_const_section(sec)
+      || !avr32_relax_data(sec)->is_relaxable)
+    return TRUE;
+
+  frag = find_frag(sec, havr->root.root.u.def.value);
+  if (!frag)
+    {
+      unsigned int i;
+      struct avr32_relax_data *rd = avr32_relax_data(sec);
+
+      RDBG("In %s: No frag for %s <%s+%lu> (limit %lu)\n",
+       sec->owner->filename, havr->root.root.root.string,
+       sec->name, havr->root.root.u.def.value, sec->size);
+      for (i = 0; i < rd->frag_count; i++)
+    RDBG("    %8lu - %8lu\n", rd->frag[i].offset,
+         rd->frag[i].offset + rd->frag[i].size);
+    }
+  BFD_ASSERT(frag);
+
+  havr->sym_frag = frag;
+  return TRUE;
+}
+
+static bfd_boolean
+analyze_relocations(struct bfd_link_info *info)
+{
+  bfd *abfd;
+  asection *sec;
+
+  /* Divide all relaxable sections into fragments */
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    {
+      if (!(elf_elfheader(abfd)->e_flags & EF_AVR32_LINKRELAX))
+    {
+      if (!(*info->callbacks->warning)
+          (info, _("input is not relaxable"), NULL, abfd, NULL, 0))
+        return FALSE;
+      continue;
+    }
+
+      for (sec = abfd->sections; sec; sec = sec->next)
+    {
+      struct avr32_relax_data *rd;
+      struct fragment *frag;
+      Elf_Internal_Rela *relocs;
+      unsigned int i;
+      bfd_boolean ret = TRUE;
+
+      if (!(sec->flags & SEC_RELOC) || sec->reloc_count == 0)
+        continue;
+
+      rd = avr32_relax_data(sec);
+
+      relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+      if (!relocs)
+        return FALSE;
+
+      qsort(relocs, sec->reloc_count, sizeof(Elf_Internal_Rela),
+        internal_reloc_compare);
+
+      for (i = 0; i < sec->reloc_count; i++)
+        {
+          enum relax_state_id state;
+
+          ret = FALSE;
+          state = get_initial_relax_state(abfd, sec, info, &relocs[i]);
+          if (state == RS_ERROR)
+        break;
+
+          if (state)
+        {
+          frag = new_frag(abfd, sec, rd, state, &relocs[i]);
+          if (!frag)
+            break;
+
+          pin_internal_relocs(sec, relocs);
+          rd->is_relaxable = TRUE;
+        }
+
+          ret = TRUE;
+        }
+
+      release_internal_relocs(sec, relocs);
+      if (!ret)
+        return ret;
+
+      if (rd->is_relaxable)
+        {
+          frag = new_frag(abfd, sec, rd, RS_NONE, NULL);
+          if (!frag)
+        return FALSE;
+        }
+    }
+    }
+
+  /* Link each global symbol to the fragment where it's defined.  */
+  elf_link_hash_traverse(elf_hash_table(info), global_sym_set_frag, info);
+
+  /* Do the same for local symbols. */
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    {
+      Elf_Internal_Sym *isymbuf, *isym;
+      struct fragment **local_sym_frag;
+      unsigned int i, sym_count;
+
+      sym_count = elf_tdata(abfd)->symtab_hdr.sh_info;
+      if (sym_count == 0)
+    continue;
+
+      local_sym_frag = bfd_zalloc(abfd, sym_count * sizeof(struct fragment *));
+      if (!local_sym_frag)
+    return FALSE;
+      elf_tdata(abfd)->local_sym_frag = local_sym_frag;
+
+      isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+      if (!isymbuf)
+    return FALSE;
+
+      for (i = 0; i < sym_count; i++)
+    {
+      struct avr32_relax_data *rd;
+      struct fragment *frag;
+      asection *sec;
+
+      isym = &isymbuf[i];
+
+      sec = bfd_section_from_elf_index(abfd, isym->st_shndx);
+      if (!sec)
+        continue;
+
+      rd = avr32_relax_data(sec);
+      if (!rd->is_relaxable)
+        continue;
+
+      frag = find_frag(sec, isym->st_value);
+      BFD_ASSERT(frag);
+
+      local_sym_frag[i] = frag;
+    }
+
+      release_local_syms(abfd, isymbuf);
+    }
+
+  /* And again for relocs with addends and constant pool references */
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    for (sec = abfd->sections; sec; sec = sec->next)
+      {
+    Elf_Internal_Rela *relocs;
+    bfd_boolean ret;
+
+    if (!(sec->flags & SEC_RELOC) || sec->reloc_count == 0)
+      continue;
+
+    relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+    if (!relocs)
+      return FALSE;
+
+    ret = allocate_reloc_data(abfd, sec, relocs, info);
+
+    release_internal_relocs(sec, relocs);
+    if (ret == FALSE)
+      return ret;
+      }
+
+  return TRUE;
+}
+
+static bfd_boolean
+rs_is_good_enough(const struct relax_state *rs, struct fragment *frag,
+          bfd_vma symval, bfd_vma addr, struct got_entry *got,
+          struct avr32_reloc_data *ind_data,
+          bfd_signed_vma offset_adjust)
+{
+  bfd_signed_vma target = 0;
+
+  switch (rs->reftype)
+    {
+    case REF_ABSOLUTE:
+      target = symval;
+      break;
+    case REF_PCREL:
+      target = symval - addr;
+      break;
+    case REF_CPOOL:
+      /* cpool frags are always in the same section and always after
+     all frags referring to it.  So it's always correct to add in
+     offset_adjust here.  */
+      target = (ind_data->add_frag->offset + ind_data->add_frag->offset_adjust
+        + offset_adjust - frag->offset - frag->offset_adjust);
+      break;
+    case REF_GOT:
+      target = got->offset;
+      break;
+    default:
+      abort();
+    }
+
+  if (target >= rs->range_min && target <= rs->range_max)
+    return TRUE;
+  else
+    return FALSE;
+}
+
+static bfd_boolean
+avr32_size_frags(bfd *abfd, asection *sec, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct avr32_relax_data *rd;
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *relocs = NULL;
+  Elf_Internal_Sym *isymbuf = NULL;
+  struct got_entry **local_got_ents;
+  struct fragment **local_sym_frag;
+  bfd_boolean ret = FALSE;
+  bfd_signed_vma delta = 0;
+  unsigned int i;
+
+  htab = avr32_elf_hash_table(info);
+  rd = avr32_relax_data(sec);
+
+  if (sec == htab->sgot)
+    {
+      RDBG("Relaxing GOT section (vma: 0x%lx)\n",
+       sec->output_section->vma + sec->output_offset);
+      if (assign_got_offsets(htab))
+    htab->repeat_pass = TRUE;
+      return TRUE;
+    }
+
+  if (!rd->is_relaxable)
+    return TRUE;
+
+  if (!sec->rawsize)
+    sec->rawsize = sec->size;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+  relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+  if (!relocs)
+    goto out;
+
+  isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+  if (!isymbuf)
+    goto out;
+
+  local_got_ents = elf_local_got_ents(abfd);
+  local_sym_frag = elf_tdata(abfd)->local_sym_frag;
+
+  RDBG("size_frags: %s<%s>\n  vma: 0x%08lx, size: 0x%08lx\n",
+       abfd->filename, sec->name,
+       sec->output_section->vma + sec->output_offset, sec->size);
+
+  for (i = 0; i < rd->frag_count; i++)
+    {
+      struct fragment *frag = &rd->frag[i];
+      struct avr32_reloc_data *r_data = NULL, *ind_data = NULL;
+      const struct relax_state *state, *next_state;
+      struct fragment *target_frag = NULL;
+      asection *sym_sec = NULL;
+      Elf_Internal_Rela *rela;
+      struct got_entry *got;
+      bfd_vma symval, r_offset, addend, addr;
+      bfd_signed_vma size_adjust = 0, distance;
+      unsigned long r_symndx;
+      bfd_boolean defined = TRUE, dynamic = FALSE;
+      unsigned char sym_type;
+
+      frag->offset_adjust += delta;
+      state = next_state = &relax_state[frag->state];
+      rela = frag->rela;
+
+      BFD_ASSERT(state->id == frag->state);
+
+      RDBG("  0x%04lx%c%d: %s [size %ld]", rela ? rela->r_offset : sec->rawsize,
+       (frag->offset_adjust < 0)?'-':'+',
+       abs(frag->offset_adjust), state->name, state->size);
+
+      if (!rela)
+    {
+      RDBG(": no reloc, ignoring\n");
+      continue;
+    }
+
+      BFD_ASSERT((unsigned int)(rela - relocs) < sec->reloc_count);
+      BFD_ASSERT(state != RS_NONE);
+
+      r_offset = rela->r_offset + frag->offset_adjust;
+      addr = sec->output_section->vma + sec->output_offset + r_offset;
+
+      switch (frag->state)
+    {
+    case RS_ALIGN:
+      size_adjust = ((addr + (1 << rela->r_addend) - 1)
+             & ~((1 << rela->r_addend) - 1));
+      size_adjust -= (sec->output_section->vma + sec->output_offset
+              + frag->offset + frag->offset_adjust
+              + frag->size + frag->size_adjust);
+
+      RDBG(": adjusting size %lu -> %lu\n", frag->size + frag->size_adjust,
+           frag->size + frag->size_adjust + size_adjust);
+      break;
+
+    case RS_CPENT:
+      if (frag->refcount == 0 && frag->size_adjust == 0)
+        {
+          RDBG(": discarding frag\n");
+          size_adjust = -4;
+        }
+      else if (frag->refcount > 0 && frag->size_adjust < 0)
+        {
+          RDBG(": un-discarding frag\n");
+          size_adjust = 4;
+        }
+      break;
+
+    default:
+      if (rd->reloc_data)
+        r_data = &rd->reloc_data[frag->rela - relocs];
+
+      /* If this is a cpool reference, we want the symbol that the
+         cpool entry refers to, not the symbol for the cpool entry
+         itself, as we already know what frag it's in.  */
+      if (relax_state[frag->initial_state].reftype == REF_CPOOL)
+        {
+          Elf_Internal_Rela *irela = r_data->add_frag->rela;
+
+          r_symndx = ELF_R_SYM(irela->r_info);
+          addend = irela->r_addend;
+
+          /* The constant pool must be in the same section as the
+         reloc referring to it.  */
+          BFD_ASSERT((unsigned long)(irela - relocs) < sec->reloc_count);
+
+          ind_data = r_data;
+          r_data = &rd->reloc_data[irela - relocs];
+        }
+      else
+        {
+          r_symndx = ELF_R_SYM(rela->r_info);
+          addend = rela->r_addend;
+        }
+
+      /* Get the value of the symbol referred to by the reloc.  */
+      if (r_symndx < symtab_hdr->sh_info)
+        {
+          Elf_Internal_Sym *isym;
+
+          isym = isymbuf + r_symndx;
+          symval = 0;
+
+          RDBG(" local sym %lu: ", r_symndx);
+
+          if (isym->st_shndx == SHN_UNDEF)
+        defined = FALSE;
+          else if (isym->st_shndx == SHN_ABS)
+        sym_sec = bfd_abs_section_ptr;
+          else if (isym->st_shndx == SHN_COMMON)
+        sym_sec = bfd_com_section_ptr;
+          else
+        sym_sec = bfd_section_from_elf_index(abfd, isym->st_shndx);
+
+          symval = isym->st_value;
+          sym_type = ELF_ST_TYPE(isym->st_info);
+          target_frag = local_sym_frag[r_symndx];
+
+          if (local_got_ents)
+        got = local_got_ents[r_symndx];
+          else
+        got = NULL;
+        }
+      else
+        {
+          /* Global symbol */
+          unsigned long index;
+          struct elf_link_hash_entry *h;
+          struct elf_avr32_link_hash_entry *havr;
+
+          index = r_symndx - symtab_hdr->sh_info;
+          h = elf_sym_hashes(abfd)[index];
+          BFD_ASSERT(h != NULL);
+
+          while (h->root.type == bfd_link_hash_indirect
+             || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+          havr = (struct elf_avr32_link_hash_entry *)h;
+          got = h->got.glist;
+
+          symval = 0;
+
+          RDBG(" %s: ", h->root.root.string);
+
+          if (h->root.type != bfd_link_hash_defined
+          && h->root.type != bfd_link_hash_defweak)
+        {
+          RDBG("(undef)");
+          defined = FALSE;
+        }
+          else if ((info->shared && !info->symbolic && h->dynindx != -1)
+               || (htab->root.dynamic_sections_created
+               && h->def_dynamic && !h->def_regular))
+        {
+          RDBG("(dynamic)");
+          dynamic = TRUE;
+          sym_sec = h->root.u.def.section;
+        }
+          else
+        {
+          sym_sec = h->root.u.def.section;
+          symval = h->root.u.def.value;
+          target_frag = havr->sym_frag;
+        }
+
+          sym_type = h->type;
+        }
+
+      /* Thanks to elf32-ppc for this one.  */
+      if (sym_sec && sym_sec->sec_info_type == ELF_INFO_TYPE_MERGE)
+        {
+          /* At this stage in linking, no SEC_MERGE symbol has been
+         adjusted, so all references to such symbols need to be
+         passed through _bfd_merged_section_offset.  (Later, in
+         relocate_section, all SEC_MERGE symbols *except* for
+         section symbols have been adjusted.)
+
+             SEC_MERGE sections are not relaxed by us, as they
+             shouldn't contain any code.  */
+
+          BFD_ASSERT(!target_frag && !(r_data && r_data->add_frag));
+
+          /* gas may reduce relocations against symbols in SEC_MERGE
+         sections to a relocation against the section symbol when
+         the original addend was zero.  When the reloc is against
+         a section symbol we should include the addend in the
+         offset passed to _bfd_merged_section_offset, since the
+         location of interest is the original symbol.  On the
+         other hand, an access to "sym+addend" where "sym" is not
+         a section symbol should not include the addend;  Such an
+         access is presumed to be an offset from "sym";  The
+         location of interest is just "sym".  */
+          RDBG("\n    MERGE: %s: 0x%lx+0x%lx+0x%lx -> ",
+           (sym_type == STT_SECTION)?"section":"not section",
+           sym_sec->output_section->vma + sym_sec->output_offset,
+           symval, addend);
+
+          if (sym_type == STT_SECTION)
+        symval += addend;
+
+          symval = (_bfd_merged_section_offset
+            (abfd, &sym_sec,
+             elf_section_data(sym_sec)->sec_info, symval));
+
+          if (sym_type != STT_SECTION)
+        symval += addend;
+        }
+      else
+        symval += addend;
+
+      if (defined && !dynamic)
+        {
+          RDBG("0x%lx+0x%lx",
+           sym_sec->output_section->vma + sym_sec->output_offset,
+           symval);
+          symval += sym_sec->output_section->vma + sym_sec->output_offset;
+        }
+
+      if (r_data && r_data->add_frag)
+        /* If the add_frag pointer is set, it means that this reloc
+           has an addend that may be affected by relaxation.  */
+        target_frag = r_data->add_frag;
+
+      if (target_frag)
+        {
+          symval += target_frag->offset_adjust;
+
+          /* If target_frag comes after this frag in the same
+         section, we should assume that it will be moved by
+         the same amount we are.  */
+          if ((target_frag - rd->frag) < (int)rd->frag_count
+          && target_frag > frag)
+        symval += delta;
+        }
+
+      distance = symval - addr;
+
+      /* First, try to make a direct reference.  If the symbol is
+         dynamic or undefined, we must take care not to change its
+         reference type, that is, we can't make it direct.
+
+         Also, it seems like some sections may actually be resized
+         after the relaxation code is done, so we can't really
+         trust that our "distance" is correct.  There's really no
+         easy solution to this problem, so we'll just disallow
+         direct references to SEC_DATA sections.
+         
+         Oh, and .bss isn't actually SEC_DATA, so we disallow
+         !SEC_HAS_CONTENTS as well. */
+      if (!dynamic && defined
+          && (htab->direct_data_refs
+          || (!(sym_sec->flags & SEC_DATA)
+              && (sym_sec->flags & SEC_HAS_CONTENTS)))
+          && next_state->direct)
+        {
+          next_state = &relax_state[next_state->direct];
+          RDBG(" D-> %s", next_state->name);
+        }
+
+      /* Iterate backwards until we find a state that fits.  */
+      while (next_state->prev
+         && !rs_is_good_enough(next_state, frag, symval, addr,
+                       got, ind_data, delta))
+        {
+          next_state = &relax_state[next_state->prev];
+          RDBG(" P-> %s", next_state->name);
+        }
+
+      /* Then try to find the best possible state.  */
+      while (next_state->next)
+        {
+          const struct relax_state *candidate;
+
+          candidate = &relax_state[next_state->next];
+          if (!rs_is_good_enough(candidate, frag, symval, addr, got,
+                     ind_data, delta))
+        break;
+
+          next_state = candidate;
+          RDBG(" N-> %s", next_state->name);
+        }
+
+      RDBG(" [size %ld]\n", next_state->size);
+
+      BFD_ASSERT(next_state->id);
+      BFD_ASSERT(!dynamic || next_state->reftype == REF_GOT);
+
+      size_adjust = next_state->size - state->size;
+
+      /* There's a theoretical possibility that shrinking one frag
+         may cause another to grow, which may cause the first one to
+         grow as well, and we're back where we started.  Avoid this
+         scenario by disallowing a frag that has grown to ever
+         shrink again.  */
+      if (state->reftype == REF_GOT && next_state->reftype != REF_GOT)
+        {
+          if (frag->has_grown)
+        next_state = state;
+          else
+        unref_got_entry(htab, got);
+        }
+      else if (state->reftype != REF_GOT && next_state->reftype == REF_GOT)
+        {
+          ref_got_entry(htab, got);
+          frag->has_grown = TRUE;
+        }
+      else if (state->reftype == REF_CPOOL
+           && next_state->reftype != REF_CPOOL)
+        {
+          if (frag->has_grown)
+        next_state = state;
+          else
+        ind_data->add_frag->refcount--;
+        }
+      else if (state->reftype != REF_CPOOL
+           && next_state->reftype == REF_CPOOL)
+        {
+          ind_data->add_frag->refcount++;
+          frag->has_grown = TRUE;
+        }
+      else
+        {
+          if (frag->has_grown && size_adjust < 0)
+        next_state = state;
+          else if (size_adjust > 0)
+        frag->has_grown = TRUE;
+        }
+
+      size_adjust = next_state->size - state->size;
+      frag->state = next_state->id;
+
+      break;
+    }
+
+      if (size_adjust)
+    htab->repeat_pass = TRUE;
+
+      frag->size_adjust += size_adjust;
+      sec->size += size_adjust;
+      delta += size_adjust;
+
+      BFD_ASSERT((frag->offset + frag->offset_adjust
+          + frag->size + frag->size_adjust)
+         == (frag[1].offset + frag[1].offset_adjust + delta));
+    }
+
+  ret = TRUE;
+
+ out:
+  release_local_syms(abfd, isymbuf);
+  release_internal_relocs(sec, relocs);
+  return ret;
+}
+
+static bfd_boolean
+adjust_global_symbol(struct elf_avr32_link_hash_entry *havr,
+             struct bfd_link_info *info ATTRIBUTE_UNUSED)
+{
+  struct elf_link_hash_entry *h = &havr->root;
+
+  if (havr->sym_frag && (h->root.type == bfd_link_hash_defined
+             || h->root.type == bfd_link_hash_defweak))
+    {
+      RDBG("adjust_global_symbol: %s 0x%08lx -> 0x%08lx\n",
+       h->root.root.string, h->root.u.def.value,
+       h->root.u.def.value + havr->sym_frag->offset_adjust);
+      h->root.u.def.value += havr->sym_frag->offset_adjust;
+    }
+  return TRUE;
+}
+
+static bfd_boolean
+adjust_syms(struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  bfd *abfd;
+
+  htab = avr32_elf_hash_table(info);
+  elf_link_hash_traverse(&htab->root, adjust_global_symbol, info);
+
+  for (abfd = info->input_bfds; abfd; abfd = abfd->link_next)
+    {
+      Elf_Internal_Sym *isymbuf;
+      struct fragment **local_sym_frag, *frag;
+      unsigned int i, sym_count;
+
+      sym_count = elf_tdata(abfd)->symtab_hdr.sh_info;
+      if (sym_count == 0)
+    continue;
+
+      isymbuf = retrieve_local_syms(abfd, info->keep_memory);
+      if (!isymbuf)
+    return FALSE;
+
+      local_sym_frag = elf_tdata(abfd)->local_sym_frag;
+
+      for (i = 0; i < sym_count; i++)
+    {
+      frag = local_sym_frag[i];
+      if (frag)
+        {
+          RDBG("adjust_local_symbol: %s[%u] 0x%08lx -> 0x%08lx\n",
+           abfd->filename, i, isymbuf[i].st_value,
+           isymbuf[i].st_value + frag->offset_adjust);
+          isymbuf[i].st_value += frag->offset_adjust;
+        }
+    }
+
+      release_local_syms(abfd, isymbuf);
+    }
+
+  htab->symbols_adjusted = TRUE;
+  return TRUE;
+}
+
+static bfd_boolean
+adjust_relocs(bfd *abfd, asection *sec, struct bfd_link_info *info)
+{
+  struct avr32_relax_data *rd;
+  Elf_Internal_Rela *relocs;
+  Elf_Internal_Shdr *symtab_hdr;
+  unsigned int i;
+  bfd_boolean ret = FALSE;
+
+  rd = avr32_relax_data(sec);
+  if (!rd->reloc_data)
+    return TRUE;
+
+  RDBG("adjust_relocs: %s<%s> (count: %u)\n", abfd->filename, sec->name,
+       sec->reloc_count);
+
+  relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+  if (!relocs)
+    return FALSE;
+
+  symtab_hdr = &elf_tdata(abfd)->symtab_hdr;
+
+  for (i = 0; i < sec->reloc_count; i++)
+    {
+      Elf_Internal_Rela *rela = &relocs[i];
+      struct avr32_reloc_data *r_data = &rd->reloc_data[i];
+      struct fragment *sym_frag;
+      unsigned long r_symndx;
+
+      if (r_data->add_frag)
+    {
+      r_symndx = ELF_R_SYM(rela->r_info);
+
+      if (r_symndx < symtab_hdr->sh_info)
+        sym_frag = elf_tdata(abfd)->local_sym_frag[r_symndx];
+      else
+        {
+          struct elf_link_hash_entry *h;
+
+          h = elf_sym_hashes(abfd)[r_symndx - symtab_hdr->sh_info];
+
+          while (h->root.type == bfd_link_hash_indirect
+             || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+          BFD_ASSERT(h->root.type == bfd_link_hash_defined
+             || h->root.type == bfd_link_hash_defweak);
+
+          sym_frag = ((struct elf_avr32_link_hash_entry *)h)->sym_frag;
+        }
+
+      RDBG("    addend: 0x%08lx -> 0x%08lx\n",
+           rela->r_addend,
+           rela->r_addend + r_data->add_frag->offset_adjust
+           - (sym_frag ? sym_frag->offset_adjust : 0));
+
+      /* If this is against a section symbol, we won't find any
+         sym_frag, so we'll just adjust the addend.  */
+      rela->r_addend += r_data->add_frag->offset_adjust;
+      if (sym_frag)
+        rela->r_addend -= sym_frag->offset_adjust;
+
+      if (r_data->sub_frag)
+        {
+          bfd_byte *contents;
+          bfd_signed_vma diff;
+
+          contents = retrieve_contents(abfd, sec, info->keep_memory);
+          if (!contents)
+        goto out;
+
+          /* I realize now that sub_frag is misnamed.  It's
+         actually add_frag which is subtracted in this
+         case...  */
+          diff = bfd_get_signed_32(abfd, contents + rela->r_offset);
+          diff += (r_data->sub_frag->offset_adjust
+               - r_data->add_frag->offset_adjust);
+          bfd_put_32(abfd, diff, contents + rela->r_offset);
+
+          RDBG("   0x%lx: DIFF32 updated: 0x%lx\n", rela->r_offset, diff);
+
+          release_contents(sec, contents);
+        }
+    }
+      else
+    BFD_ASSERT(!r_data->sub_frag);
+    }
+
+  ret = TRUE;
+
+ out:
+  release_internal_relocs(sec, relocs);
+  return ret;
+}
+
+static bfd_boolean
+avr32_move_data(bfd *abfd, asection *sec, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct avr32_relax_data *rd;
+  struct fragment *frag, *fragend;
+  Elf_Internal_Rela *relocs = NULL;
+  bfd_byte *contents = NULL;
+  unsigned int i;
+  bfd_boolean ret = FALSE;
+
+  htab = avr32_elf_hash_table(info);
+  rd = avr32_relax_data(sec);
+
+  if (!htab->symbols_adjusted)
+    if (!adjust_syms(info))
+      return FALSE;
+
+  if (rd->is_relaxable)
+    {
+      /* Resize the section first, so that we can be sure that enough
+     memory is allocated in case the section has grown.  */
+      if (sec->size > sec->rawsize
+      && elf_section_data(sec)->this_hdr.contents)
+    {
+      /* We must not use cached data if the section has grown.  */
+      free(elf_section_data(sec)->this_hdr.contents);
+      elf_section_data(sec)->this_hdr.contents = NULL;
+    }
+
+      relocs = retrieve_internal_relocs(abfd, sec, info->keep_memory);
+      if (!relocs)
+    goto out;
+      contents = retrieve_contents(abfd, sec, info->keep_memory);
+      if (!contents)
+    goto out;
+
+      fragend = rd->frag + rd->frag_count;
+
+      RDBG("move_data: %s<%s>: relocs=%p, contents=%p\n",
+       abfd->filename, sec->name, relocs, contents);
+
+      /* First, move the data into place. We must take care to move
+     frags in the right order so that we don't accidentally
+     overwrite parts of the next frag.  */
+      for (frag = rd->frag; frag < fragend; frag++)
+    {
+      RDBG("    0x%08lx%c0x%x: size 0x%lx%c0x%x\n",
+           frag->offset, frag->offset_adjust >= 0 ? '+' : '-',
+           abs(frag->offset_adjust),
+           frag->size, frag->size_adjust >= 0 ? '+' : '-',
+           abs(frag->size_adjust));
+      if (frag->offset_adjust > 0)
+        {
+          struct fragment *prev = frag - 1;
+          struct fragment *last;
+
+          for (last = frag; last < fragend && last->offset_adjust > 0;
+           last++) ;
+
+          if (last == fragend)
+        last--;
+
+          for (frag = last; frag != prev; frag--)
+        {
+          if (frag->offset_adjust
+              && frag->size + frag->size_adjust > 0)
+            {
+              RDBG("memmove 0x%lx -> 0x%lx (size %lu)\n",
+               frag->offset, frag->offset + frag->offset_adjust,
+               frag->size + frag->size_adjust);
+              memmove(contents + frag->offset + frag->offset_adjust,
+                  contents + frag->offset,
+                  frag->size + frag->size_adjust);
+            }
+        }
+          frag = last;
+        }
+      else if (frag->offset_adjust && frag->size + frag->size_adjust > 0)
+        {
+          RDBG("memmove 0x%lx -> 0x%lx (size %lu)\n",
+           frag->offset, frag->offset + frag->offset_adjust,
+           frag->size + frag->size_adjust);
+          memmove(contents + frag->offset + frag->offset_adjust,
+              contents + frag->offset,
+              frag->size + frag->size_adjust);
+        }
+    }
+
+      i = 0;
+
+      for (frag = rd->frag; frag < fragend; frag++)
+    {
+      const struct relax_state *state, *istate;
+      struct avr32_reloc_data *r_data = NULL;
+
+      istate = &relax_state[frag->initial_state];
+      state = &relax_state[frag->state];
+
+      if (rd->reloc_data)
+        r_data = &rd->reloc_data[frag->rela - relocs];
+
+      BFD_ASSERT((long)(frag->size + frag->size_adjust) >= 0);
+      BFD_ASSERT(state->reftype != REF_CPOOL
+             || r_data->add_frag->refcount > 0);
+
+      if (istate->reftype == REF_CPOOL && state->reftype != REF_CPOOL)
+        {
+          struct fragment *ifrag;
+
+          /* An indirect reference through the cpool has been
+         converted to a direct reference.  We must update the
+         reloc to point to the symbol itself instead of the
+         constant pool entry.  The reloc type will be updated
+         later.  */
+          ifrag = r_data->add_frag;
+          frag->rela->r_info = ifrag->rela->r_info;
+          frag->rela->r_addend = ifrag->rela->r_addend;
+
+          /* Copy the reloc data so the addend will be adjusted
+         correctly later.  */
+          *r_data = rd->reloc_data[ifrag->rela - relocs];
+        }
+
+      /* Move all relocs covered by this frag.  */
+      if (frag->rela)
+        BFD_ASSERT(&relocs[i] <= frag->rela);
+      else
+        BFD_ASSERT((frag + 1) == fragend && frag->state == RS_NONE);
+
+      if (frag == rd->frag)
+        BFD_ASSERT(i == 0);
+      else
+        BFD_ASSERT(&relocs[i] > frag[-1].rela);
+
+      /* If non-null, frag->rela is the last relocation in the
+         fragment.  frag->rela can only be null in the last
+         fragment, so in that case, we'll just do the rest.  */
+      for (; (i < sec->reloc_count
+          && (!frag->rela || &relocs[i] <= frag->rela)); i++)
+        {
+          RDBG("[%4u] r_offset 0x%08lx -> 0x%08lx\n", i, relocs[i].r_offset,
+           relocs[i].r_offset + frag->offset_adjust);
+          relocs[i].r_offset += frag->offset_adjust;
+        }
+
+      if (frag->refcount == 0)
+        {
+          /* If this frag is to be discarded, make sure we won't
+         relocate it later on.  */
+          BFD_ASSERT(frag->state == RS_CPENT);
+          frag->rela->r_info = ELF_R_INFO(ELF_R_SYM(frag->rela->r_info),
+                        R_AVR32_NONE);
+        }
+      else if (frag->state == RS_ALIGN)
+        {
+          bfd_vma addr, addr_end;
+
+          addr = frag->rela->r_offset;
+          addr_end = (frag->offset + frag->offset_adjust
+              + frag->size + frag->size_adjust);
+
+          /* If the section is executable, insert NOPs.
+         Otherwise, insert zeroes.  */
+          if (sec->flags & SEC_CODE)
+        {
+          if (addr & 1)
+            {
+              bfd_put_8(abfd, 0, contents + addr);
+              addr++;
+            }
+
+          BFD_ASSERT(!((addr_end - addr) & 1));
+
+          while (addr < addr_end)
+            {
+              bfd_put_16(abfd, NOP_OPCODE, contents + addr);
+              addr += 2;
+            }
+        }
+          else
+        memset(contents + addr, 0, addr_end - addr);
+        }
+      else if (state->opcode_mask)
+        {
+          bfd_vma insn;
+
+          /* Update the opcode and the relocation type unless it's a
+         "special" relax state (i.e. RS_NONE, RS_ALIGN or
+         RS_CPENT.), in which case the opcode mask is zero.  */
+          insn = bfd_get_32(abfd, contents + frag->rela->r_offset);
+          insn &= ~state->opcode_mask;
+          insn |= state->opcode;
+          RDBG("    0x%lx: inserting insn %08lx\n",
+           frag->rela->r_offset, insn);
+          bfd_put_32(abfd, insn, contents + frag->rela->r_offset);
+
+          frag->rela->r_info = ELF_R_INFO(ELF_R_SYM(frag->rela->r_info),
+                          state->r_type);
+        }
+
+      if ((frag + 1) == fragend)
+        BFD_ASSERT((frag->offset + frag->size + frag->offset_adjust
+            + frag->size_adjust) == sec->size);
+      else
+        BFD_ASSERT((frag->offset + frag->size + frag->offset_adjust
+            + frag->size_adjust)
+               == (frag[1].offset + frag[1].offset_adjust));
+    }
+    }
+
+  /* Adjust reloc addends and DIFF32 differences */
+  if (!adjust_relocs(abfd, sec, info))
+    return FALSE;
+
+  ret = TRUE;
+
+ out:
+  release_contents(sec, contents);
+  release_internal_relocs(sec, relocs);
+  return ret;
+}
+
+static bfd_boolean
+avr32_elf_relax_section(bfd *abfd, asection *sec,
+            struct bfd_link_info *info, bfd_boolean *again)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct avr32_relax_data *rd;
+
+  *again = FALSE;
+  if (info->relocatable)
+    return TRUE;
+
+  htab = avr32_elf_hash_table(info);
+  if ((!(sec->flags & SEC_RELOC) || sec->reloc_count == 0)
+      && sec != htab->sgot)
+    return TRUE;
+
+  if (!htab->relocations_analyzed)
+    {
+      if (!analyze_relocations(info))
+    return FALSE;
+      htab->relocations_analyzed = TRUE;
+    }
+
+  rd = avr32_relax_data(sec);
+
+  if (rd->iteration != htab->relax_iteration)
+    {
+      if (!htab->repeat_pass)
+    htab->relax_pass++;
+      htab->relax_iteration++;
+      htab->repeat_pass = FALSE;
+    }
+
+  rd->iteration++;
+
+  switch (htab->relax_pass)
+    {
+    case RELAX_PASS_SIZE_FRAGS:
+      if (!avr32_size_frags(abfd, sec, info))
+    return FALSE;
+      *again = TRUE;
+      break;
+    case RELAX_PASS_MOVE_DATA:
+      if (!avr32_move_data(abfd, sec, info))
+    return FALSE;
+      break;
+  }
+
+  return TRUE;
+}
+
+
+/* Relocation */
+
+static bfd_reloc_status_type
+avr32_check_reloc_value(asection *sec, Elf_Internal_Rela *rela,
+            bfd_signed_vma relocation, reloc_howto_type *howto);
+static bfd_reloc_status_type
+avr32_final_link_relocate(reloc_howto_type *howto, bfd *input_bfd,
+              asection *input_section, bfd_byte *contents,
+              Elf_Internal_Rela *rel, bfd_vma value);
+static bfd_boolean
+avr32_elf_relocate_section(bfd *output_bfd, struct bfd_link_info *info,
+               bfd *input_bfd, asection *input_section,
+               bfd_byte *contents, Elf_Internal_Rela *relocs,
+               Elf_Internal_Sym *local_syms,
+               asection **local_sections);
+
+
+#define symbol_address(symbol) \
+  symbol->value + symbol->section->output_section->vma \
+  + symbol->section->output_offset
+
+#define avr32_elf_insert_field(size, field, abfd, reloc_entry, data)    \
+  do                                    \
+    {                                   \
+      unsigned long x;                          \
+      x = bfd_get_##size (abfd, data + reloc_entry->address);       \
+      x &= ~reloc_entry->howto->dst_mask;               \
+      x |= field & reloc_entry->howto->dst_mask;            \
+      bfd_put_##size (abfd, (bfd_vma) x, data + reloc_entry->address);  \
+    }                                   \
+  while(0)
+
+static bfd_reloc_status_type
+avr32_check_reloc_value(asection *sec ATTRIBUTE_UNUSED,
+            Elf_Internal_Rela *rela ATTRIBUTE_UNUSED,
+            bfd_signed_vma relocation,
+            reloc_howto_type *howto)
+{
+  bfd_vma reloc_u;
+
+  /* We take "complain_overflow_dont" to mean "don't complain on
+     alignment either". This way, we don't have to special-case
+     R_AVR32_HI16 */
+  if (howto->complain_on_overflow == complain_overflow_dont)
+    return bfd_reloc_ok;
+
+  /* Check if the value is correctly aligned */
+  if (relocation & ((1 << howto->rightshift) - 1))
+    {
+      RDBG("misaligned: %s<%s+%lx>: %s: 0x%lx (align %u)\n",
+       sec->owner->filename, sec->name, rela->r_offset,
+       howto->name, relocation, howto->rightshift);
+      return bfd_reloc_overflow;
+    }
+
+  /* Now, get rid of the unnecessary bits */
+  relocation >>= howto->rightshift;
+  reloc_u = (bfd_vma)relocation;
+
+  switch (howto->complain_on_overflow)
+    {
+    case complain_overflow_unsigned:
+    case complain_overflow_bitfield:
+      if (reloc_u > (unsigned long)((1 << howto->bitsize) - 1))
+    {
+      RDBG("unsigned overflow: %s<%s+%lx>: %s: 0x%lx (size %u)\n",
+           sec->owner->filename, sec->name, rela->r_offset,
+           howto->name, reloc_u, howto->bitsize);
+      RDBG("reloc vma: 0x%lx\n",
+           sec->output_section->vma + sec->output_offset + rela->r_offset);
+
+      return bfd_reloc_overflow;
+    }
+      break;
+    case complain_overflow_signed:
+      if (relocation > (1 << (howto->bitsize - 1)) - 1)
+    {
+      RDBG("signed overflow: %s<%s+%lx>: %s: 0x%lx (size %u)\n",
+           sec->owner->filename, sec->name, rela->r_offset,
+           howto->name, reloc_u, howto->bitsize);
+      RDBG("reloc vma: 0x%lx\n",
+           sec->output_section->vma + sec->output_offset + rela->r_offset);
+
+      return bfd_reloc_overflow;
+    }
+      if (relocation < -(1 << (howto->bitsize - 1)))
+    {
+      RDBG("signed overflow: %s<%s+%lx>: %s: -0x%lx (size %u)\n",
+           sec->owner->filename, sec->name, rela->r_offset,
+           howto->name, -relocation, howto->bitsize);
+      RDBG("reloc vma: 0x%lx\n",
+           sec->output_section->vma + sec->output_offset + rela->r_offset);
+
+      return bfd_reloc_overflow;
+    }
+      break;
+    default:
+      abort();
+    }
+
+  return bfd_reloc_ok;
+}
+
+
+static bfd_reloc_status_type
+avr32_final_link_relocate(reloc_howto_type *howto,
+              bfd *input_bfd,
+              asection *input_section,
+              bfd_byte *contents,
+              Elf_Internal_Rela *rel,
+              bfd_vma value)
+{
+  bfd_vma field;
+  bfd_vma relocation;
+  bfd_reloc_status_type status;
+  bfd_byte *p = contents + rel->r_offset;
+  unsigned long x;
+
+  pr_debug("  (6b) final link relocate\n");
+
+  /* Sanity check the address */
+  if (rel->r_offset > input_section->size)
+    {
+      (*_bfd_error_handler)
+    ("%B: %A+0x%lx: offset out of range (section size: 0x%lx)",
+     input_bfd, input_section, rel->r_offset, input_section->size);
+      return bfd_reloc_outofrange;
+    }
+
+  relocation = value + rel->r_addend;
+
+  if (howto->pc_relative)
+    {
+      bfd_vma addr;
+
+      addr = input_section->output_section->vma
+    + input_section->output_offset + rel->r_offset;
+      addr &= ~0UL << howto->rightshift;
+      relocation -= addr;
+    }
+
+  switch (ELF32_R_TYPE(rel->r_info))
+    {
+    case R_AVR32_16N_PCREL:
+      /* sub reg, pc, . - (sym + addend) */
+      relocation = -relocation;
+      break;
+    }
+
+  status = avr32_check_reloc_value(input_section, rel, relocation, howto);
+
+  relocation >>= howto->rightshift;
+  if (howto->bitsize == 21)
+    field = (relocation & 0xffff)
+      | ((relocation & 0x10000) << 4)
+      | ((relocation & 0x1e0000) << 8);
+  else if (howto->bitsize == 12)
+    field = (relocation & 0xff) | ((relocation & 0xf00) << 4);
+  else if (howto->bitsize == 10)
+    field = ((relocation & 0xff) << 4)
+      | ((relocation & 0x300) >> 8);
+  else
+    field = relocation << howto->bitpos;
+
+  switch (howto->size)
+    {
+    case 0:
+      x = bfd_get_8 (input_bfd, p);
+      x &= ~howto->dst_mask;
+      x |= field & howto->dst_mask;
+      bfd_put_8 (input_bfd, (bfd_vma) x, p);
+      break;
+    case 1:
+      x = bfd_get_16 (input_bfd, p);
+      x &= ~howto->dst_mask;
+      x |= field & howto->dst_mask;
+      bfd_put_16 (input_bfd, (bfd_vma) x, p);
+      break;
+    case 2:
+      x = bfd_get_32 (input_bfd, p);
+      x &= ~howto->dst_mask;
+      x |= field & howto->dst_mask;
+      bfd_put_32 (input_bfd, (bfd_vma) x, p);
+      break;
+    default:
+      abort();
+    }
+
+  return status;
+}
+
+/* (6) Apply relocations to the normal (non-dynamic) sections */
+
+static bfd_boolean
+avr32_elf_relocate_section(bfd *output_bfd, struct bfd_link_info *info,
+               bfd *input_bfd, asection *input_section,
+               bfd_byte *contents, Elf_Internal_Rela *relocs,
+               Elf_Internal_Sym *local_syms,
+               asection **local_sections)
+{
+  struct elf_avr32_link_hash_table *htab;
+  Elf_Internal_Shdr *symtab_hdr;
+  Elf_Internal_Rela *rel, *relend;
+  struct elf_link_hash_entry **sym_hashes;
+  struct got_entry **local_got_ents;
+  asection *sgot;
+  asection *srelgot;
+
+  pr_debug("(6) relocate section %s:<%s> (size 0x%lx)\n",
+       input_bfd->filename, input_section->name, input_section->size);
+
+  /* If we're doing a partial link, we don't have to do anything since
+     we're using RELA relocations */
+  if (info->relocatable)
+    return TRUE;
+
+  htab = avr32_elf_hash_table(info);
+  symtab_hdr = &elf_tdata(input_bfd)->symtab_hdr;
+  sym_hashes = elf_sym_hashes(input_bfd);
+  local_got_ents = elf_local_got_ents(input_bfd);
+  sgot = htab->sgot;
+  srelgot = htab->srelgot;
+
+  relend = relocs + input_section->reloc_count;
+  for (rel = relocs; rel < relend; rel++)
+    {
+      unsigned long r_type, r_symndx;
+      reloc_howto_type *howto;
+      Elf_Internal_Sym *sym = NULL;
+      struct elf_link_hash_entry *h = NULL;
+      asection *sec = NULL;
+      bfd_vma value;
+      bfd_vma offset;
+      bfd_reloc_status_type status;
+
+      r_type = ELF32_R_TYPE(rel->r_info);
+      r_symndx = ELF32_R_SYM(rel->r_info);
+
+      if (r_type == R_AVR32_NONE
+      || r_type == R_AVR32_ALIGN
+      || r_type == R_AVR32_DIFF32
+      || r_type == R_AVR32_DIFF16
+      || r_type == R_AVR32_DIFF8)
+    continue;
+
+      /* Sanity check */
+      if (r_type > R_AVR32_max)
+    {
+      bfd_set_error(bfd_error_bad_value);
+      return FALSE;
+    }
+
+      howto = &elf_avr32_howto_table[r_type];
+
+      if (r_symndx < symtab_hdr->sh_info)
+    {
+      sym = local_syms + r_symndx;
+      sec = local_sections[r_symndx];
+
+      pr_debug("  (6a) processing %s against local symbol %lu\n",
+           howto->name, r_symndx);
+
+      /* The following function changes rel->r_addend behind our back. */
+      value = _bfd_elf_rela_local_sym(output_bfd, sym, &sec, rel);
+      pr_debug("    => value: %lx, addend: %lx\n", value, rel->r_addend);
+    }
+      else
+    {
+      if (sym_hashes == NULL)
+        return FALSE;
+
+      h = sym_hashes[r_symndx - symtab_hdr->sh_info];
+      while (h->root.type == bfd_link_hash_indirect
+         || h->root.type == bfd_link_hash_warning)
+        h = (struct elf_link_hash_entry *)h->root.u.i.link;
+
+      pr_debug("  (6a) processing %s against symbol %s\n",
+           howto->name, h->root.root.string);
+
+      if (h->root.type == bfd_link_hash_defined
+          || h->root.type == bfd_link_hash_defweak)
+        {
+          bfd_boolean dyn;
+
+          dyn = htab->root.dynamic_sections_created;
+          sec = h->root.u.def.section;
+
+          if (sec->output_section)
+        value = (h->root.u.def.value
+             + sec->output_section->vma
+             + sec->output_offset);
+          else
+        value = h->root.u.def.value;
+        }
+      else if (h->root.type == bfd_link_hash_undefweak)
+        value = 0;
+      else if (info->unresolved_syms_in_objects == RM_IGNORE
+           && ELF_ST_VISIBILITY(h->other) == STV_DEFAULT)
+        value = 0;
+      else
+        {
+          bfd_boolean err;
+          err = (info->unresolved_syms_in_objects == RM_GENERATE_ERROR
+             || ELF_ST_VISIBILITY(h->other) != STV_DEFAULT);
+          if (!info->callbacks->undefined_symbol
+          (info, h->root.root.string, input_bfd,
+           input_section, rel->r_offset, err))
+        return FALSE;
+          value = 0;
+        }
+
+      pr_debug("    => value: %lx, addend: %lx\n", value, rel->r_addend);
+    }
+
+      switch (r_type)
+    {
+    case R_AVR32_GOT32:
+    case R_AVR32_GOT16:
+    case R_AVR32_GOT8:
+    case R_AVR32_GOT21S:
+    case R_AVR32_GOT18SW:
+    case R_AVR32_GOT16S:
+    case R_AVR32_GOT7UW:
+    case R_AVR32_LDA_GOT:
+    case R_AVR32_GOTCALL:
+      BFD_ASSERT(sgot != NULL);
+
+      if (h != NULL)
+        {
+          BFD_ASSERT(h->got.glist->refcount > 0);
+          offset = h->got.glist->offset;
+
+          BFD_ASSERT(offset < sgot->size);
+          if (!elf_hash_table(info)->dynamic_sections_created
+          || (h->def_regular
+              && (!info->shared
+              || info->symbolic
+              || h->dynindx == -1)))
+        {
+          /* This is actually a static link, or it is a
+             -Bsymbolic link and the symbol is defined
+             locally, or the symbol was forced to be local.  */
+          bfd_put_32(output_bfd, value, sgot->contents + offset);
+        }
+        }
+      else
+        {
+          BFD_ASSERT(local_got_ents &&
+             local_got_ents[r_symndx]->refcount > 0);
+          offset = local_got_ents[r_symndx]->offset;
+
+          /* Local GOT entries don't have relocs.  If this is a
+         shared library, the dynamic linker will add the load
+         address to the initial value at startup.  */
+          BFD_ASSERT(offset < sgot->size);
+          pr_debug("Initializing GOT entry at offset %lu: 0x%lx\n",
+               offset, value);
+          bfd_put_32 (output_bfd, value, sgot->contents + offset);
+        }
+
+      value = sgot->output_offset + offset;
+      pr_debug("GOT reference: New value %lx\n", value);
+      break;
+
+    case R_AVR32_GOTPC:
+      /* This relocation type is for constant pool entries used in
+         the calculation "Rd = PC - (PC - GOT)", where the
+         constant pool supplies the constant (PC - GOT)
+         offset. The symbol value + addend indicates where the
+         value of PC is taken. */
+      value -= sgot->output_section->vma;
+      break;
+
+    case R_AVR32_32_PCREL:
+      /* We must adjust r_offset to account for discarded data in
+         the .eh_frame section.  This is probably not the right
+         way to do this, since AFAICS all other architectures do
+         it some other way.  I just can't figure out how...  */
+      {
+        bfd_vma r_offset;
+
+        r_offset = _bfd_elf_section_offset(output_bfd, info,
+                           input_section,
+                           rel->r_offset);
+        if (r_offset == (bfd_vma)-1
+        || r_offset == (bfd_vma)-2)
+          continue;
+        rel->r_offset = r_offset;
+      }
+      break;
+
+    case R_AVR32_32:
+      /* We need to emit a run-time relocation in the following cases:
+           - we're creating a shared library
+           - the symbol is not defined in any regular objects
+
+         Of course, sections that aren't going to be part of the
+         run-time image will not get any relocs, and undefined
+         symbols won't have any either (only weak undefined
+         symbols should get this far).  */
+      if ((info->shared
+           || (elf_hash_table(info)->dynamic_sections_created
+           && h != NULL
+           && h->def_dynamic
+           && !h->def_regular))
+          && r_symndx != 0
+          && (input_section->flags & SEC_ALLOC))
+        {
+          Elf_Internal_Rela outrel;
+          bfd_byte *loc;
+          bfd_boolean skip, relocate;
+          struct elf_avr32_link_hash_entry *avrh;
+
+          pr_debug("Going to generate dynamic reloc...\n");
+
+          skip = FALSE;
+          relocate = FALSE;
+
+          outrel.r_offset = _bfd_elf_section_offset(output_bfd, info,
+                            input_section,
+                            rel->r_offset);
+          if (outrel.r_offset == (bfd_vma)-1)
+        skip = TRUE;
+          else if (outrel.r_offset == (bfd_vma)-2)
+        skip = TRUE, relocate = TRUE;
+
+          outrel.r_offset += (input_section->output_section->vma
+                  + input_section->output_offset);
+
+          pr_debug("    ... offset %lx, dynindx %ld\n",
+               outrel.r_offset, h ? h->dynindx : -1);
+
+          if (skip)
+        memset(&outrel, 0, sizeof(outrel));
+          else
+        {
+          avrh = (struct elf_avr32_link_hash_entry *)h;
+          /* h->dynindx may be -1 if this symbol was marked to
+             become local.  */
+          if (h == NULL
+              || ((info->symbolic || h->dynindx == -1)
+              && h->def_regular))
+            {
+              relocate = TRUE;
+              outrel.r_info = ELF32_R_INFO(0, R_AVR32_RELATIVE);
+              outrel.r_addend = value + rel->r_addend;
+              pr_debug("    ... R_AVR32_RELATIVE\n");
+            }
+          else
+            {
+              BFD_ASSERT(h->dynindx != -1);
+              relocate = TRUE;
+              outrel.r_info = ELF32_R_INFO(h->dynindx, R_AVR32_GLOB_DAT);
+              outrel.r_addend = rel->r_addend;
+              pr_debug("    ... R_AVR32_GLOB_DAT\n");
+            }
+        }
+
+          pr_debug("srelgot reloc_count: %d, size %lu\n",
+               srelgot->reloc_count, srelgot->size);
+
+          loc = srelgot->contents;
+          loc += srelgot->reloc_count++ * sizeof(Elf32_External_Rela);
+          bfd_elf32_swap_reloca_out(output_bfd, &outrel, loc);
+
+          BFD_ASSERT(srelgot->reloc_count * sizeof(Elf32_External_Rela)
+             <= srelgot->size);
+
+          if (!relocate)
+        continue;
+        }
+      break;
+    }
+
+      status = avr32_final_link_relocate(howto, input_bfd, input_section,
+                     contents, rel, value);
+
+      switch (status)
+    {
+    case bfd_reloc_ok:
+      break;
+
+    case bfd_reloc_overflow:
+      {
+        const char *name;
+
+        if (h != NULL)
+          name = h->root.root.string;
+        else
+          {
+        name = bfd_elf_string_from_elf_section(input_bfd,
+                               symtab_hdr->sh_link,
+                               sym->st_name);
+        if (name == NULL)
+          return FALSE;
+        if (*name == '\0')
+          name = bfd_section_name(input_bfd, sec);
+          }
+        if (!((*info->callbacks->reloc_overflow)
+          (info, (h ? &h->root : NULL), name, howto->name,
+           rel->r_addend, input_bfd, input_section, rel->r_offset)))
+          return FALSE;
+      }
+      break;
+
+    case bfd_reloc_outofrange:
+    default:
+      abort();
+    }
+    }
+
+  return TRUE;
+}
+
+
+/* Additional processing of dynamic sections after relocation */
+
+static bfd_boolean
+avr32_elf_finish_dynamic_symbol(bfd *output_bfd, struct bfd_link_info *info,
+                struct elf_link_hash_entry *h,
+                Elf_Internal_Sym *sym);
+static bfd_boolean
+avr32_elf_finish_dynamic_sections(bfd *output_bfd, struct bfd_link_info *info);
+
+
+/* (7) Initialize the contents of a dynamic symbol and/or emit
+   relocations for it */
+
+static bfd_boolean
+avr32_elf_finish_dynamic_symbol(bfd *output_bfd, struct bfd_link_info *info,
+                struct elf_link_hash_entry *h,
+                Elf_Internal_Sym *sym)
+{
+  struct elf_avr32_link_hash_table *htab;
+  struct got_entry *got;
+
+  pr_debug("(7) finish dynamic symbol: %s\n", h->root.root.string);
+
+  htab = avr32_elf_hash_table(info);
+  got = h->got.glist;
+
+  if (got && got->refcount > 0)
+    {
+      asection *sgot;
+      asection *srelgot;
+      Elf_Internal_Rela rel;
+      bfd_byte *loc;
+
+      /* This symbol has an entry in the GOT. Set it up. */
+      sgot = htab->sgot;
+      srelgot = htab->srelgot;
+      BFD_ASSERT(sgot && srelgot);
+
+      rel.r_offset = (sgot->output_section->vma
+              + sgot->output_offset
+              + got->offset);
+
+      /* If this is a static link, or it is a -Bsymbolic link and the
+     symbol is defined locally or was forced to be local because
+     of a version file, we just want to emit a RELATIVE reloc. The
+     entry in the global offset table will already have been
+     initialized in the relocate_section function. */
+      if ((info->shared
+       && !info->symbolic
+       && h->dynindx != -1)
+      || (htab->root.dynamic_sections_created
+          && h->def_dynamic
+          && !h->def_regular))
+    {
+      bfd_put_32(output_bfd, 0, sgot->contents + got->offset);
+      rel.r_info = ELF32_R_INFO(h->dynindx, R_AVR32_GLOB_DAT);
+      rel.r_addend = 0;
+
+      pr_debug("GOT reloc R_AVR32_GLOB_DAT, dynindx: %ld\n", h->dynindx);
+      pr_debug("    srelgot reloc_count: %d, size: %lu\n",
+           srelgot->reloc_count, srelgot->size);
+
+      loc = (srelgot->contents
+         + srelgot->reloc_count++ * sizeof(Elf32_External_Rela));
+      bfd_elf32_swap_reloca_out(output_bfd, &rel, loc);
+
+      BFD_ASSERT(srelgot->reloc_count * sizeof(Elf32_External_Rela)
+             <= srelgot->size);
+    }
+    }
+
+  /* Mark _DYNAMIC and _GLOBAL_OFFSET_TABLE_ as absolute */
+  if (strcmp(h->root.root.string, "_DYNAMIC") == 0
+      || strcmp(h->root.root.string, "_GLOBAL_OFFSET_TABLE_") == 0)
+    sym->st_shndx = SHN_ABS;
+
+  return TRUE;
+}
+
+/* (8) Do any remaining initialization of the dynamic sections */
+
+static bfd_boolean
+avr32_elf_finish_dynamic_sections(bfd *output_bfd, struct bfd_link_info *info)
+{
+  struct elf_avr32_link_hash_table *htab;
+  asection *sgot, *sdyn;
+
+  pr_debug("(8) finish dynamic sections\n");
+
+  htab = avr32_elf_hash_table(info);
+  sgot = htab->sgot;
+  sdyn = bfd_get_section_by_name(htab->root.dynobj, ".dynamic");
+
+  if (htab->root.dynamic_sections_created)
+    {
+      Elf32_External_Dyn *dyncon, *dynconend;
+
+      BFD_ASSERT(sdyn && sgot && sgot->size >= AVR32_GOT_HEADER_SIZE);
+
+      dyncon = (Elf32_External_Dyn *)sdyn->contents;
+      dynconend = (Elf32_External_Dyn *)(sdyn->contents + sdyn->size);
+      for (; dyncon < dynconend; dyncon++)
+    {
+      Elf_Internal_Dyn dyn;
+      asection *s;
+
+      bfd_elf32_swap_dyn_in(htab->root.dynobj, dyncon, &dyn);
+
+      switch (dyn.d_tag)
+        {
+        default:
+          break;
+
+        case DT_PLTGOT:
+          s = sgot->output_section;
+          BFD_ASSERT(s != NULL);
+          dyn.d_un.d_ptr = s->vma;
+          bfd_elf32_swap_dyn_out(output_bfd, &dyn, dyncon);
+          break;
+
+        case DT_AVR32_GOTSZ:
+          s = sgot->output_section;
+          BFD_ASSERT(s != NULL);
+          dyn.d_un.d_val = s->size;
+          bfd_elf32_swap_dyn_out(output_bfd, &dyn, dyncon);
+          break;
+        }
+    }
+
+      /* Fill in the first two entries in the global offset table */
+      bfd_put_32(output_bfd,
+         sdyn->output_section->vma + sdyn->output_offset,
+         sgot->contents);
+
+      /* The runtime linker will fill this one in with the address of
+     the run-time link map */
+      bfd_put_32(output_bfd, 0, sgot->contents + 4);
+    }
+
+  if (sgot)
+    elf_section_data(sgot->output_section)->this_hdr.sh_entsize = 4;
+
+  return TRUE;
+}
+
+
+/* AVR32-specific private ELF data */
+
+static bfd_boolean
+avr32_elf_set_private_flags(bfd *abfd, flagword flags);
+static bfd_boolean
+avr32_elf_copy_private_bfd_data(bfd *ibfd, bfd *obfd);
+static bfd_boolean
+avr32_elf_merge_private_bfd_data(bfd *ibfd, bfd *obfd);
+static bfd_boolean
+avr32_elf_print_private_bfd_data(bfd *abfd, void *ptr);
+
+static bfd_boolean
+avr32_elf_set_private_flags(bfd *abfd, flagword flags)
+{
+  elf_elfheader(abfd)->e_flags = flags;
+  elf_flags_init(abfd) = TRUE;
+
+  return TRUE;
+}
+
+/* Copy backend specific data from one object module to another.  */
+
+static bfd_boolean
+avr32_elf_copy_private_bfd_data(bfd *ibfd, bfd *obfd)
+{
+  elf_elfheader(obfd)->e_flags = elf_elfheader(ibfd)->e_flags;
+  return TRUE;
+}
+
+/* Merge backend specific data from an object file to the output
+   object file when linking.  */
+
+static bfd_boolean
+avr32_elf_merge_private_bfd_data(bfd *ibfd, bfd *obfd)
+{
+  flagword out_flags, in_flags;
+
+  pr_debug("(0) merge_private_bfd_data: %s -> %s\n",
+       ibfd->filename, obfd->filename);
+
+  in_flags = elf_elfheader(ibfd)->e_flags;
+  out_flags = elf_elfheader(obfd)->e_flags;
+
+  if (elf_flags_init(obfd))
+    {
+      /* If one of the inputs are non-PIC, the output must be
+     considered non-PIC.  The same applies to linkrelax.  */
+      if (!(in_flags & EF_AVR32_PIC))
+    out_flags &= ~EF_AVR32_PIC;
+      if (!(in_flags & EF_AVR32_LINKRELAX))
+    out_flags &= ~EF_AVR32_LINKRELAX;
+    }
+  else
+    {
+      elf_flags_init(obfd) = TRUE;
+      out_flags = in_flags;
+    }
+
+  elf_elfheader(obfd)->e_flags = out_flags;
+
+  return TRUE;
+}
+
+static bfd_boolean
+avr32_elf_print_private_bfd_data(bfd *abfd, void *ptr)
+{
+  FILE *file = (FILE *)ptr;
+  unsigned long flags;
+
+  BFD_ASSERT(abfd != NULL && ptr != NULL);
+
+  _bfd_elf_print_private_bfd_data(abfd, ptr);
+
+  flags = elf_elfheader(abfd)->e_flags;
+
+  fprintf(file, _("private flags = %lx:"), elf_elfheader(abfd)->e_flags);
+
+  if (flags & EF_AVR32_PIC)
+    fprintf(file, " [PIC]");
+  if (flags & EF_AVR32_LINKRELAX)
+    fprintf(file, " [linker relaxable]");
+
+  flags &= ~(EF_AVR32_PIC | EF_AVR32_LINKRELAX);
+
+  if (flags)
+    fprintf(file, _("<Unrecognized flag bits set>"));
+
+  fputc('\n', file);
+
+  return TRUE;
+}
+
+/* Set avr32-specific linker options.  */
+void bfd_elf32_avr32_set_options(struct bfd_link_info *info,
+                 int direct_data_refs)
+{
+  struct elf_avr32_link_hash_table *htab;
+
+  htab = avr32_elf_hash_table (info);
+  htab->direct_data_refs = !!direct_data_refs;
+}
+
+
+
+/* Understanding core dumps */
+
+static bfd_boolean
+avr32_elf_grok_prstatus(bfd *abfd, Elf_Internal_Note *note);
+static bfd_boolean
+avr32_elf_grok_psinfo(bfd *abfd, Elf_Internal_Note *note);
+
+static bfd_boolean
+avr32_elf_grok_prstatus(bfd *abfd, Elf_Internal_Note *note)
+{
+  /* Linux/AVR32B elf_prstatus */
+  if (note->descsz != 148)
+    return FALSE;
+
+  /* pr_cursig */
+  elf_tdata(abfd)->core_signal = bfd_get_16(abfd, note->descdata + 12);
+
+  /* pr_pid */
+  elf_tdata(abfd)->core_pid = bfd_get_32(abfd, note->descdata + 24);
+
+  /* Make a ".reg/999" section for pr_reg. The size is for 16
+     general-purpose registers, SR and r12_orig (18 * 4 = 72).  */
+  return _bfd_elfcore_make_pseudosection(abfd, ".reg", 72,
+                     note->descpos + 72);
+}
+
+static bfd_boolean
+avr32_elf_grok_psinfo(bfd *abfd, Elf_Internal_Note *note)
+{
+  /* Linux/AVR32B elf_prpsinfo */
+  if (note->descsz != 128)
+    return FALSE;
+
+  elf_tdata(abfd)->core_program
+    = _bfd_elfcore_strndup(abfd, note->descdata + 32, 16);
+  elf_tdata(abfd)->core_command
+    = _bfd_elfcore_strndup(abfd, note->descdata + 48, 80);
+
+  /* Note that for some reason, a spurious space is tacked
+     onto the end of the args in some (at least one anyway)
+     implementations, so strip it off if it exists.  */
+
+  {
+    char *command = elf_tdata (abfd)->core_command;
+    int n = strlen (command);
+
+    if (0 < n && command[n - 1] == ' ')
+      command[n - 1] = '\0';
+  }
+
+  return TRUE;
+}
+
+
+#define ELF_ARCH            bfd_arch_avr32
+#define ELF_MACHINE_CODE        EM_AVR32
+#define ELF_MAXPAGESIZE         0x1000
+
+#define TARGET_BIG_SYM          bfd_elf32_avr32_vec
+#define TARGET_BIG_NAME         "elf32-avr32"
+
+#define elf_backend_grok_prstatus   avr32_elf_grok_prstatus
+#define elf_backend_grok_psinfo     avr32_elf_grok_psinfo
+
+/* Only RELA relocations are used */
+#define elf_backend_may_use_rel_p   0
+#define elf_backend_may_use_rela_p  1
+#define elf_backend_default_use_rela_p  1
+#define elf_backend_rela_normal     1
+#define elf_info_to_howto_rel       NULL
+#define elf_info_to_howto       avr32_info_to_howto
+
+#define bfd_elf32_bfd_copy_private_bfd_data avr32_elf_copy_private_bfd_data
+#define bfd_elf32_bfd_merge_private_bfd_data    avr32_elf_merge_private_bfd_data
+#define bfd_elf32_bfd_set_private_flags     avr32_elf_set_private_flags
+#define bfd_elf32_bfd_print_private_bfd_data    avr32_elf_print_private_bfd_data
+#define bfd_elf32_new_section_hook      avr32_elf_new_section_hook
+
+#define elf_backend_gc_mark_hook        avr32_elf_gc_mark_hook
+#define elf_backend_gc_sweep_hook       avr32_elf_gc_sweep_hook
+#define elf_backend_relocate_section    avr32_elf_relocate_section
+#define elf_backend_copy_indirect_symbol avr32_elf_copy_indirect_symbol
+#define elf_backend_create_dynamic_sections avr32_elf_create_dynamic_sections
+#define bfd_elf32_bfd_link_hash_table_create avr32_elf_link_hash_table_create
+#define elf_backend_adjust_dynamic_symbol avr32_elf_adjust_dynamic_symbol
+#define elf_backend_size_dynamic_sections avr32_elf_size_dynamic_sections
+#define elf_backend_finish_dynamic_symbol avr32_elf_finish_dynamic_symbol
+#define elf_backend_finish_dynamic_sections avr32_elf_finish_dynamic_sections
+
+#define bfd_elf32_bfd_relax_section avr32_elf_relax_section
+
+/* Find out which symbols need an entry in .got. */
+#define elf_backend_check_relocs    avr32_check_relocs
+#define elf_backend_can_refcount    1
+#define elf_backend_can_gc_sections 1
+#define elf_backend_plt_readonly    1
+#define elf_backend_plt_not_loaded  1
+#define elf_backend_want_plt_sym    0
+#define elf_backend_plt_alignment   2
+#define elf_backend_want_dynbss     0
+#define elf_backend_want_got_plt    0
+#define elf_backend_want_got_sym    1
+#define elf_backend_got_header_size AVR32_GOT_HEADER_SIZE
+
+#include "elf32-target.h"
diff -Nrup gdb-6.7.1/bfd/elf32-avr32.h gdb-6.7.1-atmel/bfd/elf32-avr32.h
--- gdb-6.7.1/bfd/elf32-avr32.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/bfd/elf32-avr32.h	2008-04-03 15:00:38.000000000 +0200
@@ -0,0 +1,23 @@
+/* AVR32-specific support for 32-bit ELF.
+   Copyright 2007 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
+
+void bfd_elf32_avr32_set_options(struct bfd_link_info *info,
+				 int direct_data_refs);
diff -Nrup gdb-6.7.1/bfd/elf-bfd.h gdb-6.7.1-atmel/bfd/elf-bfd.h
--- gdb-6.7.1/bfd/elf-bfd.h	2007-08-24 17:11:12.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/elf-bfd.h	2008-04-03 15:00:37.000000000 +0200
@@ -1400,6 +1400,10 @@ struct elf_obj_tdata
      find_nearest_line.  */
   struct mips_elf_find_line *find_line_info;
 
+  /* Used by AVR32 ELF relaxation code.  Contains an array of pointers
+     for each local symbol to the fragment where it is defined.  */
+  struct fragment **local_sym_frag;
+
   /* A place to stash dwarf1 info for this bfd.  */
   struct dwarf1_debug *dwarf1_find_line_info;
 
diff -Nrup gdb-6.7.1/bfd/libbfd.h gdb-6.7.1-atmel/bfd/libbfd.h
--- gdb-6.7.1/bfd/libbfd.h	2007-07-27 03:04:29.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/libbfd.h	2008-04-03 15:00:36.000000000 +0200
@@ -1601,6 +1601,47 @@ static const char *const bfd_reloc_code_
   "BFD_RELOC_AVR_LDI",
   "BFD_RELOC_AVR_6",
   "BFD_RELOC_AVR_6_ADIW",
+  "BFD_RELOC_AVR32_DIFF32",
+  "BFD_RELOC_AVR32_DIFF16",
+  "BFD_RELOC_AVR32_DIFF8",
+  "BFD_RELOC_AVR32_GOT32",
+  "BFD_RELOC_AVR32_GOT16",
+  "BFD_RELOC_AVR32_GOT8",
+  "BFD_RELOC_AVR32_21S",
+  "BFD_RELOC_AVR32_16U",
+  "BFD_RELOC_AVR32_16S",
+  "BFD_RELOC_AVR32_SUB5",
+  "BFD_RELOC_AVR32_8S_EXT",
+  "BFD_RELOC_AVR32_8S",
+  "BFD_RELOC_AVR32_22H_PCREL",
+  "BFD_RELOC_AVR32_18W_PCREL",
+  "BFD_RELOC_AVR32_16B_PCREL",
+  "BFD_RELOC_AVR32_16N_PCREL",
+  "BFD_RELOC_AVR32_14UW_PCREL",
+  "BFD_RELOC_AVR32_11H_PCREL",
+  "BFD_RELOC_AVR32_10UW_PCREL",
+  "BFD_RELOC_AVR32_9H_PCREL",
+  "BFD_RELOC_AVR32_9UW_PCREL",
+  "BFD_RELOC_AVR32_GOTPC",
+  "BFD_RELOC_AVR32_GOTCALL",
+  "BFD_RELOC_AVR32_LDA_GOT",
+  "BFD_RELOC_AVR32_GOT21S",
+  "BFD_RELOC_AVR32_GOT18SW",
+  "BFD_RELOC_AVR32_GOT16S",
+  "BFD_RELOC_AVR32_32_CPENT",
+  "BFD_RELOC_AVR32_CPCALL",
+  "BFD_RELOC_AVR32_16_CP",
+  "BFD_RELOC_AVR32_9W_CP",
+  "BFD_RELOC_AVR32_ALIGN",
+  "BFD_RELOC_AVR32_14UW",
+  "BFD_RELOC_AVR32_10UW",
+  "BFD_RELOC_AVR32_10SW",
+  "BFD_RELOC_AVR32_STHH_W",
+  "BFD_RELOC_AVR32_7UW",
+  "BFD_RELOC_AVR32_6S",
+  "BFD_RELOC_AVR32_6UW",
+  "BFD_RELOC_AVR32_4UH",
+  "BFD_RELOC_AVR32_3U",
   "BFD_RELOC_390_12",
   "BFD_RELOC_390_GOT12",
   "BFD_RELOC_390_PLT32",
diff -Nrup gdb-6.7.1/bfd/Makefile.am gdb-6.7.1-atmel/bfd/Makefile.am
--- gdb-6.7.1/bfd/Makefile.am	2007-08-23 18:29:49.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/Makefile.am	2008-04-03 15:00:36.000000000 +0200
@@ -63,6 +63,7 @@ ALL_MACHINES = \
 	cpu-arc.lo \
 	cpu-arm.lo \
 	cpu-avr.lo \
+	cpu-avr32.lo \
 	cpu-bfin.lo \
 	cpu-cr16.lo \
 	cpu-cr16c.lo \
@@ -243,6 +244,7 @@ BFD32_BACKENDS = \
 	elf32-arc.lo \
 	elf32-arm.lo \
 	elf32-avr.lo \
+	elf32-avr32.lo \
 	elf32-bfin.lo \
 	elf32-cr16.lo \
 	elf32-cr16c.lo \
@@ -1319,6 +1321,10 @@ elf32-avr.lo: elf32-avr.c $(INCDIR)/file
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/avr.h \
   $(INCDIR)/elf/reloc-macros.h elf32-avr.h elf32-target.h
+elf32-avr32.lo: elf32-avr32.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/avr32.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-bfin.lo: elf32-bfin.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/bfin.h \
diff -Nrup gdb-6.7.1/bfd/Makefile.in gdb-6.7.1-atmel/bfd/Makefile.in
--- gdb-6.7.1/bfd/Makefile.in	2007-08-23 18:29:49.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/Makefile.in	2008-04-03 15:01:24.000000000 +0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,15 +15,11 @@
 @SET_MAKE@
 
 
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = .
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -38,14 +34,12 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub README \
-	ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
-	$(top_srcdir)/configure $(am__configure_deps) \
-	$(srcdir)/config.in $(srcdir)/../mkinstalldirs \
-	$(srcdir)/bfd-in2.h $(top_srcdir)/po/Make-in \
-	$(srcdir)/../ltmain.sh $(srcdir)/../config.guess \
-	$(srcdir)/../config.sub
 subdir = .
+DIST_COMMON = README ChangeLog $(srcdir)/Makefile.in \
+	$(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(srcdir)/config.in \
+	$(srcdir)/../mkinstalldirs $(srcdir)/bfd-in2.h \
+	$(top_srcdir)/po/Make-in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../config/acx.m4 \
 	$(top_srcdir)/../config/depstand.m4 \
@@ -61,7 +55,7 @@ am__aclocal_m4_deps = $(top_srcdir)/../c
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno configure.status.lineno
+ configure.lineno config.status.lineno
 mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = bfd-in3.h po/Makefile.in
@@ -87,30 +81,35 @@ am__objects_1 = archive.lo archures.lo b
 	stab-syms.lo merge.lo dwarf2.lo simple.lo
 am_libbfd_la_OBJECTS = $(am__objects_1)
 libbfd_la_OBJECTS = $(am_libbfd_la_OBJECTS)
-DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
+libbfd_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libbfd_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
 am__depfiles_maybe =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
 SOURCES = $(libbfd_a_SOURCES) $(libbfd_la_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-exec-recursive install-info-recursive \
-	install-recursive installcheck-recursive installdirs-recursive \
-	pdf-recursive ps-recursive uninstall-info-recursive \
-	uninstall-recursive
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
 ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AR = @AR@
 AUTOCONF = @AUTOCONF@
@@ -148,15 +147,12 @@ EXEEXT = @EXEEXT@
 EXEEXT_FOR_BUILD = @EXEEXT_FOR_BUILD@
 FGREP = @FGREP@
 GENCAT = @GENCAT@
-GENINSRC_NEVER_FALSE = @GENINSRC_NEVER_FALSE@
-GENINSRC_NEVER_TRUE = @GENINSRC_NEVER_TRUE@
 GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 HDEFINES = @HDEFINES@
 INCINTL = @INCINTL@
+INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
-INSTALL_LIBBFD_FALSE = @INSTALL_LIBBFD_FALSE@
-INSTALL_LIBBFD_TRUE = @INSTALL_LIBBFD_TRUE@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
@@ -171,9 +167,8 @@ LIBTOOL = @LIBTOOL@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
 MAINT = @MAINT@
-MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
-MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
 MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
 MKINSTALLDIRS = @MKINSTALLDIRS@
 MSGFMT = @MSGFMT@
 MSGMERGE = @MSGMERGE@
@@ -203,11 +198,13 @@ WARN_CFLAGS = @WARN_CFLAGS@
 WIN32LDFLAGS = @WIN32LDFLAGS@
 WIN32LIBADD = @WIN32LIBADD@
 XGETTEXT = @XGETTEXT@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
 all_backends = @all_backends@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -227,6 +224,7 @@ build_alias = @build_alias@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
+builddir = @builddir@
 datadir = @datadir@
 datarootdir = @datarootdir@
 docdir = @docdir@
@@ -256,6 +254,7 @@ program_transform_name = @program_transf
 psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
@@ -264,6 +263,8 @@ target_noncanonical = @target_noncanonic
 target_os = @target_os@
 target_vendor = @target_vendor@
 tdefaults = @tdefaults@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
 wordsize = @wordsize@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 ACLOCAL_AMFLAGS = -I . -I .. -I ../config
@@ -314,6 +315,7 @@ ALL_MACHINES = \
 	cpu-arc.lo \
 	cpu-arm.lo \
 	cpu-avr.lo \
+	cpu-avr32.lo \
 	cpu-bfin.lo \
 	cpu-cr16.lo \
 	cpu-cr16c.lo \
@@ -495,6 +497,7 @@ BFD32_BACKENDS = \
 	elf32-arc.lo \
 	elf32-arm.lo \
 	elf32-avr.lo \
+	elf32-avr32.lo \
 	elf32-bfin.lo \
 	elf32-cr16.lo \
 	elf32-cr16c.lo \
@@ -981,15 +984,15 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
-	      echo ' cd $(srcdir) && $(AUTOMAKE) --cygnus '; \
-	      cd $(srcdir) && $(AUTOMAKE) --cygnus  \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
 		&& exit 0; \
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --cygnus  Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --cygnus  Makefile
+	  $(AUTOMAKE) --foreign  Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
@@ -1012,7 +1015,7 @@ $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(
 config.h: stamp-h1
 	@if test ! -f $@; then \
 	  rm -f stamp-h1; \
-	  $(MAKE) stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
 	else :; fi
 
 stamp-h1: $(srcdir)/config.in $(top_builddir)/config.status
@@ -1042,7 +1045,7 @@ clean-bfdlibLTLIBRARIES:
 	  rm -f "$${dir}/so_locations"; \
 	done
 libbfd.la: $(libbfd_la_OBJECTS) $(libbfd_la_DEPENDENCIES) 
-	$(LINK) -rpath $(bfdlibdir) $(libbfd_la_LDFLAGS) $(libbfd_la_OBJECTS) $(libbfd_la_LIBADD) $(LIBS)
+	$(libbfd_la_LINK) -rpath $(bfdlibdir) $(libbfd_la_OBJECTS) $(libbfd_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -1067,7 +1070,6 @@ clean-libtool:
 
 distclean-libtool:
 	-rm -f libtool
-uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -1100,8 +1102,7 @@ $(RECURSIVE_TARGETS):
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-mostlyclean-recursive clean-recursive distclean-recursive \
-maintainer-clean-recursive:
+$(RECURSIVE_CLEAN_TARGETS):
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -1145,8 +1146,8 @@ ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -1171,8 +1172,8 @@ TAGS: tags-recursive $(HEADERS) $(SOURCE
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -1182,13 +1183,12 @@ ctags: CTAGS
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.in $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
-	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS) config.in $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -1206,7 +1206,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRAR
 installdirs: installdirs-recursive
 installdirs-am:
 	for dir in "$(DESTDIR)$(bfdlibdir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: install-recursive
 install-exec: install-exec-recursive
@@ -1258,12 +1258,18 @@ info-am:
 
 install-data-am: install-bfdlibLTLIBRARIES
 
+install-dvi: install-dvi-recursive
+
 install-exec-am:
 
 install-info: install-info-recursive
 
 install-man:
 
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -1287,23 +1293,25 @@ ps-am:
 
 uninstall-am: uninstall-bfdlibLTLIBRARIES
 
-uninstall-info: uninstall-info-recursive
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
 
-.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am am--refresh check \
-	check-am clean clean-bfdlibLTLIBRARIES clean-generic \
-	clean-libtool clean-noinstLIBRARIES clean-recursive ctags \
-	ctags-recursive distclean distclean-compile distclean-generic \
-	distclean-hdr distclean-libtool distclean-recursive \
-	distclean-tags dvi dvi-am html html-am info info-am install \
-	install-am install-bfdlibLTLIBRARIES install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic maintainer-clean-recursive \
-	mostlyclean mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool mostlyclean-recursive pdf pdf-am ps ps-am \
-	tags tags-recursive uninstall uninstall-am \
-	uninstall-bfdlibLTLIBRARIES uninstall-info-am
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-am clean \
+	clean-bfdlibLTLIBRARIES clean-generic clean-libtool \
+	clean-noinstLIBRARIES ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-bfdlibLTLIBRARIES \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags tags-recursive uninstall uninstall-am \
+	uninstall-bfdlibLTLIBRARIES
 
 
 po/SRC-POTFILES.in: @MAINT@ Makefile $(SRC_POTFILES)
@@ -1901,6 +1909,10 @@ elf32-avr.lo: elf32-avr.c $(INCDIR)/file
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/avr.h \
   $(INCDIR)/elf/reloc-macros.h elf32-avr.h elf32-target.h
+elf32-avr32.lo: elf32-avr32.c $(INCDIR)/filenames.h elf-bfd.h \
+  $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h $(INCDIR)/elf/external.h \
+  $(INCDIR)/bfdlink.h $(INCDIR)/elf/avr32.h $(INCDIR)/elf/reloc-macros.h \
+  elf32-target.h
 elf32-bfin.lo: elf32-bfin.c $(INCDIR)/filenames.h $(INCDIR)/hashtab.h \
   elf-bfd.h $(INCDIR)/elf/common.h $(INCDIR)/elf/internal.h \
   $(INCDIR)/elf/external.h $(INCDIR)/bfdlink.h $(INCDIR)/elf/bfin.h \
diff -Nrup gdb-6.7.1/bfd/reloc.c gdb-6.7.1-atmel/bfd/reloc.c
--- gdb-6.7.1/bfd/reloc.c	2007-07-26 11:37:13.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/reloc.c	2008-04-03 15:00:36.000000000 +0200
@@ -3948,6 +3948,129 @@ ENUMDOC
   instructions
 
 ENUM
+  BFD_RELOC_AVR32_DIFF32
+ENUMX
+  BFD_RELOC_AVR32_DIFF16
+ENUMX
+  BFD_RELOC_AVR32_DIFF8
+ENUMDOC
+  Difference between two labels: L2 - L1. The value of L1 is encoded
+  as sym + addend, while the initial difference after assembly is
+  inserted into the object file by the assembler.
+ENUM
+  BFD_RELOC_AVR32_GOT32
+ENUMX
+  BFD_RELOC_AVR32_GOT16
+ENUMX
+  BFD_RELOC_AVR32_GOT8
+ENUMDOC
+  Reference to a symbol through the Global Offset Table. The linker
+  will allocate an entry for symbol in the GOT and insert the offset
+  of this entry as the relocation value.
+ENUM
+  BFD_RELOC_AVR32_21S
+ENUMX
+  BFD_RELOC_AVR32_16U
+ENUMX
+  BFD_RELOC_AVR32_16S
+ENUMX
+  BFD_RELOC_AVR32_SUB5
+ENUMX
+  BFD_RELOC_AVR32_8S_EXT
+ENUMX
+  BFD_RELOC_AVR32_8S
+ENUMDOC
+  Normal (non-pc-relative) code relocations. Alignment and signedness
+  is indicated by the suffixes. S means signed, U means unsigned. W
+  means word-aligned, H means halfword-aligned, neither means
+  byte-aligned (no alignment.) SUB5 is the same relocation as 16S.
+ENUM
+  BFD_RELOC_AVR32_22H_PCREL
+ENUMX
+  BFD_RELOC_AVR32_18W_PCREL
+ENUMX
+  BFD_RELOC_AVR32_16B_PCREL
+ENUMX
+  BFD_RELOC_AVR32_16N_PCREL
+ENUMX
+  BFD_RELOC_AVR32_14UW_PCREL
+ENUMX
+  BFD_RELOC_AVR32_11H_PCREL
+ENUMX
+  BFD_RELOC_AVR32_10UW_PCREL
+ENUMX
+  BFD_RELOC_AVR32_9H_PCREL
+ENUMX
+  BFD_RELOC_AVR32_9UW_PCREL
+ENUMDOC
+  PC-relative relocations are signed if neither 'U' nor 'S' is
+  specified. However, we explicitly tack on a 'B' to indicate no
+  alignment, to avoid confusion with data relocs. All of these resolve
+  to sym + addend - offset, except the one with 'N' (negated) suffix.
+  This particular one resolves to offset - sym - addend.
+ENUM
+  BFD_RELOC_AVR32_GOTPC
+ENUMDOC
+  Subtract the link-time address of the GOT from (symbol + addend)
+  and insert the result.
+ENUM
+  BFD_RELOC_AVR32_GOTCALL
+ENUMX
+  BFD_RELOC_AVR32_LDA_GOT
+ENUMX
+  BFD_RELOC_AVR32_GOT21S
+ENUMX
+  BFD_RELOC_AVR32_GOT18SW
+ENUMX
+  BFD_RELOC_AVR32_GOT16S
+ENUMDOC
+  Reference to a symbol through the GOT. The linker will allocate an
+  entry for symbol in the GOT and insert the offset of this entry as
+  the relocation value. addend must be zero. As usual, 'S' means
+  signed, 'W' means word-aligned, etc.
+ENUM
+  BFD_RELOC_AVR32_32_CPENT
+ENUMDOC
+  32-bit constant pool entry. I don't think 8- and 16-bit entries make
+  a whole lot of sense.
+ENUM
+  BFD_RELOC_AVR32_CPCALL
+ENUMX
+  BFD_RELOC_AVR32_16_CP
+ENUMX
+  BFD_RELOC_AVR32_9W_CP
+ENUMDOC
+  Constant pool references. Some of these relocations are signed,
+  others are unsigned. It doesn't really matter, since the constant
+  pool always comes after the code that references it.
+ENUM
+  BFD_RELOC_AVR32_ALIGN
+ENUMDOC
+  sym must be the absolute symbol. The addend specifies the alignment
+  order, e.g. if addend is 2, the linker must add padding so that the
+  next address is aligned to a 4-byte boundary.
+ENUM
+  BFD_RELOC_AVR32_14UW
+ENUMX
+  BFD_RELOC_AVR32_10UW
+ENUMX
+  BFD_RELOC_AVR32_10SW
+ENUMX
+  BFD_RELOC_AVR32_STHH_W
+ENUMX
+  BFD_RELOC_AVR32_7UW
+ENUMX
+  BFD_RELOC_AVR32_6S
+ENUMX
+  BFD_RELOC_AVR32_6UW
+ENUMX
+  BFD_RELOC_AVR32_4UH
+ENUMX
+  BFD_RELOC_AVR32_3U
+ENUMDOC
+  Code relocations that will never make it to the output file.
+
+ENUM
   BFD_RELOC_390_12
 ENUMDOC
    Direct 12 bit.
diff -Nrup gdb-6.7.1/bfd/targets.c gdb-6.7.1-atmel/bfd/targets.c
--- gdb-6.7.1/bfd/targets.c	2007-07-03 16:26:42.000000000 +0200
+++ gdb-6.7.1-atmel/bfd/targets.c	2008-04-03 15:00:38.000000000 +0200
@@ -564,6 +564,7 @@ extern const bfd_target bfd_efi_app_ia32
 extern const bfd_target bfd_efi_app_x86_64_vec;
 extern const bfd_target bfd_efi_app_ia64_vec;
 extern const bfd_target bfd_elf32_avr_vec;
+extern const bfd_target bfd_elf32_avr32_vec;
 extern const bfd_target bfd_elf32_bfin_vec;
 extern const bfd_target bfd_elf32_bfinfdpic_vec;
 extern const bfd_target bfd_elf32_big_generic_vec;
@@ -884,6 +885,7 @@ static const bfd_target * const _bfd_tar
 	&bfd_efi_app_ia64_vec,
 #endif
 	&bfd_elf32_avr_vec,
+	&bfd_elf32_avr32_vec,
 	&bfd_elf32_bfin_vec,
 	&bfd_elf32_bfinfdpic_vec,
 
diff -Nrup gdb-6.7.1/gdb/avr32-linux-tdep.c gdb-6.7.1-atmel/gdb/avr32-linux-tdep.c
--- gdb-6.7.1/gdb/avr32-linux-tdep.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/avr32-linux-tdep.c	2008-04-03 15:00:45.000000000 +0200
@@ -0,0 +1,109 @@
+/* GNU/Linux on AVR32 target support.
+   Copyright 2004-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "target.h"
+#include "solib-svr4.h"
+#include "osabi.h"
+
+#include "avr32-tdep.h"
+
+/* Fetch, and possibly build, an appropriate link_map_offsets
+   structure for AVR32 linux targets using the struct offsets defined
+   in <link.h>.  Note, however, that link.h is not actually referred
+   to in this file.  Instead, the relevant structs offsets were
+   obtained from examining link.h.  (We can't refer to link.h from
+   this file because the host system won't necessarily have it, or if
+   it does, the structs which it defines will refer to the host
+   system, not the target).
+
+   The following information is derived from uClibc's link.h  */
+
+static struct link_map_offsets *
+avr32_linux_fetch_link_map_offsets (void)
+{
+  static struct link_map_offsets lmo;
+  static struct link_map_offsets *lmp = NULL;
+
+  if (lmp == NULL)
+    {
+      lmp = &lmo;
+
+      /* Size of struct r_debug */
+      lmo.r_version_offset = 0;
+      lmo.r_version_size = 4;
+      lmo.r_map_offset = 4;
+
+      lmo.link_map_size = 20;
+      lmo.l_addr_offset = 0;
+      lmo.l_name_offset = 4;
+      lmo.l_ld_offset = 8;
+      lmo.l_next_offset = 12;
+      lmo.l_prev_offset = 16;
+    }
+
+  return lmp;
+}
+
+/* This corresponds with the layout of struct pt_regs from <asm/ptrace.h> */
+static int avr32_linux_gregset_reg_offset[] =
+  {
+    16 * 4,		/*  r0 */
+    15 * 4,		/*  r1 */
+    14 * 4,		/*  r2 */
+    13 * 4,		/*  r3 */
+    12 * 4,		/*  r4 */
+    11 * 4,		/*  r5 */
+    10 * 4,		/*  r6 */
+    9 * 4,		/*  r7 */
+    8 * 4,		/*  r8 */
+    7 * 4,		/*  r9 */
+    6 * 4,		/* r10 */
+    5 * 4,		/* r11 */
+    4 * 4,		/* r12 */
+    3 * 4,		/*  sp */
+    2 * 4,		/*  lr */
+    1 * 4,		/*  pc */
+    /* sr at offset 0 */
+    /* orig_r12 at offset 17 * 4 */
+  };
+
+static void
+avr32_linux_init_abi(struct gdbarch_info info,
+		     struct gdbarch *gdbarch)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep(gdbarch);
+
+  tdep->gregset_reg_offset = avr32_linux_gregset_reg_offset;
+  tdep->gregset_num_regs = ARRAY_SIZE(avr32_linux_gregset_reg_offset);
+  tdep->sizeof_gregset = 18 * 4;
+
+  set_solib_svr4_fetch_link_map_offsets
+    (gdbarch, avr32_linux_fetch_link_map_offsets);
+}
+
+void
+_initialize_avr32_linux_tdep(void)
+{
+  gdbarch_register_osabi(bfd_arch_avr32, 0, GDB_OSABI_LINUX,
+			 avr32_linux_init_abi);
+}
diff -Nrup gdb-6.7.1/gdb/avr32-tdep.c gdb-6.7.1-atmel/gdb/avr32-tdep.c
--- gdb-6.7.1/gdb/avr32-tdep.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/avr32-tdep.c	2008-04-03 15:00:45.000000000 +0200
@@ -0,0 +1,794 @@
+/* Common target dependent code for GDB on AVR32 systems.
+   Copyright 2004-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "defs.h"
+#include "frame.h"
+#include "frame-base.h"
+#include "frame-unwind.h"
+#include "dwarf2-frame.h"
+#include "inferior.h"
+#include "gdbcmd.h"
+#include "gdbcore.h"
+#include "dis-asm.h"
+#include "osabi.h"
+#include "regcache.h"
+#include "regset.h"
+#include "arch-utils.h"
+#include "gdb_string.h"
+
+#include "avr32-tdep.h"
+#include "elf-bfd.h"
+#include "elf/avr32.h"
+
+#include "gdb_assert.h"
+
+/* 0xd673 is the BREAKPOINT instruction */
+static unsigned char avr32_default_breakpoint[] = { 0xd6, 0x73 };
+
+/* Use the same register numbering as GCC */
+enum {
+  AVR32_REG_R0 = 0,
+  AVR32_REG_R1,
+  AVR32_REG_R2,
+  AVR32_REG_R3,
+  AVR32_REG_R4,
+  AVR32_REG_R5,
+  AVR32_REG_R6,
+  AVR32_REG_R7,
+  AVR32_REG_R8,
+  AVR32_REG_R9,
+  AVR32_REG_R10,
+  AVR32_REG_R11,
+  AVR32_REG_R12,
+  AVR32_REG_SP,
+  AVR32_REG_LR,
+  AVR32_REG_PC,
+  AVR32_NUM_REGS
+};
+
+#define AVR32_REG_FP AVR32_REG_R7
+
+struct avr32_frame_cache
+{
+  CORE_ADDR base;
+  LONGEST sp_offset;
+  CORE_ADDR pc;
+
+  int uses_fp;
+
+  CORE_ADDR saved_regs[AVR32_NUM_REGS];
+  CORE_ADDR saved_sp;
+};
+
+static struct type *
+avr32_register_type(struct gdbarch *gdbarch, int reg_nr)
+{
+  return builtin_type_int;
+}
+
+static const char *
+avr32_register_name(int reg_nr)
+{
+  static const char *register_names[] =
+    {
+      "r0", "r1", "r2", "r3", "r4", "r5", "r6", "r7",
+      "r8", "r9", "r10", "r11", "r12", "sp", "lr", "pc"
+    };
+
+  if (reg_nr < 0)
+    return NULL;
+  if (reg_nr >= sizeof(register_names) / sizeof(*register_names))
+    return NULL;
+  return register_names[reg_nr];
+}
+
+static void
+avr32_show_regs_command (char *argv, int from_tty)
+{
+    struct frame_info *frame;
+    frame = get_current_frame();/* need current scope */
+    
+  printf_filtered ("pc: %08lx  lr: %08lx  sp: %08lx  r12: %08lx\n",
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_PC),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_LR),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_SP),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R12));
+  printf_filtered ("r11: %08lx  r10: %08lx   r9: %08lx   r8: %08lx\n",
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R11),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R10),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R9),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R8));
+  printf_filtered (" r7: %08lx   r6: %08lx   r5: %08lx   r4: %08lx\n",
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R7),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R6),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R5),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R4));
+  printf_filtered (" r3: %08lx   r2: %08lx   r1: %08lx   r0: %08lx\n",
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R3),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R2),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R1),
+		   (unsigned long)get_frame_register_unsigned (frame, AVR32_REG_R0));
+}
+
+static void
+avr32_set_sysreg_command(char *args, int from_tty)
+{
+  LONGEST ret;
+  CORE_ADDR addr, value;
+  char *eq, *value_s, *endptr;
+  char buffer[4];
+
+  if (!args)
+    goto show_usage;
+
+  eq = strchr(args, '=');
+  if (!eq)
+    goto show_usage;
+
+  value_s = eq + 1;
+  *eq = 0;
+
+  addr = strtoul(args, &endptr, 0);
+  if (*args == '\0' || *endptr != '\0')
+    goto show_usage;
+
+  value = strtoul(value_s, &endptr, 0);
+  if (*value_s == '\0' || *endptr != '\0')
+    goto show_usage;
+
+  store_unsigned_integer(buffer, 4, value);
+
+  ret = target_write(&current_target, TARGET_OBJECT_SYSREG, "",
+		     buffer, addr, 4);
+  if (ret != 4)
+    printf_unfiltered("Failed to write system register %lu.\n", addr);
+
+  return;
+
+show_usage:
+  printf_unfiltered("\"set sysreg\" must be followed by SYSREG=VALUE.\n");
+}
+
+static void
+avr32_show_sysreg_command(char *args, int from_tty)
+{
+  LONGEST ret;
+  CORE_ADDR addr, value;
+  char *endptr;
+  char value_raw[4];
+
+  if (!args)
+    goto show_usage;
+
+  addr = strtoul(args, &endptr, 0);
+  if (*args == '\0' || *endptr != '\0')
+    goto show_usage;
+
+  ret = target_read(&current_target, TARGET_OBJECT_SYSREG, "",
+		    value_raw, addr, 4);
+  if (ret != 4)
+    printf_unfiltered("Failed to read system register %lu.\n", addr);
+  else
+    {
+      value = extract_unsigned_integer(value_raw, 4);
+      printf_unfiltered("SYSREG[%lu] = 0x%lx\n", addr, value);
+    }
+
+  return;
+
+show_usage:
+  printf_unfiltered("\"show sysreg\" must be followed by a system register.\n");
+}
+
+static const unsigned char *
+avr32_breakpoint_from_pc(CORE_ADDR *pcptr, int *lenptr)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep(current_gdbarch);
+
+  *lenptr = tdep->avr32_breakpoint_size;
+  return tdep->avr32_breakpoint;
+}
+
+static int
+gdb_print_insn_avr32(bfd_vma memaddr, disassemble_info *info)
+{
+  info->endian = gdbarch_byte_order(current_gdbarch);
+  return print_insn_avr32(memaddr, info);
+}
+
+static void
+avr32_write_pc(struct regcache *regcache, CORE_ADDR pc)
+{
+  regcache_cooked_write_unsigned (regcache, AVR32_REG_PC,
+                  (pc & 0xffffffff));
+
+}
+
+/* Determine, for architecture GDBARCH, how a return value of TYPE
+   should be returned.  If it is supposed to be returned in registers,
+   and READBUF is non-zero, read the appropriate value from REGCACHE,
+   and copy it into READBUF.  If WRITEBUF is non-zero, write the value
+   from WRITEBUF into REGCACHE.  */
+
+static enum return_value_convention
+avr32_return_value(struct gdbarch *gdbarch, struct type *type,
+		   struct regcache *regcache, gdb_byte *readbuf,
+		   const gdb_byte *writebuf)
+{
+  enum type_code code = TYPE_CODE(type);
+  int len = TYPE_LENGTH(type);
+
+  if (code == TYPE_CODE_STRUCT || code == TYPE_CODE_UNION)
+    {
+      /* The IAR Compiler Reference says that:
+
+      "If a structure is returned, the caller passes a pointer to a
+      location where the called function should write the result. The
+      pointer is passed in register R12. The called function must
+      return the same pointer in register R12."
+
+      Assuming GCC provides the same guarantee, this should go into
+      the Linux/AVR32 ABI document. */
+
+      if (readbuf)
+	{
+	  ULONGEST addr;
+
+	  regcache_raw_read_unsigned(regcache, AVR32_REG_R12, &addr);
+	  read_memory(addr, readbuf, TYPE_LENGTH(type));
+	}
+
+      return RETURN_VALUE_ABI_RETURNS_ADDRESS;
+    }
+
+  if (readbuf)
+    {
+      if (len <= 4)
+	regcache_raw_read(regcache, AVR32_REG_R12, readbuf);
+      else if (len <= 8)
+	{
+	  regcache_raw_read(regcache, AVR32_REG_R10, readbuf);
+	  regcache_raw_read(regcache, AVR32_REG_R11, (char *)readbuf + 4);
+	}
+      else
+	internal_error(__FILE__, __LINE__,
+		       "Cannot extract return value of %d bytes long.", len);
+    }
+  if (writebuf)
+    {
+      if (len <= 4)
+	regcache_raw_write_part(regcache, AVR32_REG_R12, 0, len, writebuf);
+      else if (len <= 8)
+	{
+	  regcache_raw_write(regcache, AVR32_REG_R10, writebuf);
+	  regcache_raw_write_part(regcache, AVR32_REG_R11, 0,
+				  len - 4, (char *)writebuf + 4);
+	}
+      else
+	internal_error(__FILE__, __LINE__,
+		       "Cannot store return value of %d bytes long.", len);
+    }
+
+  return RETURN_VALUE_REGISTER_CONVENTION;
+}
+
+static int
+sign_extend (int value, int bits)
+{
+  value = value & ((1 << bits) - 1);
+  return (value & (1 << (bits - 1))
+          ? value | (~((1 << bits) - 1))
+          : value);
+}
+
+#define IS_EXTENDED(x)		(((x) & 0xe0000000) == 0xe0000000)
+/* pushm {reglist} */
+#define IS_PUSHM(x)		(((x) & 0xf00f0000) == 0xd0010000)
+/* stm --sp, {reglist} */
+#define IS_STM_MMSP(x)		(((x) & 0xffff0000) == 0xebcd0000)
+/* st.w --sp, {reg} */
+#define IS_PUSH(x)		(((x) & 0xfff00000) == 0x1aa00000)
+/* mov fp, sp */
+#define IS_MOV_FP_SP(x)		(((x) & 0xffff0000) == 0x1a970000)
+/* sub sp, {imm} */
+#define IS_SUB_SP_IMM_C(x)	(((x) & 0xf00f0000) == 0x200d0000)
+#define IS_SUB_SP_IMM_E(x)	(((x) & 0xe1ef0000) == 0xe02d0000)
+
+#define GET_PUSH_SRCREG(x)	(((x) >> 16) & 0xf)
+#define GET_SUB_IMM_C(x)	sign_extend(((x) >> 20) & 0xff, 8)
+#define GET_SUB_IMM_E(x)	sign_extend(((x) & 0xffff)		\
+					    | (((x) >> 4) & 0x10000)	\
+					    | (((x) >> 8) & 0x1e0000),	\
+					    21)
+
+/* Analyze the prologue of the function starting at pc. The function
+   will not be analyzed further than current_pc, which indicates how
+   much of the function has actually been executed.  */
+static CORE_ADDR
+avr32_analyze_prologue (CORE_ADDR pc, CORE_ADDR current_pc,
+			struct avr32_frame_cache *cache)
+{
+  ULONGEST insn;
+  CORE_ADDR opc;
+
+  if (pc >= current_pc)
+    return current_pc;
+
+  cache->uses_fp = 0;
+  while (pc < current_pc)
+    {
+      insn = read_memory_unsigned_integer(pc, 2) << 16;
+      if (IS_EXTENDED(insn))
+	  insn = read_memory_unsigned_integer(pc, 4);
+
+      if (IS_PUSHM(insn))
+	{
+	  if (insn & 0x00100000)
+	    {
+	      cache->saved_regs[0] = cache->sp_offset;
+	      cache->saved_regs[1] = cache->sp_offset + 4;
+	      cache->saved_regs[2] = cache->sp_offset + 8;
+	      cache->saved_regs[3] = cache->sp_offset + 12;
+	      cache->sp_offset += 16;
+	    }
+	  if (insn & 0x00200000)
+	    {
+	      cache->saved_regs[4] = cache->sp_offset;
+	      cache->saved_regs[5] = cache->sp_offset + 4;
+	      cache->saved_regs[6] = cache->sp_offset + 8;
+	      cache->saved_regs[7] = cache->sp_offset + 12;
+	      cache->sp_offset += 16;
+	    }
+	  if (insn & 0x00400000)
+	    {
+	      cache->saved_regs[8] = cache->sp_offset;
+	      cache->saved_regs[9] = cache->sp_offset + 4;
+	      cache->sp_offset += 8;
+	    }
+	  if (insn & 0x00800000)
+	    {
+	      cache->saved_regs[10] = cache->sp_offset;
+	      cache->sp_offset += 4;
+	    }
+	  if (insn & 0x01000000)
+	    {
+	      cache->saved_regs[11] = cache->sp_offset;
+	      cache->sp_offset += 4;
+	    }
+	  if (insn & 0x02000000)
+	    {
+	      cache->saved_regs[12] = cache->sp_offset;
+	      cache->sp_offset += 4;
+	    }
+	  if (insn & 0x04000000)
+	    {
+	      cache->saved_regs[14] = cache->sp_offset;
+	      cache->sp_offset += 4;
+	    }
+	  if (insn & 0x08000000)
+	    {
+	      cache->saved_regs[15] = cache->sp_offset;
+	      cache->sp_offset += 4;
+	    }
+	}
+      if (IS_STM_MMSP(insn))
+	{
+	  int i;
+
+	  for (i = 0; i < 16; i++)
+	    {
+	      if (insn & (1 << i))
+		{
+		  cache->saved_regs[i] = cache->sp_offset;
+		  cache->sp_offset += 4;
+		}
+	    }
+	}
+      else if (IS_PUSH(insn))
+	{
+	  cache->saved_regs[GET_PUSH_SRCREG(insn)] = cache->sp_offset;
+	  cache->sp_offset += 4;
+	}
+      else if (IS_MOV_FP_SP(insn))
+	{
+	  cache->uses_fp = 1;
+	  cache->base = cache->sp_offset;
+	}
+      else if (IS_SUB_SP_IMM_C(insn))
+	{
+	  cache->sp_offset -= GET_SUB_IMM_C(insn);
+	}
+      else if (IS_SUB_SP_IMM_E(insn))
+	{
+	  cache->sp_offset -= GET_SUB_IMM_E(insn);
+	}
+      else
+	break;
+
+      if (IS_EXTENDED(insn))
+	pc += 4;
+      else
+	pc += 2;
+    }
+
+  return pc;
+}
+
+/* Return PC of first real instruction.
+
+   We assume the following prologue (all steps are optional):
+
+   A "pushm ..." or "stm --sp, ..." instruction to handle callee-saved
+   registers.
+
+   A "mov r7,sp" instruction to set up the frame pointer.
+
+   A "sub sp, x" instruction to allocate space for local variables. */
+
+static CORE_ADDR
+avr32_skip_prologue(CORE_ADDR start_pc)
+{
+  unsigned char insn[4];
+  CORE_ADDR pc = start_pc;
+
+  /* Check if any registers are saved. If not, we may safely(?) assume
+     that the other steps aren't taken */
+  read_memory(pc, (char *)insn, sizeof(insn));
+  if ((insn[0] & 0xf0) == 0xd0 && (insn[1] & 0x0f) == 0x01)
+    /* pushm instruction */
+    pc += 2;
+  else if (insn[0] == 0xeb && insn[1] == 0xcd)
+    /* stm --sp instruction */
+    pc += 4;
+  else
+    /* assuming no prologue */
+    return pc;
+
+  /* Check for frame pointer initialization */
+  read_memory(pc, (char *)insn, sizeof(insn));
+  if (insn[0] == 0x1a && insn[1] == 0x97)
+    /* mov r7, sp */
+    pc += 2;
+
+  /* Check for stack frame allocation */
+  read_memory(pc, (char *)insn, sizeof(insn));
+  if ((insn[0] & 0xf0) == 0x20 && (insn[1] & 0x0f) == 0x0d)
+    /* sub sp, x where -512 <= x <= 508 and x & 3 == 0 */
+    pc += 2;
+  else if ((insn[0] & 0xe1) == 0xe0 && (insn[1] & 0xef) == 0x2d)
+    /* sub sp, x for really large (or strange) stack frames */
+    pc += 4;
+
+  return pc;
+}
+
+static CORE_ADDR
+avr32_frame_align(struct gdbarch *gdbarch, CORE_ADDR sp)
+{
+  return sp & ~3;
+}
+
+static CORE_ADDR
+avr32_unwind_sp(struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  char buf[sizeof(long)];
+  frame_unwind_register(next_frame, AVR32_REG_SP, buf);
+  return extract_unsigned_integer(buf, sizeof(buf));
+}
+
+static CORE_ADDR
+avr32_unwind_pc(struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  char buf[sizeof(long)];
+  frame_unwind_register(next_frame, AVR32_REG_PC, buf);
+  return extract_unsigned_integer(buf, sizeof(buf));
+}
+
+static struct frame_id
+avr32_unwind_dummy_id(struct gdbarch *gdbarch, struct frame_info *next_frame)
+{
+  return frame_id_build(avr32_unwind_sp(gdbarch, next_frame),
+			frame_pc_unwind(next_frame));
+}
+
+static struct avr32_frame_cache *
+avr32_alloc_frame_cache (void)
+{
+  struct avr32_frame_cache *cache;
+  int i;
+
+  cache = FRAME_OBSTACK_ZALLOC (struct avr32_frame_cache);
+
+  for (i = 0; i < AVR32_NUM_REGS; i++)
+    cache->saved_regs[i] = -1;
+
+  return cache;
+}
+
+static struct avr32_frame_cache *
+avr32_frame_cache (struct frame_info *next_frame, void **this_cache)
+{
+  struct avr32_frame_cache *cache;
+  CORE_ADDR current_pc;
+  int i;
+
+  if (*this_cache)
+    return *this_cache;
+
+  cache = avr32_alloc_frame_cache();
+  *this_cache = cache;
+
+  /* FP is supposed to hold the frame pointer, but this is actually
+     almost never the case. */
+  cache->base = frame_unwind_register_unsigned (next_frame, AVR32_REG_FP);
+
+  cache->pc = frame_func_unwind (next_frame,NORMAL_FRAME);
+  current_pc = frame_pc_unwind (next_frame);
+  if (cache->pc != 0)
+    avr32_analyze_prologue (cache->pc, current_pc, cache);
+
+  if (!cache->uses_fp)
+    {
+      /* We have no frame pointer, which means that unwinding will be
+	 a bit tricky.  Assume that no stack-arguments are passed to
+	 this function.  */
+      cache->base = frame_unwind_register_unsigned (next_frame, AVR32_REG_SP);
+    }
+
+  cache->saved_sp = cache->base + cache->sp_offset;
+
+  /* Adjust all the saved registers so that they contain addresses
+     instead of offsets.  */
+  for (i = 0; i < AVR32_NUM_REGS; i++)
+    if (cache->saved_regs[i] != -1)
+      cache->saved_regs[i] = cache->saved_sp - cache->saved_regs[i] - 4;
+
+  return cache;
+}
+
+static void
+avr32_frame_prev_register (struct frame_info *next_frame, void **this_cache,
+			   int regnum, int *optimizedp,
+			   enum lval_type *lvalp, CORE_ADDR *addrp,
+			   int *realnump, gdb_byte *valuep)
+{
+  struct avr32_frame_cache *cache = avr32_frame_cache(next_frame, this_cache);
+
+  gdb_assert (regnum >= 0);
+
+  if (regnum == gdbarch_sp_regnum(current_gdbarch) && cache->saved_sp)
+    {
+      *optimizedp = 0;
+      *lvalp = not_lval;
+      *addrp = 0;
+      *realnump = -1;
+      if (valuep)
+	store_unsigned_integer(valuep, 4, cache->saved_sp);
+      return;
+    }
+
+  /* The PC of the previous frame is stored in LR of the current frame. */
+  if (regnum == AVR32_REG_PC)
+    regnum = AVR32_REG_LR;
+
+  if (regnum < AVR32_NUM_REGS && cache->saved_regs[regnum] != -1)
+    {
+      *optimizedp = 0;
+      *lvalp = lval_memory;
+      *addrp = cache->saved_regs[regnum];
+      *realnump = -1;
+      if (valuep)
+	read_memory(*addrp, valuep, register_size(current_gdbarch, regnum));
+      return;
+    }
+
+  *optimizedp = 0;
+  *lvalp = lval_register;
+  *addrp = 0;
+  *realnump = regnum;
+  if (valuep)
+    frame_unwind_register (next_frame, (*realnump), valuep);
+}
+
+static void
+avr32_frame_this_id (struct frame_info *next_frame, void **this_cache,
+		     struct frame_id *this_id)
+{
+  struct avr32_frame_cache *cache = avr32_frame_cache (next_frame, this_cache);
+
+  /* This marks the outermost frame.  */
+  if (cache->base == 0)
+    return;
+
+  *this_id = frame_id_build (cache->saved_sp, cache->pc);
+}
+
+static const struct frame_unwind avr32_frame_unwind = {
+  NORMAL_FRAME,
+  avr32_frame_this_id,
+  avr32_frame_prev_register
+};
+
+/* Default unwind sniffer. This one must always return something */
+static const struct frame_unwind *
+avr32_frame_sniffer (struct frame_info *next_frame)
+{
+  return &avr32_frame_unwind;
+}
+
+/* Supply register REGNUM from the buffer specified by GREGS and LEN
+   in the general-purpose register set REGSET to register cache
+   REGCACHE.  If REGNUM is -1, do this for all registers in REGSET.  */
+
+static void
+avr32_supply_gregset(const struct regset *regset, struct regcache *regcache,
+		     int regnum, const void *gregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep(regset->arch);
+  const char *regs = gregs;
+  int i;
+
+  gdb_assert(len == tdep->sizeof_gregset);
+
+  for (i = 0; i < tdep->gregset_num_regs; i++)
+    {
+      if ((regnum == i || regnum == -1)
+	  && tdep->gregset_reg_offset[i] != -1)
+	regcache_raw_supply(regcache, i, regs + tdep->gregset_reg_offset[i]);
+    }
+}
+
+/* Collect register REGNUM from the register cache REGCACHE and store
+   it in the buffer specified by GREGS and LEN as described by the
+   general-purpose register set REGSET.  If REGNUM is -1, do this for
+   all registers in REGSET.  */
+
+static void
+avr32_collect_gregset(const struct regset *regset,
+		      const struct regcache *regcache,
+		      int regnum, void *gregs, size_t len)
+{
+  const struct gdbarch_tdep *tdep = gdbarch_tdep(regset->arch);
+  char *regs = gregs;
+  int i;
+
+  for (i = 0; i < tdep->gregset_num_regs; i++)
+    {
+      if ((regnum == i || regnum == -1)
+	  && tdep->gregset_reg_offset[i] != -1)
+	regcache_raw_collect(regcache, i, regs + tdep->gregset_reg_offset[i]);
+    }
+}
+
+static const struct regset *
+avr32_regset_from_core_section(struct gdbarch *gdbarch,
+			       const char *sect_name, size_t sect_size)
+{
+  struct gdbarch_tdep *tdep = gdbarch_tdep(gdbarch);
+
+  if (strcmp(sect_name, ".reg") == 0 && sect_size == tdep->sizeof_gregset)
+    {
+      if (tdep->gregset == NULL)
+	tdep->gregset = regset_alloc(gdbarch, avr32_supply_gregset,
+				     avr32_collect_gregset);
+      return tdep->gregset;
+    }
+
+  return NULL;
+}
+
+/* Initialize the current architecture based on INFO.  If possible,
+   re-use an architecture from ARCHES, which is a list of
+   architectures already created during this debugging session.
+
+   Called e.g. at program startup, when reading a core file, and when
+   reading a binary file.  */
+
+static struct gdbarch *
+avr32_gdbarch_init (struct gdbarch_info info, struct gdbarch_list *arches)
+{
+  struct gdbarch *gdbarch;
+  struct gdbarch_tdep *tdep;
+
+  /* If there is already a candidate, use it. */
+  arches = gdbarch_list_lookup_by_info(arches, &info);
+  if (arches != NULL)
+    return arches->gdbarch;
+
+  /* None found, create a new architecture from the information
+     provided. */
+  tdep = xmalloc(sizeof(struct gdbarch_tdep));
+  gdbarch = gdbarch_alloc(&info, tdep);
+
+  /* Corefile: General-purpose registers.  Real values are filled in
+     by OS-specific init.  */
+  tdep->gregset = NULL;
+  tdep->gregset_reg_offset = NULL;
+  tdep->gregset_num_regs = 0;
+  tdep->sizeof_gregset = 0;
+
+  /* Breakpoints */
+  tdep->avr32_breakpoint = avr32_default_breakpoint;
+  tdep->avr32_breakpoint_size = sizeof(avr32_default_breakpoint);
+
+  set_gdbarch_short_bit(gdbarch, 16);
+  set_gdbarch_int_bit(gdbarch, 32);
+  set_gdbarch_long_bit(gdbarch, 32);
+  set_gdbarch_long_long_bit(gdbarch, 64);
+  set_gdbarch_float_bit(gdbarch, 32);
+  set_gdbarch_double_bit(gdbarch, 64);
+  set_gdbarch_long_double_bit(gdbarch, 64);
+  set_gdbarch_ptr_bit(gdbarch, 32);
+
+  set_gdbarch_num_regs(gdbarch, AVR32_NUM_REGS);
+  set_gdbarch_sp_regnum(gdbarch, AVR32_REG_SP);
+  set_gdbarch_pc_regnum(gdbarch, AVR32_REG_PC);
+  /* FIXME: What exactly is fp0? */
+  set_gdbarch_fp0_regnum(gdbarch, -1);
+  /* XXX: Should SR be a pseudo-register? */
+  set_gdbarch_ps_regnum(gdbarch, -1);
+  set_gdbarch_num_pseudo_regs(gdbarch, 0);
+
+  set_gdbarch_register_type(gdbarch, avr32_register_type);
+  set_gdbarch_register_name(gdbarch, avr32_register_name);
+  set_gdbarch_breakpoint_from_pc(gdbarch, avr32_breakpoint_from_pc);
+  set_gdbarch_print_insn(gdbarch, gdb_print_insn_avr32);
+  set_gdbarch_write_pc(gdbarch, avr32_write_pc);
+
+  set_gdbarch_return_value(gdbarch, avr32_return_value);
+
+  set_gdbarch_skip_prologue(gdbarch, avr32_skip_prologue);
+  set_gdbarch_inner_than(gdbarch, core_addr_lessthan);
+
+  set_gdbarch_frame_align(gdbarch, avr32_frame_align);
+  set_gdbarch_unwind_sp(gdbarch, avr32_unwind_sp);
+  set_gdbarch_unwind_pc(gdbarch, avr32_unwind_pc);
+  set_gdbarch_unwind_dummy_id(gdbarch, avr32_unwind_dummy_id);
+
+  gdbarch_init_osabi(info, gdbarch);
+
+  /* If the OS ABI provided a register mapping, enable the generic
+     core file support (unless it has already been enabled.)  */
+  if (tdep->gregset_reg_offset
+      && !gdbarch_regset_from_core_section_p(gdbarch))
+    set_gdbarch_regset_from_core_section(gdbarch,
+					 avr32_regset_from_core_section);
+
+  frame_unwind_append_sniffer(gdbarch, dwarf2_frame_sniffer);
+  frame_unwind_append_sniffer(gdbarch, avr32_frame_sniffer);
+
+  return gdbarch;
+}
+
+void
+_initialize_avr32_tdep(void)
+{
+  gdbarch_register(bfd_arch_avr32, avr32_gdbarch_init, NULL);
+
+  /* "set sysreg NAME=VALUE"/"show sysreg NAME" */
+  add_cmd("sysreg", class_vars, avr32_set_sysreg_command,
+	  "Write VALUE to system register NAME.", &setlist);
+  add_cmd("sysreg", class_vars, avr32_show_sysreg_command,
+	  "Show the value of system register NAME.", &showlist);
+
+  add_com("regs", class_vars, avr32_show_regs_command, "Print all registers");
+}
diff -Nrup gdb-6.7.1/gdb/avr32-tdep.h gdb-6.7.1-atmel/gdb/avr32-tdep.h
--- gdb-6.7.1/gdb/avr32-tdep.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/avr32-tdep.h	2008-04-03 15:00:48.000000000 +0200
@@ -0,0 +1,39 @@
+/* Common target dependent code for GDB on AVR32 systems.
+   Copyright 2004-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef AVR32_TDEP_H
+#define AVR32_TDEP_H
+
+struct regset;
+
+struct gdbarch_tdep
+{
+  const unsigned char *avr32_breakpoint;	/* Breakpoint instruction pattern */
+  int avr32_breakpoint_size;	/* And its size */
+
+  struct regset *gregset;
+  int *gregset_reg_offset;
+  int gregset_num_regs;
+  size_t sizeof_gregset;
+};
+
+#endif /* AVR32_TDEP_H */
diff -Nrup gdb-6.7.1/gdb/config/avr32/embed.mt gdb-6.7.1-atmel/gdb/config/avr32/embed.mt
--- gdb-6.7.1/gdb/config/avr32/embed.mt	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/config/avr32/embed.mt	2008-04-03 15:00:44.000000000 +0200
@@ -0,0 +1,2 @@
+# Target: AVR32 embedded system
+TDEPFILES= avr32-tdep.o
diff -Nrup gdb-6.7.1/gdb/config/avr32/linux.mt gdb-6.7.1-atmel/gdb/config/avr32/linux.mt
--- gdb-6.7.1/gdb/config/avr32/linux.mt	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/config/avr32/linux.mt	2008-04-03 15:00:44.000000000 +0200
@@ -0,0 +1,3 @@
+# Target: AVR32 based machine running GNU/Linux
+
+TDEPFILES=avr32-tdep.o avr32-linux-tdep.o solib.o solib-svr4.o corelow.o
diff -Nrup gdb-6.7.1/gdb/config/avr32/tm-linux.h gdb-6.7.1-atmel/gdb/config/avr32/tm-linux.h
--- gdb-6.7.1/gdb/config/avr32/tm-linux.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/config/avr32/tm-linux.h	2008-04-03 15:00:44.000000000 +0200
@@ -0,0 +1,28 @@
+/* Target definitions for GNU/Linux on AVR32, for GDB.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#ifndef TM_AVR32LINUX_H
+#define TM_AVR32LINUX_H
+
+#include "config/tm-linux.h"
+
+#endif /* TM_AVR32LINUX_H */
diff -Nrup gdb-6.7.1/gdb/configure.tgt gdb-6.7.1-atmel/gdb/configure.tgt
--- gdb-6.7.1/gdb/configure.tgt	2007-04-27 15:19:48.000000000 +0200
+++ gdb-6.7.1-atmel/gdb/configure.tgt	2008-04-03 15:00:48.000000000 +0200
@@ -31,6 +31,7 @@ case "${target_cpu}" in
 alpha*)			gdb_target_cpu=alpha ;;
 am33_2.0*)              gdb_target_cpu=mn10300 ;;
 arm*)			gdb_target_cpu=arm ;;
+avr32*)			gdb_target_cpu=avr32 ;;
 avr*)			gdb_target_cpu=avr ;;
 hppa*)			gdb_target_cpu=pa ;;
 i[34567]86*)		gdb_target_cpu=i386 ;;
@@ -90,6 +91,13 @@ xscale-*-*)		gdb_target=embed
 			build_rdi_share=yes
                         ;;
 
+avr32*-*-linux*)	gdb_target=linux
+			build_gdbserver=yes
+			;;
+
+avr32*-*-*)		gdb_target=embed
+			;;
+
 avr-*-*)		gdb_target=avr ;;
 
 cris*)                  gdb_target=cris ;;
diff -Nrup gdb-6.7.1/gdb/gdbserver/configure.srv gdb-6.7.1-atmel/gdb/gdbserver/configure.srv
--- gdb-6.7.1/gdb/gdbserver/configure.srv	2007-07-12 21:59:00.000000000 +0200
+++ gdb-6.7.1-atmel/gdb/gdbserver/configure.srv	2008-04-03 15:00:44.000000000 +0200
@@ -39,6 +39,11 @@ case "${target}" in
 			srv_mingw=yes
 			srv_mingwce=yes
 			;;
+  avr32*-*-linux*)	srv_regobj=reg-avr32.o
+			srv_tgtobj="linux-low.o linux-avr32-low.o"
+			srv_linux_usrregs=yes
+			srv_linux_thread_db=yes
+			;;
   crisv32-*-linux*)	srv_regobj=reg-crisv32.o
 			srv_tgtobj="linux-low.o linux-crisv32-low.o"
 			srv_linux_regsets=yes
diff -Nrup gdb-6.7.1/gdb/gdbserver/linux-avr32-low.c gdb-6.7.1-atmel/gdb/gdbserver/linux-avr32-low.c
--- gdb-6.7.1/gdb/gdbserver/linux-avr32-low.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/gdbserver/linux-avr32-low.c	2008-04-03 15:00:44.000000000 +0200
@@ -0,0 +1,116 @@
+/* GNU/Linux/AVR32 specific low level interface, for the remote server for GDB.
+   Copyright 2004-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of GDB.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 2 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.  */
+
+#include "server.h"
+#include "linux-low.h"
+
+#define avr32_num_regs 16
+
+static int avr32_regmap[] = {
+  64, 60, 56, 52, 48, 44, 40, 36,
+  32, 28, 24, 20, 16, 12, 8, 4,
+};
+
+static int avr32_cannot_store_register(int regno)
+{
+  return regno >= avr32_num_regs;
+}
+
+static int avr32_cannot_fetch_register(int regno)
+{
+  return regno > avr32_num_regs;
+}
+
+#ifdef HAVE_LINUX_REGSETS
+#include <sys/procfs.h>
+#include <sys/ptrace.h>
+
+static void
+avr32_fill_gregset(void *buf)
+{
+  int i;
+
+  for (i = 0; i < avr32_num_regs; i++)
+    collect_register(i, ((char *)buf) + avr32_regmap[i]);
+}
+
+static void
+avr32_store_gregset(const void *buf)
+{
+  int i;
+
+  for (i = 0; i < avr32_num_regs; i++)
+    supply_register(i, ((char *)buf) + avr32_regmap[i]);
+}
+
+struct regset_info target_regsets[] = {
+  { PTRACE_GETREGS, PTRACE_SETREGS, sizeof(elf_gregset_t),
+    GENERAL_REGS,
+    avr32_fill_gregset, avr32_store_gregset },
+  { 0, 0, -1, -1, NULL, NULL }
+};
+
+#endif /* HAVE_LINUX_REGSETS */
+
+static CORE_ADDR
+avr32_get_pc(void)
+{
+  unsigned long pc;
+  collect_register_by_name("pc", &pc);
+  return pc;
+}
+
+static void
+avr32_set_pc(CORE_ADDR pc)
+{
+  unsigned long newpc = pc;
+  supply_register_by_name("pc", &newpc);
+}
+
+static const unsigned short avr32_breakpoint = 0xd673;
+#define avr32_breakpoint_len 2
+
+static int
+avr32_breakpoint_at(CORE_ADDR where)
+{
+  unsigned short insn;
+
+  (*the_target->read_memory)(where, (char *)&insn, sizeof(insn));
+  if (insn == avr32_breakpoint)
+    return 1;
+
+  return 0;
+}
+
+struct linux_target_ops the_low_target = {
+  avr32_num_regs,
+  avr32_regmap,
+  avr32_cannot_fetch_register,
+  avr32_cannot_store_register,
+  avr32_get_pc,
+  avr32_set_pc,
+  (const char *)&avr32_breakpoint,
+  avr32_breakpoint_len,
+  NULL,
+  0,
+  avr32_breakpoint_at,
+};
diff -Nrup gdb-6.7.1/gdb/gdbserver/Makefile.in gdb-6.7.1-atmel/gdb/gdbserver/Makefile.in
--- gdb-6.7.1/gdb/gdbserver/Makefile.in	2007-06-13 20:50:38.000000000 +0200
+++ gdb-6.7.1-atmel/gdb/gdbserver/Makefile.in	2008-04-03 15:00:44.000000000 +0200
@@ -121,6 +121,7 @@ SFILES=	$(srcdir)/gdbreplay.c $(srcdir)/
 	$(srcdir)/remote-utils.c $(srcdir)/server.c $(srcdir)/target.c \
 	$(srcdir)/thread-db.c $(srcdir)/utils.c \
 	$(srcdir)/linux-arm-low.c $(srcdir)/linux-cris-low.c \
+	$(srcdir)/linux-avr32-low.c \
 	$(srcdir)/linux-crisv32-low.c $(srcdir)/linux-i386-low.c \
 	$(srcdir)/i387-fp.c \
 	$(srcdir)/linux-ia64-low.c $(srcdir)/linux-low.c \
@@ -218,6 +219,7 @@ clean:
 	rm -f reg-arm.c reg-i386.c reg-ia64.c reg-m32r.c reg-m68k.c
 	rm -f reg-ppc.c reg-sh.c reg-spu.c reg-x86-64.c reg-i386-linux.c
 	rm -f reg-cris.c reg-crisv32.c reg-x86-64-linux.c
+	rm -f reg-avr32.c
 	rm -f arm-with-iwmmxt.c mips-linux.c mips64-linux.c
 	rm -f xml-builtin.c stamp-xml target.xml
 
@@ -298,6 +300,7 @@ linux-low.o: linux-low.c $(linux_low_h) 
 
 linux-arm-low.o: linux-arm-low.c $(linux_low_h) $(server_h) \
 	$(gdb_proc_service_h)
+linux-avr32-low.o: linux-avr32-low.c $(linux_low_h) $(server_h)
 linux-cris-low.o: linux-cris-low.c $(linux_low_h) $(server_h)
 linux-crisv32-low.o: linux-crisv32-low.c $(linux_low_h) $(server_h)
 linux-i386-low.o: linux-i386-low.c $(linux_low_h) $(server_h) \
@@ -320,6 +323,9 @@ spu-low.o: spu-low.c $(server_h)
 reg-arm.o : reg-arm.c $(regdef_h)
 reg-arm.c : $(srcdir)/../regformats/reg-arm.dat $(regdat_sh)
 	sh $(regdat_sh) $(srcdir)/../regformats/reg-arm.dat reg-arm.c
+reg-avr32.o : reg-avr32.c $(regdef_h)
+reg-avr32.c : $(srcdir)/../regformats/reg-avr32.dat $(regdat_sh)
+	sh $(regdat_sh) $(srcdir)/../regformats/reg-avr32.dat reg-avr32.c
 arm-with-iwmmxt.o : arm-with-iwmmxt.c $(regdef_h)
 arm-with-iwmmxt.c : $(srcdir)/../regformats/arm-with-iwmmxt.dat $(regdat_sh)
 	sh $(regdat_sh) $(srcdir)/../regformats/arm-with-iwmmxt.dat arm-with-iwmmxt.c
diff -Nrup gdb-6.7.1/gdb/Makefile.in gdb-6.7.1-atmel/gdb/Makefile.in
--- gdb-6.7.1/gdb/Makefile.in	2007-09-05 02:14:02.000000000 +0200
+++ gdb-6.7.1-atmel/gdb/Makefile.in	2008-04-03 15:00:48.000000000 +0200
@@ -595,6 +595,7 @@ elf_internal_h =	$(INCLUDE_DIR)/elf/inte
 elf_reloc_macros_h =	$(INCLUDE_DIR)/elf/reloc-macros.h
 elf_sh_h =	$(INCLUDE_DIR)/elf/sh.h
 elf_arm_h =	$(INCLUDE_DIR)/elf/arm.h $(elf_reloc_macros_h)
+elf_avr32_h =	$(INCLUDE_DIR)/elf/avr32.h $(elf_reloc_macros_h)
 elf_bfd_h =	$(BFD_SRC)/elf-bfd.h
 elf_frv_h =	$(INCLUDE_DIR)/elf/frv.h $(elf_reloc_macros_h)
 elf_m32c_h =    $(INCLUDE_DIR)/elf/m32c.h $(elf_reloc_macros_h)
@@ -662,6 +663,7 @@ annotate_h = annotate.h $(symtab_h) $(gd
 arch_utils_h = arch-utils.h
 arm_linux_tdep_h = arm-linux-tdep.h
 arm_tdep_h = arm-tdep.h
+avr32_tdep_h = avr32-tdep.h
 auxv_h = auxv.h
 ax_gdb_h = ax-gdb.h
 ax_h = ax.h $(doublest_h)
@@ -1443,6 +1445,7 @@ ALLDEPFILES = \
 	arm-linux-nat.c arm-linux-tdep.c arm-tdep.c \
 	armnbsd-nat.c armbsd-tdep.c armnbsd-tdep.c armobsd-tdep.c \
 	avr-tdep.c \
+	avr32-linux-tdep.c avr32-tdep.c \
 	bsd-uthread.c bsd-kvm.c \
 	core-regset.c corelow.c \
 	dcache.c exec.c \
@@ -1833,6 +1836,12 @@ avr-tdep.o: avr-tdep.c $(defs_h) $(frame
 	$(frame_base_h) $(trad_frame_h) $(gdbcmd_h) $(gdbcore_h) \
 	$(inferior_h) $(symfile_h) $(arch_utils_h) $(regcache_h) \
 	$(gdb_string_h) $(dis_asm_h) $(gdbtypes_h)
+avr32-linux-tdep.o: avr32-linux-tdep.c $(defs_h) $(target_h) \
+	$(solib_svr4_h) $(osabi_h) $(avr32_tdep_h)
+avr32-tdep.o: avr32-tdep.c $(defs_h) $(frame_h) $(frame_unwind_h) \
+	$(dwarf2_frame_h) $(inferior_h) $(gdbcore_h) $(dis_asm_h) \
+	$(osabi_h) $(regcache_h) $(arch_utils_h) $(avr32_tdep_h) \
+	$(elf_bfd_h) $(elf_avr32_h) $(gdb_assert_h)
 ax-gdb.o: ax-gdb.c $(defs_h) $(symtab_h) $(symfile_h) $(gdbtypes_h) \
 	$(value_h) $(expression_h) $(command_h) $(gdbcmd_h) $(frame_h) \
 	$(target_h) $(ax_h) $(ax_gdb_h) $(gdb_string_h) $(block_h) \
diff -Nrup gdb-6.7.1/gdb/regformats/reg-avr32.dat gdb-6.7.1-atmel/gdb/regformats/reg-avr32.dat
--- gdb-6.7.1/gdb/regformats/reg-avr32.dat	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/regformats/reg-avr32.dat	2008-04-03 15:00:48.000000000 +0200
@@ -0,0 +1,18 @@
+name:avr32
+expedite:sp,pc
+32:r0
+32:r1
+32:r2
+32:r3
+32:r4
+32:r5
+32:r6
+32:r7
+32:r8
+32:r9
+32:r10
+32:r11
+32:r12
+32:sp
+32:lr
+32:pc
diff -Nrup gdb-6.7.1/gdb/remote.c gdb-6.7.1-atmel/gdb/remote.c
--- gdb-6.7.1/gdb/remote.c	2007-10-05 23:36:56.000000000 +0200
+++ gdb-6.7.1-atmel/gdb/remote.c	2008-04-03 15:00:46.000000000 +0200
@@ -910,6 +910,7 @@ enum {
   PACKET_qGetTLSAddr,
   PACKET_qSupported,
   PACKET_QPassSignals,
+  PACKET_qPart_sysreg,
   PACKET_MAX
 };
 
@@ -5786,6 +5787,114 @@ remote_xfer_partial (struct target_ops *
 	return -1;
     }
 
+
+
+  /* This is fucked up, but so is the existing code.  We happen to be
+     able to support writes, so we don't want arbitrary limitations
+     preventing us from doing so.  There's also a warning below that
+     we shouldn't do something, so I guess we probably shouldn't (but
+     if we don't, the rest of the function is worthless to us.)
+     Better duplicate most of the code instead.  */
+  if (object == TARGET_OBJECT_SYSREG)
+    {
+      struct packet_config *cfg = NULL;
+      const char *object_name = NULL;
+
+      switch (object)
+	{
+	case TARGET_OBJECT_SYSREG:
+	  cfg = &remote_protocol_packets[PACKET_qPart_sysreg];
+	  if (cfg->support != PACKET_DISABLE)
+	    object_name = "sysreg";
+	  break;
+	}
+
+      if (object_name == NULL)
+	return -1;
+
+      /* Note: a zero OFFSET and LEN can be used to query the minimum
+	 buffer size.  */
+      if (offset == 0 && len == 0)
+	return (get_remote_packet_size ());
+
+      /* except for querying the minimum buffer size, target must be open */
+      if (!remote_desc)
+	error ("remote query is only available after target open");
+
+      gdb_assert (annex != NULL);
+      for (i = 0; annex[i]; i++)
+	/* Bad caller may have sent forbidden characters.  */
+	gdb_assert (isprint (annex[i]) && annex[i] != '$' && annex[i] != '#');
+
+      if (writebuf)
+	{
+	  LONGEST body_len, header_len, count;
+	  long max_len;
+	  char* buf = rs->buf;
+	  /* TODO: Use xsnprintf() like other parts of this code does? */
+	  max_len = get_remote_packet_size ();
+	  header_len = snprintf(rs->buf, max_len - 5,
+				"qPart:%s:write:%s:%s:",
+				object_name, annex ? annex : "",
+				phex_nz (offset, sizeof offset));
+	  body_len = max_len - header_len - 5;
+	  if (body_len < 0)
+	    return -1;
+
+	  /* Each byte takes two hex characters + null character at the end */
+	  count = len;
+	  if (count > (body_len - 1) / 2)
+	    count = (body_len - 1) / 2;
+
+	  bin2hex(writebuf, rs->buf + header_len, count);
+	  i = putpkt(rs->buf);
+	  if (i < 0)
+	    return i;
+
+	  rs->buf[0] = '\0';
+	  getpkt(&rs->buf, &rs->buf_size, 0);
+	  if (packet_ok(buf, cfg) != PACKET_OK)
+	    return -1;
+
+	  p2 = &buf[0];
+	  body_len = 0;
+	  while (*p2)
+	    body_len = (body_len << 4) + fromhex (*p2++);
+
+	  i = body_len;
+	}
+      else
+	{
+	  LONGEST n = min((get_remote_packet_size () - 5) / 2, len);
+	  LONGEST req_len;
+	  char* buf = rs->buf;
+
+	  req_len = snprintf(rs->buf, get_remote_packet_size () - 5,
+			     "qPart:%s:read:%s:%s,%s",
+			     object_name, annex,
+			     phex_nz (offset, sizeof(offset)),
+			     phex_nz (n, sizeof(n)));
+	  if (req_len > rs->buf_size - 5)
+	    return -1;
+
+	  i = putpkt(rs->buf);
+	  if (i < 0)
+	    return i;
+
+	  rs->buf[0] = '\0';
+	  len = get_remote_packet_size ();
+	  getpkt(&rs->buf, &rs->buf_size, 0);
+	  if (packet_ok(buf, cfg) != PACKET_OK)
+	    return -1;
+	  if (rs->buf[0] == 'O' && rs->buf[1] == 'K' && rs->buf[2] == '\0')
+	    return 0;
+
+	  i = hex2bin(rs->buf, readbuf, len);
+	}
+
+      return i;
+    }
+
   /* Handle SPU memory using qxfer packets. */
   if (object == TARGET_OBJECT_SPU)
     {
@@ -6720,6 +6829,10 @@ Show the maximum size of the address (in
   add_packet_config_cmd (&remote_protocol_packets[PACKET_qSupported],
 			 "qSupported", "supported-packets", 0);
 
+  add_packet_config_cmd (&remote_protocol_packets[PACKET_qPart_sysreg],
+			 "qPart_sysreg", "sysreg",
+			 0);
+
   /* Keep the old ``set remote Z-packet ...'' working.  Each individual
      Z sub-packet has its own set and show commands, but users may
      have sets to this variable in their .gdbinit files (or in their
diff -Nrup gdb-6.7.1/gdb/target.h gdb-6.7.1-atmel/gdb/target.h
--- gdb-6.7.1/gdb/target.h	2007-08-23 20:08:46.000000000 +0200
+++ gdb-6.7.1-atmel/gdb/target.h	2008-04-03 15:00:44.000000000 +0200
@@ -212,7 +212,10 @@ enum target_object
      See "target-descriptions.c".  ANNEX should never be empty.  */
   TARGET_OBJECT_AVAILABLE_FEATURES,
   /* Currently loaded libraries, in XML format.  */
-  TARGET_OBJECT_LIBRARIES
+  TARGET_OBJECT_LIBRARIES,
+  /* System Register.  See "avr32-tdep.c and "remote.c". */
+  TARGET_OBJECT_SYSREG
+
   /* Possible future objects: TARGET_OBJECT_FILE, TARGET_OBJECT_PROC, ... */
 };
 
diff -Nrup gdb-6.7.1/gdb/version.in gdb-6.7.1-atmel/gdb/version.in
--- gdb-6.7.1/gdb/version.in	2007-10-29 18:49:54.000000000 +0100
+++ gdb-6.7.1-atmel/gdb/version.in	2008-04-03 15:00:43.000000000 +0200
@@ -1 +1 @@
-6.7.1
+6.7.1.atmel.1.0.3
diff -Nrup gdb-6.7.1/include/dis-asm.h gdb-6.7.1-atmel/include/dis-asm.h
--- gdb-6.7.1/include/dis-asm.h	2007-06-29 16:09:34.000000000 +0200
+++ gdb-6.7.1-atmel/include/dis-asm.h	2008-04-03 15:00:35.000000000 +0200
@@ -211,6 +211,7 @@ typedef int (*disassembler_ftype) (bfd_v
 
 extern int print_insn_alpha		(bfd_vma, disassemble_info *);
 extern int print_insn_avr		(bfd_vma, disassemble_info *);
+extern int print_insn_avr32		(bfd_vma, disassemble_info *);
 extern int print_insn_bfin		(bfd_vma, disassemble_info *);
 extern int print_insn_big_arm		(bfd_vma, disassemble_info *);
 extern int print_insn_big_mips		(bfd_vma, disassemble_info *);
@@ -290,10 +291,12 @@ extern void print_i386_disassembler_opti
 extern void print_mips_disassembler_options (FILE *);
 extern void print_ppc_disassembler_options (FILE *);
 extern void print_arm_disassembler_options (FILE *);
+extern void print_avr32_disassembler_options (FILE *);
 extern void parse_arm_disassembler_option (char *);
-extern int  get_arm_regname_num_options (void);
-extern int  set_arm_regname_option (int);
-extern int  get_arm_regnames (int, const char **, const char **, const char *const **);
+extern void parse_avr32_disassembler_option (char *);
+extern int get_arm_regname_num_options (void);
+extern int set_arm_regname_option (int);
+extern int get_arm_regnames (int, const char **, const char **, const char *const **);
 extern bfd_boolean arm_symbol_is_valid (asymbol *, struct disassemble_info *);
 
 /* Fetch the disassembler for a given BFD, if that support is available.  */
diff -Nrup gdb-6.7.1/include/elf/avr32.h gdb-6.7.1-atmel/include/elf/avr32.h
--- gdb-6.7.1/include/elf/avr32.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/include/elf/avr32.h	2008-04-03 15:00:35.000000000 +0200
@@ -0,0 +1,95 @@
+/* AVR32 ELF support for BFD.
+   Copyright 2003-2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of BFD, the Binary File Descriptor library.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "elf/reloc-macros.h"
+
+/* CPU-specific flags for the ELF header e_flags field */
+#define EF_AVR32_LINKRELAX		0x01
+#define EF_AVR32_PIC			0x02
+
+START_RELOC_NUMBERS (elf_avr32_reloc_type)
+    RELOC_NUMBER (R_AVR32_NONE,			0)
+
+    /* Data Relocations */
+    RELOC_NUMBER (R_AVR32_32,			1)
+    RELOC_NUMBER (R_AVR32_16,			2)
+    RELOC_NUMBER (R_AVR32_8,			3)
+    RELOC_NUMBER (R_AVR32_32_PCREL,		4)
+    RELOC_NUMBER (R_AVR32_16_PCREL,		5)
+    RELOC_NUMBER (R_AVR32_8_PCREL,		6)
+    RELOC_NUMBER (R_AVR32_DIFF32,		7)
+    RELOC_NUMBER (R_AVR32_DIFF16,		8)
+    RELOC_NUMBER (R_AVR32_DIFF8,		9)
+    RELOC_NUMBER (R_AVR32_GOT32,		10)
+    RELOC_NUMBER (R_AVR32_GOT16,		11)
+    RELOC_NUMBER (R_AVR32_GOT8,			12)
+
+    /* Normal Code Relocations */
+    RELOC_NUMBER (R_AVR32_21S,			13)
+    RELOC_NUMBER (R_AVR32_16U,			14)
+    RELOC_NUMBER (R_AVR32_16S,			15)
+    RELOC_NUMBER (R_AVR32_8S,			16)
+    RELOC_NUMBER (R_AVR32_8S_EXT,		17)
+
+    /* PC-Relative Code Relocations */
+    RELOC_NUMBER (R_AVR32_22H_PCREL,		18)
+    RELOC_NUMBER (R_AVR32_18W_PCREL,		19)
+    RELOC_NUMBER (R_AVR32_16B_PCREL,		20)
+    RELOC_NUMBER (R_AVR32_16N_PCREL,		21)
+    RELOC_NUMBER (R_AVR32_14UW_PCREL,		22)
+    RELOC_NUMBER (R_AVR32_11H_PCREL,		23)
+    RELOC_NUMBER (R_AVR32_10UW_PCREL,		24)
+    RELOC_NUMBER (R_AVR32_9H_PCREL,		25)
+    RELOC_NUMBER (R_AVR32_9UW_PCREL,		26)
+
+    /* Special Code Relocations */
+    RELOC_NUMBER (R_AVR32_HI16,			27)
+    RELOC_NUMBER (R_AVR32_LO16,			28)
+
+    /* PIC Relocations */
+    RELOC_NUMBER (R_AVR32_GOTPC,		29)
+    RELOC_NUMBER (R_AVR32_GOTCALL,		30)
+    RELOC_NUMBER (R_AVR32_LDA_GOT,		31)
+    RELOC_NUMBER (R_AVR32_GOT21S,		32)
+    RELOC_NUMBER (R_AVR32_GOT18SW,		33)
+    RELOC_NUMBER (R_AVR32_GOT16S,		34)
+    RELOC_NUMBER (R_AVR32_GOT7UW,		35)
+
+    /* Constant Pool Relocations */
+    RELOC_NUMBER (R_AVR32_32_CPENT,		36)
+    RELOC_NUMBER (R_AVR32_CPCALL,		37)
+    RELOC_NUMBER (R_AVR32_16_CP,		38)
+    RELOC_NUMBER (R_AVR32_9W_CP,		39)
+
+    /* Dynamic Relocations */
+    RELOC_NUMBER (R_AVR32_RELATIVE,		40)
+    RELOC_NUMBER (R_AVR32_GLOB_DAT,		41)
+    RELOC_NUMBER (R_AVR32_JMP_SLOT,		42)
+
+    /* Linkrelax Information */
+    RELOC_NUMBER (R_AVR32_ALIGN,		43)
+END_RELOC_NUMBERS (R_AVR32_max)
+
+/* Processor specific dynamic array tags.  */
+
+/* The total size in bytes of the Global Offset Table */
+#define DT_AVR32_GOTSZ			0x70000001
diff -Nrup gdb-6.7.1/include/elf/common.h gdb-6.7.1-atmel/include/elf/common.h
--- gdb-6.7.1/include/elf/common.h	2007-08-25 15:20:40.000000000 +0200
+++ gdb-6.7.1-atmel/include/elf/common.h	2008-04-03 15:00:35.000000000 +0200
@@ -217,6 +217,9 @@
 /* MSP430 magic number.  Written in the absense of everything.  */
 #define EM_MSP430_OLD		0x1059
 
+/* AVR32 magic number, picked by IAR Systems. */
+#define EM_AVR32        0x18ad
+
 /* Morpho MT.   Written in the absense of an ABI.  */
 #define EM_MT                   0x2530
 
diff -Nrup gdb-6.7.1/opcodes/avr32-asm.c gdb-6.7.1-atmel/opcodes/avr32-asm.c
--- gdb-6.7.1/opcodes/avr32-asm.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/opcodes/avr32-asm.c	2008-04-03 15:00:35.000000000 +0200
@@ -0,0 +1,233 @@
+/* Assembler interface for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include <string.h>
+
+#include "avr32-opc.h"
+#include "avr32-asm.h"
+
+/* Structure for a register hash table entry.  */
+struct reg_entry
+{
+  const char	*name;
+  int		number;
+};
+
+/* Integer Registers.  */
+static const struct reg_entry reg_table[] =
+  {
+    /* Primary names (used by the disassembler) */
+    { "r0",   0 }, { "r1",   1 }, { "r2",   2 }, { "r3",   3 },
+    { "r4",   4 }, { "r5",   5 }, { "r6",   6 }, { "r7",   7 },
+    { "r8",   8 }, { "r9",   9 }, { "r10", 10 }, { "r11", 11 },
+    { "r12", 12 }, { "sp",  13 }, { "lr",  14 }, { "pc",  15 },
+    /* Alternatives to sp, lr and pc.  */
+    { "r13", 13 }, { "r14", 14 }, { "r15", 15 },
+  };
+#define AVR32_NR_INTREGS (sizeof(reg_table)/sizeof(reg_table[0]))
+
+/* Coprocessor Registers.  */
+static const struct reg_entry cr_table[] =
+  {
+    { "cr0",   0 }, { "cr1",   1 }, { "cr2",   2 }, { "cr3",   3 },
+    { "cr4",   4 }, { "cr5",   5 }, { "cr6",   6 }, { "cr7",   7 },
+    { "cr8",   8 }, { "cr9",   9 }, { "cr10", 10 }, { "cr11", 11 },
+    { "cr12", 12 }, { "cr13", 13 }, { "cr14", 14 }, { "cr15", 15 },
+  };
+#define AVR32_NR_CPREGS (sizeof(cr_table)/sizeof(cr_table[0]))
+
+/* Floating-point Registers.  */
+static const struct reg_entry fr_table[] =
+  {
+    { "fr0",   0 }, { "fr1",   1 }, { "fr2",   2 }, { "fr3",   3 },
+    { "fr4",   4 }, { "fr5",   5 }, { "fr6",   6 }, { "fr7",   7 },
+    { "fr8",   8 }, { "fr9",   9 }, { "fr10", 10 }, { "fr11", 11 },
+    { "fr12", 12 }, { "fr13", 13 }, { "fr14", 14 }, { "fr15", 15 },
+  };
+#define AVR32_NR_FPREGS (sizeof(fr_table)/sizeof(fr_table[0]))
+
+int
+avr32_parse_intreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_INTREGS; i++)
+    {
+      if (strcasecmp(reg_table[i].name, str) == 0)
+	return reg_table[i].number;
+    }
+
+  return -1;
+}
+
+int
+avr32_parse_cpreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_CPREGS; i++)
+    {
+      if (strcasecmp(cr_table[i].name, str) == 0)
+	return cr_table[i].number;
+    }
+
+  return -1;
+}
+
+int avr32_parse_fpreg(const char *str)
+{
+  unsigned int i;
+
+  for (i = 0; i < AVR32_NR_FPREGS; i++)
+    {
+      if (strcasecmp(fr_table[i].name, str) == 0)
+	return fr_table[i].number;
+    }
+
+  return -1;
+}
+
+static unsigned long
+parse_reglist(char *str, char **endptr, int (*parse_reg)(const char *))
+{
+  int reg_from, reg_to;
+  unsigned long result = 0;
+  char *p1, *p2, c;
+
+  while (*str)
+    {
+      for (p1 = str; *p1; p1++)
+	if (*p1 == ',' || *p1 == '-')
+	  break;
+
+      c = *p1, *p1 = 0;
+      reg_from = parse_reg(str);
+      *p1 = c;
+
+      if (reg_from < 0)
+	break;
+
+      if (*p1 == '-')
+	{
+	  for (p2 = ++p1; *p2; p2++)
+	    if (*p2 == ',')
+	      break;
+
+	  c = *p2, *p2 = 0;
+	  /* printf("going to parse reg_to from `%s'\n", p1); */
+	  reg_to = parse_reg(p1);
+	  *p2 = c;
+
+	  if (reg_to < 0)
+	    break;
+
+	  while (reg_from <= reg_to)
+	    result |= (1 << reg_from++);
+	  p1 = p2;
+	}
+      else
+	result |= (1 << reg_from);
+
+      str = p1;
+      if (*str) ++str;
+    }
+
+  if (endptr)
+    *endptr = str;
+
+  return result;
+}
+
+unsigned long
+avr32_parse_reglist(char *str, char **endptr)
+{
+  return parse_reglist(str, endptr, avr32_parse_intreg);
+}
+
+unsigned long
+avr32_parse_cpreglist(char *str, char **endptr)
+{
+  return parse_reglist(str, endptr, avr32_parse_cpreg);
+}
+
+int
+avr32_make_regmask8(unsigned long regmask16, unsigned long *regmask8)
+{
+  unsigned long result = 0;
+
+  /* printf("convert regmask16 0x%04lx\n", regmask16); */
+
+  if (regmask16 & 0xf)
+    {
+      if ((regmask16 & 0xf) == 0xf)
+	result |= 1 << 0;
+      else
+	return -1;
+    }
+  if (regmask16 & 0xf0)
+    {
+      if ((regmask16 & 0xf0) == 0xf0)
+	result |= 1 << 1;
+      else
+	return -1;
+    }
+  if (regmask16 & 0x300)
+    {
+      if ((regmask16 & 0x300) == 0x300)
+	result |= 1 << 2;
+      else
+	return -1;
+    }
+  if (regmask16 & (1 << 13))
+    return -1;
+
+  if (regmask16 & (1 << 10))
+    result |= 1 << 3;
+  if (regmask16 & (1 << 11))
+    result |= 1 << 4;
+  if (regmask16 & (1 << 12))
+    result |= 1 << 5;
+  if (regmask16 & (1 << 14))
+    result |= 1 << 6;
+  if (regmask16 & (1 << 15))
+    result |= 1 << 7;
+
+  *regmask8 = result;
+
+  return 0;
+}
+
+#if 0
+struct reg_map
+{
+  const struct reg_entry	*names;
+  int				nr_regs;
+  struct hash_control		*htab;
+  const char			*errmsg;
+};
+
+struct reg_map all_reg_maps[] =
+  {
+    { reg_table, AVR32_NR_INTREGS, NULL, N_("integral register expected") },
+    { cr_table,  AVR32_NR_CPREGS,  NULL, N_("coprocessor register expected") },
+  };
+#endif
diff -Nrup gdb-6.7.1/opcodes/avr32-asm.h gdb-6.7.1-atmel/opcodes/avr32-asm.h
--- gdb-6.7.1/opcodes/avr32-asm.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/opcodes/avr32-asm.h	2008-04-03 15:00:35.000000000 +0200
@@ -0,0 +1,38 @@
+/* Assembler interface for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+#ifndef __OPCODES_AVR32_ASM_H
+#define __OPCODES_AVR32_ASM_H
+
+extern int
+avr32_parse_intreg(const char *str);
+extern int
+avr32_parse_cpreg(const char *str);
+extern int
+avr32_parse_fpreg(const char *str);
+extern unsigned long
+avr32_parse_reglist(char *str, char **endptr);
+extern unsigned long
+avr32_parse_cpreglist(char *str, char **endptr);
+extern int
+avr32_make_regmask8(unsigned long regmask16, unsigned long *regmask8);
+
+#endif /* __OPCODES_AVR32_ASM_H */
diff -Nrup gdb-6.7.1/opcodes/avr32-dis.c gdb-6.7.1-atmel/opcodes/avr32-dis.c
--- gdb-6.7.1/opcodes/avr32-dis.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/opcodes/avr32-dis.c	2008-04-03 15:00:35.000000000 +0200
@@ -0,0 +1,891 @@
+/* Print AVR32 instructions for GDB and objdump.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "sysdep.h"
+#include "dis-asm.h"
+#include "avr32-opc.h"
+#include "opintl.h"
+#include "safe-ctype.h"
+
+/* TODO: Share this with -asm */
+
+/* Structure for a register hash table entry.  */
+struct reg_entry
+{
+  const char	*name;
+  int		number;
+};
+
+#ifndef strneq
+#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
+#endif
+
+
+static const struct reg_entry reg_table[] =
+  {
+    /* Primary names (used by the disassembler) */
+    { "r0",   0 }, { "r1",   1 }, { "r2",   2 }, { "r3",   3 },
+    { "r4",   4 }, { "r5",   5 }, { "r6",   6 }, { "r7",   7 },
+    { "r8",   8 }, { "r9",   9 }, { "r10", 10 }, { "r11", 11 },
+    { "r12", 12 }, { "sp",  13 }, { "lr",  14 }, { "pc",  15 },
+    /* Alternatives to sp, lr and pc.  */
+    { "r13", 13 }, { "r14", 14 }, { "r15", 15 },
+  };
+#define AVR32_NR_INTREGS (sizeof(reg_table)/sizeof(reg_table[0]))
+
+/* Coprocessor Registers.  */
+static const struct reg_entry cr_table[] =
+  {
+    { "cr0",   0 }, { "cr1",   1 }, { "cr2",   2 }, { "cr3",   3 },
+    { "cr4",   4 }, { "cr5",   5 }, { "cr6",   6 }, { "cr7",   7 },
+    { "cr8",   8 }, { "cr9",   9 }, { "cr10", 10 }, { "cr11", 11 },
+    { "cr12", 12 }, { "cr13", 13 }, { "cr14", 14 }, { "cr15", 15 },
+  };
+#define AVR32_NR_CPREGS (sizeof(cr_table)/sizeof(cr_table[0]))
+
+static const char bparts[4] = { 'b', 'l', 'u', 't' };
+static bfd_vma current_pc;
+
+struct avr32_field_value
+{
+  const struct avr32_ifield *ifield;
+  unsigned long value;
+};
+
+struct avr32_operand
+{
+  int id;
+  int is_pcrel;
+  int align_order;
+  int (*print)(struct avr32_operand *op, struct disassemble_info *info,
+	       struct avr32_field_value *ifields);
+};
+
+static signed long
+get_signed_value(const struct avr32_field_value *fv)
+{
+  signed long value = fv->value;
+
+  if (fv->value & (1 << (fv->ifield->bitsize - 1)))
+    value |= (~0UL << fv->ifield->bitsize);
+
+  return value;
+}
+
+static void
+print_reglist_range(unsigned int first, unsigned int last,
+		    const struct reg_entry *reg_names,
+		    int need_comma,
+		    struct disassemble_info *info)
+{
+  if (need_comma)
+    info->fprintf_func(info->stream, ",");
+
+  if (first == last)
+    info->fprintf_func(info->stream, "%s",
+		       reg_names[first].name);
+  else
+    info->fprintf_func(info->stream, "%s-%s",
+		       reg_names[first].name, reg_names[last].name);
+}
+
+static int
+print_intreg(struct avr32_operand *op,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  unsigned long regid = ifields[0].value << op->align_order;
+
+  info->fprintf_func(info->stream, "%s",
+		     reg_table[regid].name);
+  return 1;
+}
+
+static int
+print_intreg_predec(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		    struct disassemble_info *info,
+		    struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "--%s",
+		     reg_table[ifields[0].value].name);
+  return 1;
+}
+
+static int
+print_intreg_postinc(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		     struct disassemble_info *info,
+		     struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s++",
+		     reg_table[ifields[0].value].name);
+  return 1;
+}
+
+static int
+print_intreg_lsl(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		 struct disassemble_info *info,
+		 struct avr32_field_value *ifields)
+{
+  const char *rp = reg_table[ifields[0].value].name;
+  unsigned long sa = ifields[1].value;
+
+  if (sa)
+    info->fprintf_func(info->stream, "%s<<0x%lx", rp, sa);
+  else
+    info->fprintf_func(info->stream, "%s", rp);
+
+  return 2;
+}
+
+static int
+print_intreg_lsr(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		 struct disassemble_info *info,
+		 struct avr32_field_value *ifields)
+{
+  const char *rp = reg_table[ifields[0].value].name;
+  unsigned long sa = ifields[1].value;
+
+  if (sa)
+    info->fprintf_func(info->stream, "%s>>0x%lx", rp, sa);
+  else
+    info->fprintf_func(info->stream, "%s", rp);
+
+  return 2;
+}
+
+static int
+print_intreg_bpart(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s:%c",
+		     reg_table[ifields[0].value].name,
+		     bparts[ifields[1].value]);
+  return 2;
+}
+
+static int
+print_intreg_hpart(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s:%c",
+		     reg_table[ifields[0].value].name,
+		     ifields[1].value ? 't' : 'b');
+  return 2;
+}
+
+static int
+print_intreg_sdisp(struct avr32_operand *op,
+		  struct disassemble_info *info,
+		  struct avr32_field_value *ifields)
+{
+  signed long disp;
+
+  disp = get_signed_value(&ifields[1]) << op->align_order;
+
+  info->fprintf_func(info->stream, "%s[%ld]",
+		     reg_table[ifields[0].value].name, disp);
+  return 2;
+}
+
+static int
+print_intreg_udisp(struct avr32_operand *op,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s[0x%lx]",
+		     reg_table[ifields[0].value].name,
+		     ifields[1].value << op->align_order);
+  return 2;
+}
+
+static int
+print_intreg_index(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  const char *rb, *ri;
+  unsigned long sa = ifields[2].value;
+
+  rb = reg_table[ifields[0].value].name;
+  ri = reg_table[ifields[1].value].name;
+
+  if (sa)
+    info->fprintf_func(info->stream, "%s[%s<<0x%lx]", rb, ri, sa);
+  else
+    info->fprintf_func(info->stream, "%s[%s]", rb, ri);
+
+  return 3;
+}
+
+static int
+print_intreg_xindex(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		    struct disassemble_info *info,
+		    struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%s[%s:%c<<2]",
+		     reg_table[ifields[0].value].name,
+		     reg_table[ifields[1].value].name,
+		     bparts[ifields[2].value]);
+  return 3;
+}
+
+static int
+print_jmplabel(struct avr32_operand *op,
+	       struct disassemble_info *info,
+	       struct avr32_field_value *ifields)
+{
+  bfd_vma address, offset;
+
+  offset = get_signed_value(ifields) << op->align_order;
+  address = (current_pc & (~0UL << op->align_order)) + offset;
+
+  info->print_address_func(address, info);
+
+  return 1;
+}
+
+static int
+print_pc_disp(struct avr32_operand *op,
+	      struct disassemble_info *info,
+	      struct avr32_field_value *ifields)
+{
+  bfd_vma address, offset;
+
+  offset = ifields[0].value << op->align_order;
+  address = (current_pc & (~0UL << op->align_order)) + offset;
+
+  info->print_address_func(address, info);
+
+  return 1;
+}
+
+static int
+print_sp(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	 struct disassemble_info *info,
+	 struct avr32_field_value *ifields ATTRIBUTE_UNUSED)
+{
+  info->fprintf_func(info->stream, "sp");
+  return 1;
+}
+
+static int
+print_sp_disp(struct avr32_operand *op,
+	      struct disassemble_info *info,
+	      struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "sp[0x%lx]",
+		     ifields[0].value << op->align_order);
+  return 1;
+}
+
+static int
+print_cpno(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	   struct disassemble_info *info,
+	   struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "cp%lu", ifields[0].value);
+  return 1;
+}
+
+static int
+print_cpreg(struct avr32_operand *op,
+	    struct disassemble_info *info,
+	    struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "cr%lu",
+		     ifields[0].value << op->align_order);
+  return 1;
+}
+
+static int
+print_uconst(struct avr32_operand *op,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "0x%lx",
+		     ifields[0].value << op->align_order);
+  return 1;
+}
+
+static int
+print_sconst(struct avr32_operand *op,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  info->fprintf_func(info->stream, "%ld",
+		     get_signed_value(ifields) << op->align_order);
+  return 1;
+}
+
+static int
+print_reglist8_head(unsigned long regmask, int *commap,
+		    struct disassemble_info *info)
+{
+  int first = -1, last, i = 0;
+  int need_comma = 0;
+
+  while (i < 12)
+    {
+      if (first == -1 && (regmask & 1))
+	{
+	  first = i;
+	}
+      else if (first != -1 && !(regmask & 1))
+	{
+	  last = i - 1;
+
+	  print_reglist_range(first, last, reg_table, need_comma, info);
+	  need_comma = 1;
+	  first = -1;
+	}
+
+      if (i < 8)
+	i += 4;
+      else if (i < 10)
+	i += 2;
+      else
+	i++;
+      regmask >>= 1;
+    }
+
+  *commap = need_comma;
+  return first;
+}
+
+static void
+print_reglist8_tail(unsigned long regmask, int first, int need_comma,
+		    struct disassemble_info *info)
+{
+  int last = 11;
+
+  if (regmask & 0x20)
+    {
+      if (first == -1)
+	first = 12;
+      last = 12;
+    }
+
+  if (first != -1)
+    {
+      print_reglist_range(first, last, reg_table, need_comma, info);
+      need_comma = 1;
+      first = -1;
+    }
+
+  if (regmask & 0x40)
+    {
+      if (first == -1)
+	first = 14;
+      last = 14;
+    }
+
+  if (regmask & 0x80)
+    {
+      if (first == -1)
+	first = 15;
+      last = 15;
+    }
+
+  if (first != -1)
+    print_reglist_range(first, last, reg_table, need_comma, info);
+}
+
+static int
+print_reglist8(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	       struct disassemble_info *info,
+	       struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  int first, need_comma;
+
+  first = print_reglist8_head(regmask, &need_comma, info);
+  print_reglist8_tail(regmask, first, need_comma, info);
+
+  return 1;
+}
+
+static int
+print_reglist9(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	       struct disassemble_info *info,
+	       struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value >> 1;
+  int first, last, need_comma;
+
+  first = print_reglist8_head(regmask, &need_comma, info);
+
+  if ((ifields[0].value & 0x101) == 0x101)
+    {
+      if (first != -1)
+	{
+	  last = 11;
+
+	  print_reglist_range(first, last, reg_table, need_comma, info);
+	  need_comma = 1;
+	  first = -1;
+	}
+
+      print_reglist_range(15, 15, reg_table, need_comma, info);
+
+      regmask >>= 5;
+
+      if ((regmask & 3) == 0)
+	info->fprintf_func(info->stream, ",r12=0");
+      else if ((regmask & 3) == 1)
+	info->fprintf_func(info->stream, ",r12=1");
+      else
+	info->fprintf_func(info->stream, ",r12=-1");
+    }
+  else
+      print_reglist8_tail(regmask, first, need_comma, info);
+
+  return 1;
+}
+
+static int
+print_reglist16(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		struct disassemble_info *info,
+		struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  unsigned int i = 0, first, last;
+  int need_comma = 0;
+
+  while (i < 16)
+    {
+      if (regmask & 1)
+	{
+	  first = i;
+	  while (i < 16)
+	    {
+	      i++;
+	      regmask >>= 1;
+	      if (!(regmask & 1))
+		break;
+	    }
+	  last = i - 1;
+	  print_reglist_range(first, last, reg_table, need_comma, info);
+	  need_comma = 1;
+	}
+      else
+	{
+	  i++;
+	  regmask >>= 1;
+	}
+    }
+
+  return 1;
+}
+
+static int
+print_reglist_ldm(struct avr32_operand *op,
+		  struct disassemble_info *info,
+		  struct avr32_field_value *ifields)
+{
+  int rp, w_bit;
+  int i, first, last;
+  unsigned long regmask;
+
+  rp = ifields[0].value;
+  w_bit = ifields[1].value;
+  regmask = ifields[2].value;
+
+  if (regmask & (1 << AVR32_REG_PC) && rp == AVR32_REG_PC)
+    {
+      if (w_bit)
+	info->fprintf_func(info->stream, "sp++");
+      else
+	info->fprintf_func(info->stream, "sp");
+
+      for (i = 0; i < 12; )
+	{
+	  if (regmask & (1 << i))
+	    {
+	      first = i;
+	      while (i < 12)
+		{
+		  i++;
+		  if (!(regmask & (1 << i)))
+		    break;
+		}
+	      last = i - 1;
+	      print_reglist_range(first, last, reg_table, 1, info);
+	    }
+	  else
+	    i++;
+	}
+
+      info->fprintf_func(info->stream, ",pc");
+      if (regmask & (1 << AVR32_REG_LR))
+	info->fprintf_func(info->stream, ",r12=-1");
+      else if (regmask & (1 << AVR32_REG_R12))
+	info->fprintf_func(info->stream, ",r12=1");
+      else
+	info->fprintf_func(info->stream, ",r12=0");
+    }
+  else
+    {
+      if (w_bit)
+	info->fprintf_func(info->stream, "%s++,", reg_table[rp].name);
+      else
+	info->fprintf_func(info->stream, "%s,", reg_table[rp].name);
+
+      print_reglist16(op, info, ifields + 2);
+    }
+
+  return 3;
+}
+
+static int
+print_reglist_cp8(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		  struct disassemble_info *info,
+		  struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  unsigned int i = 0, first, last, offset = 0;
+  int need_comma = 0;
+
+  if (ifields[1].value)
+    offset = 8;
+
+  while (i < 8)
+    {
+      if (regmask & 1)
+	{
+	  first = i;
+	  while (i < 8)
+	    {
+	      i++;
+	      regmask >>= 1;
+	      if (!(regmask & 1))
+		break;
+	    }
+	  last = i - 1;
+	  print_reglist_range(offset + first, offset + last,
+			      cr_table, need_comma, info);
+	  need_comma = 1;
+	}
+      else
+	{
+	  i++;
+	  regmask >>= 1;
+	}
+    }
+
+  return 2;
+}
+
+static int
+print_reglist_cpd8(struct avr32_operand *op ATTRIBUTE_UNUSED,
+		   struct disassemble_info *info,
+		   struct avr32_field_value *ifields)
+{
+  unsigned long regmask = ifields[0].value;
+  unsigned int i = 0, first, last;
+  int need_comma = 0;
+
+  while (i < 8)
+    {
+      if (regmask & 1)
+	{
+	  first = 2 * i;
+	  while (i < 8)
+	    {
+	      i++;
+	      regmask >>= 1;
+	      if (!(regmask & 1))
+		break;
+	    }
+	  last = 2 * (i - 1) + 1;
+	  print_reglist_range(first, last, cr_table, need_comma, info);
+	  need_comma = 1;
+	}
+      else
+	{
+	  i++;
+	  regmask >>= 1;
+	}
+    }
+
+  return 1;
+}
+
+static int
+print_retval(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	     struct disassemble_info *info,
+	     struct avr32_field_value *ifields)
+{
+  unsigned long regid = ifields[0].value;
+  const char *retval;
+
+  if (regid < AVR32_REG_SP)
+    retval = reg_table[regid].name;
+  else if (regid == AVR32_REG_SP)
+    retval = "0";
+  else if (regid == AVR32_REG_LR)
+    retval = "-1";
+  else
+    retval = "1";
+
+  info->fprintf_func(info->stream, "%s", retval);
+
+  return 1;
+}
+
+static int
+print_mcall(struct avr32_operand *op,
+	    struct disassemble_info *info,
+	    struct avr32_field_value *ifields)
+{
+  unsigned long regid = ifields[0].value;
+
+  if (regid == AVR32_REG_PC)
+    print_jmplabel(op, info, ifields + 1);
+  else
+    print_intreg_sdisp(op, info, ifields);
+
+  return 2;
+}
+
+static int
+print_jospinc(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	      struct disassemble_info *info,
+	      struct avr32_field_value *ifields)
+{
+  signed long value = ifields[0].value;
+
+  if (value >= 4)
+    value -= 8;
+  else
+    value += 1;
+
+  info->fprintf_func(info->stream, "%ld", value);
+
+  return 1;
+}
+
+static int
+print_coh(struct avr32_operand *op ATTRIBUTE_UNUSED,
+	  struct disassemble_info *info,
+	  struct avr32_field_value *ifields ATTRIBUTE_UNUSED)
+{
+  info->fprintf_func(info->stream, "COH");
+  return 0;
+}
+
+#define OP(name, sgn, pcrel, align, func) \
+  { AVR32_OPERAND_##name, pcrel, align, print_##func }
+
+struct avr32_operand operand[AVR32_NR_OPERANDS] =
+  {
+    OP(INTREG, 0, 0, 0, intreg),
+    OP(INTREG_PREDEC, 0, 0, 0, intreg_predec),
+    OP(INTREG_POSTINC, 0, 0, 0, intreg_postinc),
+    OP(INTREG_LSL, 0, 0, 0, intreg_lsl),
+    OP(INTREG_LSR, 0, 0, 0, intreg_lsr),
+    OP(INTREG_BSEL, 0, 0, 0, intreg_bpart),
+    OP(INTREG_HSEL, 0, 0, 1, intreg_hpart),
+    OP(INTREG_SDISP, 1, 0, 0, intreg_sdisp),
+    OP(INTREG_SDISP_H, 1, 0, 1, intreg_sdisp),
+    OP(INTREG_SDISP_W, 1, 0, 2, intreg_sdisp),
+    OP(INTREG_UDISP, 0, 0, 0, intreg_udisp),
+    OP(INTREG_UDISP_H, 0, 0, 1, intreg_udisp),
+    OP(INTREG_UDISP_W, 0, 0, 2, intreg_udisp),
+    OP(INTREG_INDEX, 0, 0, 0, intreg_index),
+    OP(INTREG_XINDEX, 0, 0, 0, intreg_xindex),
+    OP(DWREG, 0, 0, 1, intreg),
+    OP(PC_UDISP_W, 0, 1, 2, pc_disp),
+    OP(SP, 0, 0, 0, sp),
+    OP(SP_UDISP_W, 0, 0, 2, sp_disp),
+    OP(CPNO, 0, 0, 0, cpno),
+    OP(CPREG, 0, 0, 0, cpreg),
+    OP(CPREG_D, 0, 0, 1, cpreg),
+    OP(UNSIGNED_CONST, 0, 0, 0, uconst),
+    OP(UNSIGNED_CONST_W, 0, 0, 2, uconst),
+    OP(SIGNED_CONST, 1, 0, 0, sconst),
+    OP(SIGNED_CONST_W, 1, 0, 2, sconst),
+    OP(JMPLABEL, 1, 1, 1, jmplabel),
+    OP(UNSIGNED_NUMBER, 0, 0, 0, uconst),
+    OP(UNSIGNED_NUMBER_W, 0, 0, 2, uconst),
+    OP(REGLIST8, 0, 0, 0, reglist8),
+    OP(REGLIST9, 0, 0, 0, reglist9),
+    OP(REGLIST16, 0, 0, 0, reglist16),
+    OP(REGLIST_LDM, 0, 0, 0, reglist_ldm),
+    OP(REGLIST_CP8, 0, 0, 0, reglist_cp8),
+    OP(REGLIST_CPD8, 0, 0, 0, reglist_cpd8),
+    OP(RETVAL, 0, 0, 0, retval),
+    OP(MCALL, 1, 0, 2, mcall),
+    OP(JOSPINC, 0, 0, 0, jospinc),
+    OP(COH, 0, 0, 0, coh),
+  };
+
+static void
+print_opcode(bfd_vma insn_word, const struct avr32_opcode *opc,
+	     bfd_vma pc, struct disassemble_info *info)
+{
+  const struct avr32_syntax *syntax = opc->syntax;
+  struct avr32_field_value fields[AVR32_MAX_FIELDS];
+  unsigned int i, next_field = 0, nr_operands;
+
+  for (i = 0; i < opc->nr_fields; i++)
+    {
+      opc->fields[i]->extract(opc->fields[i], &insn_word, &fields[i].value);
+      fields[i].ifield = opc->fields[i];
+    }
+
+  current_pc = pc;
+  info->fprintf_func(info->stream, "%s", syntax->mnemonic->name);
+
+  if (syntax->nr_operands < 0)
+    nr_operands = (unsigned int) -syntax->nr_operands;
+  else
+    nr_operands = (unsigned int) syntax->nr_operands;
+
+  for (i = 0; i < nr_operands; i++)
+    {
+      struct avr32_operand *op = &operand[syntax->operand[i]];
+
+      if (i)
+	info->fprintf_func(info->stream, ",");
+      else
+	info->fprintf_func(info->stream, " ");
+      next_field += op->print(op, info, &fields[next_field]);
+    }
+}
+
+static const struct avr32_opcode *
+find_opcode(bfd_vma insn_word)
+{
+  int i;
+
+  for (i = 0; i < AVR32_NR_OPCODES; i++)
+    {
+      const struct avr32_opcode *opc = &avr32_opc_table[i];
+
+      if ((insn_word & opc->mask) == opc->value)
+	return opc;
+    }
+
+  return NULL;
+}
+
+static int
+read_insn_word(bfd_vma pc, bfd_vma *valuep,
+	       struct disassemble_info *info)
+{
+  bfd_byte b[4];
+  int status;
+
+  status = info->read_memory_func(pc, b, 4, info);
+  if (status)
+    {
+      status = info->read_memory_func(pc, b, 2, info);
+      if (status)
+	{
+	  info->memory_error_func(status, pc, info);
+	  return -1;
+	}
+      b[3] = b[2] = 0;
+    }
+
+  *valuep =  (b[0] << 24) | (b[1] << 16) | (b[2] << 8) | b[3];
+  return 0;
+}
+
+/* Parse an individual disassembler option.  */
+
+void
+parse_avr32_disassembler_option (option)
+     char * option;
+{
+  if (option == NULL)
+    return;
+
+  /* XXX - should break 'option' at following delimiter.  */
+  fprintf (stderr, _("Unrecognised disassembler option: %s\n"), option);
+
+  return;
+}
+
+/* Parse the string of disassembler options, spliting it at whitespaces
+   or commas.  (Whitespace separators supported for backwards compatibility).  */
+
+static void
+parse_disassembler_options (char *options)
+{
+  if (options == NULL)
+    return;
+
+  while (*options)
+    {
+      parse_avr32_disassembler_option (options);
+
+      /* Skip forward to next seperator.  */
+      while ((*options) && (! ISSPACE (*options)) && (*options != ','))
+	++ options;
+      /* Skip forward past seperators.  */
+      while (ISSPACE (*options) || (*options == ','))
+	++ options;
+    }
+}
+
+int
+print_insn_avr32(bfd_vma pc, struct disassemble_info *info)
+{
+  bfd_vma insn_word;
+  const struct avr32_opcode *opc;
+
+  if (info->disassembler_options)
+    {
+      parse_disassembler_options (info->disassembler_options);
+
+      /* To avoid repeated parsing of these options, we remove them here.  */
+      info->disassembler_options = NULL;
+    }
+
+  info->bytes_per_chunk = 1;
+  info->display_endian = BFD_ENDIAN_BIG;
+
+  if (read_insn_word(pc, &insn_word, info))
+    return -1;
+
+  opc = find_opcode(insn_word);
+  if (opc)
+    {
+      print_opcode(insn_word, opc, pc, info);
+      return opc->size;
+    }
+  else
+    {
+      info->fprintf_func(info->stream, _("*unknown*"));
+      return 2;
+    }
+
+}
+
+void
+print_avr32_disassembler_options (FILE *stream ATTRIBUTE_UNUSED)
+{
+
+}
diff -Nrup gdb-6.7.1/opcodes/avr32-opc.c gdb-6.7.1-atmel/opcodes/avr32-opc.c
--- gdb-6.7.1/opcodes/avr32-opc.c	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/opcodes/avr32-opc.c	2008-04-03 15:00:36.000000000 +0200
@@ -0,0 +1,6932 @@
+/* Opcode tables for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include <stdlib.h>
+#include <assert.h>
+
+#include "avr32-opc.h"
+
+#define PICO_CPNO   1
+
+void
+avr32_insert_simple(const struct avr32_ifield *field,
+            void *buf, unsigned long value)
+{
+  bfd_vma word;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  word |= (value << field->shift) & field->mask;
+  bfd_putb32(word, buf);
+}
+
+void
+avr32_insert_bit5c(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+           void *buf, unsigned long value)
+{
+  char *opcode = buf;
+
+  opcode[0] = (opcode[0] & 0xe1) | (value & 0x1e);
+  opcode[1] = (opcode[1] & 0xef) | ((value & 1) << 4);
+}
+
+void
+avr32_insert_k10(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+         void *buf, unsigned long value)
+{
+  char *opcode = buf;
+
+  opcode[0] = (opcode[0] & 0xf0) | ((value & 0xf0) >> 4);
+  opcode[1] = ((opcode[1] & 0x0c) | ((value & 0x0f) << 4)
+           | ((value & 0x300) >> 8));
+}
+
+
+void
+avr32_insert_k21(const struct avr32_ifield *field,
+         void *buf, unsigned long value)
+{
+  bfd_vma word;
+  bfd_vma k21;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  k21 = ((value & 0xffff) | ((value & 0x10000) << 4)
+     | ((value & 0x1e0000) << 8));
+  assert(!(k21 & ~field->mask));
+  word |= k21;
+  bfd_putb32(word, buf);
+}
+
+void
+avr32_insert_cpop(const struct avr32_ifield *field,
+          void *buf, unsigned long value)
+{
+  bfd_vma word;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  word |= (((value & 0x1e) << 15) | ((value & 0x60) << 20)
+       | ((value & 0x01) << 12));
+  bfd_putb32(word, buf);
+}
+
+void
+avr32_insert_k12cp(const struct avr32_ifield *field,
+           void *buf, unsigned long value)
+{
+  bfd_vma word;
+
+  word = bfd_getb32(buf);
+  word &= ~field->mask;
+  word |= ((value & 0xf00) << 4) | (value & 0xff);
+  bfd_putb32(word, buf);
+}
+
+void avr32_extract_simple(const struct avr32_ifield *field,
+              void *buf, unsigned long *value)
+{
+  /* XXX: The disassembler has done any necessary byteswapping already */
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = (word & field->mask) >> field->shift;
+}
+
+void avr32_extract_bit5c(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+             void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word >> 20) & 1) | ((word >> 24) & 0x1e);
+}
+
+void avr32_extract_k10(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+               void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word >> 8) & 0x300) | ((word >> 20) & 0xff);
+}
+
+void avr32_extract_k21(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+               void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word & 0xffff) | ((word >> 4) & 0x10000)
+        | ((word >> 8) & 0x1e0000));
+}
+
+void avr32_extract_cpop(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+            void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = (((word >> 12) & 1) | ((word >> 15) & 0x1e)
+        | ((word >> 20) & 0x60));
+}
+
+void avr32_extract_k12cp(const struct avr32_ifield *field ATTRIBUTE_UNUSED,
+             void *buf, unsigned long *value)
+{
+  bfd_vma word = *(bfd_vma *)buf;
+
+  *value = ((word >> 4) & 0xf00) | (word & 0xff);
+}
+
+
+#define IFLD(id, bitsz, shift, mask, func) \
+  { AVR32_IFIELD_##id, bitsz, shift, mask, \
+    avr32_insert_##func, avr32_extract_##func }
+
+const struct avr32_ifield avr32_ifield_table[] =
+  {
+    IFLD(RX, 4, 25, 0x1e000000, simple),
+    IFLD(RY, 4, 16, 0x000f0000, simple),
+    IFLD(COND4C, 4, 20, 0x00f00000, simple),
+    IFLD(K8C, 8, 20, 0x0ff00000, simple),
+    IFLD(K7C, 7, 20, 0x07f00000, simple),
+    IFLD(K5C, 5, 20, 0x01f00000, simple),
+    IFLD(K3, 3, 20, 0x00700000, simple),
+    IFLD(RY_DW, 3, 17, 0x000e0000, simple),
+    IFLD(COND4E, 4, 8, 0x00000f00, simple),
+    IFLD(K8E, 8, 0, 0x000000ff, simple),
+    IFLD(BIT5C, 5, 20, 0x1e100000, bit5c),
+    IFLD(COND3, 3, 16, 0x00070000, simple),
+    IFLD(K10, 10, 16, 0x0ff30000, k10),
+    IFLD(POPM, 9, 19, 0x0ff80000, simple),
+    IFLD(K2, 2, 4, 0x00000030, simple),
+    IFLD(RD_E, 4, 0, 0x0000000f, simple),
+    IFLD(RD_DW, 3, 1, 0x0000000e, simple),
+    IFLD(X, 1, 5, 0x00000020, simple),
+    IFLD(Y, 1, 4, 0x00000010, simple),
+    IFLD(X2, 1, 13, 0x00002000, simple),
+    IFLD(Y2, 1, 12, 0x00001000, simple),
+    IFLD(K5E, 5, 0, 0x0000001f, simple),
+    IFLD(PART2, 2, 0, 0x00000003, simple),
+    IFLD(PART1, 1, 0, 0x00000001, simple),
+    IFLD(K16, 16, 0, 0x0000ffff, simple),
+    IFLD(CACHEOP, 5, 11, 0x0000f800, simple),
+    IFLD(K11, 11, 0, 0x000007ff, simple),
+    IFLD(K21, 21, 0, 0x1e10ffff, k21),
+    IFLD(CPOP, 7, 12, 0x060f1000, cpop),
+    IFLD(CPNO, 3, 13, 0x0000e000, simple),
+    IFLD(CRD_RI, 4, 8, 0x00000f00, simple),
+    IFLD(CRX, 4, 4, 0x000000f0, simple),
+    IFLD(CRY, 4, 0, 0x0000000f, simple),
+    IFLD(K7E, 7, 0, 0x0000007f, simple),
+    IFLD(CRD_DW, 3, 9, 0x00000e00, simple),
+    IFLD(PART1_K12, 1, 12, 0x00001000, simple),
+    IFLD(PART2_K12, 2, 12, 0x00003000, simple),
+    IFLD(K12, 12, 0, 0x00000fff, simple),
+    IFLD(S5, 5, 5, 0x000003e0, simple),
+    IFLD(K5E2, 5, 4, 0x000001f0, simple),
+    IFLD(K4, 4, 20, 0x00f00000, simple),
+    IFLD(COND4E2, 4, 4, 0x000000f0, simple),
+    IFLD(K8E2, 8, 4, 0x00000ff0, simple),
+    IFLD(K6, 6, 20, 0x03f00000, simple),
+    IFLD(MEM15, 15, 0, 0x00007fff, simple),
+    IFLD(MEMB5, 5, 15, 0x000f8000, simple),
+    IFLD(W, 1, 25, 0x02000000, simple),
+    /* Coprocessor Multiple High/Low */
+    IFLD(CM_HL, 1, 8, 0x00000100, simple),
+    IFLD(K12CP, 12 ,0, 0x0000f0ff, k12cp),
+    IFLD(K9E, 9 ,0, 0x000001ff, simple),
+  };
+#undef IFLD
+
+
+struct avr32_opcode avr32_opc_table[] =
+  {
+    {
+      AVR32_OPC_ABS, 2, 0x5c400000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ABS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_ACALL, 2, 0xd0000000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_ACALL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_ACR, 2, 0x5c000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ACR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ADC, 4, 0xe0000040, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADC],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ADD1, 2, 0x00000000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ADD1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_ADD2, 4, 0xe0000000, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADD2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_ADDABS, 4, 0xe0000e40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADDABS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ADDHH_W, 4, 0xe0000e00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ADDHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_AND1, 2, 0x00600000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_AND1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_AND2, 4, 0xe1e00000, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_AND2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_AND3, 4, 0xe1e00200, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_AND3],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_ANDH, 4, 0xe4100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDH_COH, 4, 0xe6100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDH_COH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDL, 4, 0xe0100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDL],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDL_COH, 4, 0xe2100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDL_COH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ANDN, 2, 0x00800000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ANDN],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_ASR1, 4, 0xe0000840, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_ASR1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ASR3, 4, 0xe0001400, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_ASR3],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_ASR2, 2, 0xa1400000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ASR2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_BLD, 4, 0xedb00000, 0xfff0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_BLD],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_BREQ1, 2, 0xc0000000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREQ1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRNE1, 2, 0xc0010000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRNE1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRCC1, 2, 0xc0020000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRCC1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRCS1, 2, 0xc0030000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRCS1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRGE1, 2, 0xc0040000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRGE1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRLT1, 2, 0xc0050000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLT1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRMI1, 2, 0xc0060000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRMI1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BRPL1, 2, 0xc0070000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRPL1],
+      BFD_RELOC_AVR32_9H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_BREQ2, 4, 0xe0800000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREQ2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRNE2, 4, 0xe0810000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRNE2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRCC2, 4, 0xe0820000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRHS2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRCS2, 4, 0xe0830000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLO2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRGE2, 4, 0xe0840000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRGE2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRLT2, 4, 0xe0850000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLT2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRMI2, 4, 0xe0860000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRMI2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRPL2, 4, 0xe0870000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRPL2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRLS, 4, 0xe0880000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLS],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRGT, 4, 0xe0890000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRGT],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRLE, 4, 0xe08a0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRLE],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRHI, 4, 0xe08b0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRHI],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRVS, 4, 0xe08c0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRVS],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRVC, 4, 0xe08d0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRVC],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRQS, 4, 0xe08e0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRQS],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BRAL, 4, 0xe08f0000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BRAL],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_BREAKPOINT, 2, 0xd6730000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREAKPOINT],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_BREV, 2, 0x5c900000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_BREV],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_BST, 4, 0xefb00000, 0xfff0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_BST],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_CACHE, 4, 0xf4100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CACHE],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K11],
+    &avr32_ifield_table[AVR32_IFIELD_CACHEOP],
+      },
+    },
+    {
+      AVR32_OPC_CASTS_B, 2, 0x5c600000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTS_B],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CASTS_H, 2, 0x5c800000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTS_H],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CASTU_B, 2, 0x5c500000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTU_B],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CASTU_H, 2, 0x5c700000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CASTU_H],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CBR, 2, 0xa1c00000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CBR],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_CLZ, 4, 0xe0001200, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CLZ],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_COM, 2, 0x5cd00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_COM],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_COP, 4, 0xe1a00000, 0xf9f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_COP],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_CRX],
+    &avr32_ifield_table[AVR32_IFIELD_CRY],
+    &avr32_ifield_table[AVR32_IFIELD_CPOP],
+      },
+    },
+    {
+      AVR32_OPC_CP_B, 4, 0xe0001800, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_B],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CP_H, 4, 0xe0001900, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_H],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CP_W1, 2, 0x00300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_W1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CP_W2, 2, 0x58000000, 0xfc000000,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_W2],
+      BFD_RELOC_AVR32_6S, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K6],
+      },
+    },
+    {
+      AVR32_OPC_CP_W3, 4, 0xe0400000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CP_W3],
+      BFD_RELOC_AVR32_21S, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_CPC1, 4, 0xe0001300, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_CPC1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_CPC2, 2, 0x5c200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_CPC2],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_CSRF, 2, 0xd4030000, 0xfe0f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_CSRF],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_CSRFCZ, 2, 0xd0030000, 0xfe0f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_CSRFCZ],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_DIVS, 4, 0xe0000c00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_DIVS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_DIVU, 4, 0xe0000d00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_DIVU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_EOR1, 2, 0x00500000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_EOR1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_EOR2, 4, 0xe1e02000, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_EOR2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E2],
+      }
+    },
+    {
+      AVR32_OPC_EOR3, 4, 0xe1e02200, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_EOR3],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E2],
+      }
+    },
+    {
+      AVR32_OPC_EORL, 4, 0xec100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_EORL],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_EORH, 4, 0xee100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_EORH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_FRS, 2, 0xd7430000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_FRS],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_ICALL, 2, 0x5d100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ICALL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_INCJOSP, 2, 0xd6830000, 0xff8f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_INCJOSP],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_D1, 2, 0xa1010000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_D2, 2, 0xa1100000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_D3, 2, 0xa1000000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D3],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_D5, 4, 0xe0000200, 0xe1f0ffc1,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_D4, 4, 0xe0e00000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_D4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_SB2, 4, 0xe0000600, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SB2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_SB1, 4, 0xe1200000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SB1],
+      BFD_RELOC_AVR32_16S, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB1, 2, 0x01300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB2, 2, 0x01700000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB5, 4, 0xe0000700, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB3, 2, 0x01800000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB3],
+      BFD_RELOC_AVR32_3U, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_UB4, 4, 0xe1300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UB4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH1, 2, 0x01100000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH2, 2, 0x01500000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH5, 4, 0xe0000400, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH3, 2, 0x80000000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH3],
+      BFD_RELOC_AVR32_4UH, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_SH4, 4, 0xe1000000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_SH4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH1, 2, 0x01200000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH2, 2, 0x01600000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH5, 4, 0xe0000500, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH3, 2, 0x80800000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH3],
+      BFD_RELOC_AVR32_4UH, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K3],
+      },
+    },
+    {
+      AVR32_OPC_LD_UH4, 4, 0xe1100000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_UH4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LD_W1, 2, 0x01000000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_W2, 2, 0x01400000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_LD_W5, 4, 0xe0000300, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_W6, 4, 0xe0000f80, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W6],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LD_W3, 2, 0x60000000, 0xe0000000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W3],
+      BFD_RELOC_AVR32_7UW, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_LD_W4, 4, 0xe0f00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LD_W4],
+      BFD_RELOC_AVR32_16S, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDC_D1, 4, 0xe9a01000, 0xfff01100,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_D1],
+      BFD_RELOC_AVR32_10UW, 4, 3,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDC_D2, 4, 0xefa00050, 0xfff011ff,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_D2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LDC_D3, 4, 0xefa01040, 0xfff011c0,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_D3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LDC_W1, 4, 0xe9a00000, 0xfff01000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_W1],
+      BFD_RELOC_AVR32_10UW, 4, 3,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDC_W2, 4, 0xefa00040, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_W2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LDC_W3, 4, 0xefa01000, 0xfff010c0,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC_W3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_LDC0_D, 4, 0xf3a00000, 0xfff00100,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC0_D],
+      BFD_RELOC_AVR32_14UW, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K12CP],
+      },
+    },
+    {
+      AVR32_OPC_LDC0_W, 4, 0xf1a00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDC0_W],
+      BFD_RELOC_AVR32_14UW, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K12CP],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_D, 4, 0xeda00400, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_D_PU, 4, 0xeda01400, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_D_PU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_W, 4, 0xeda00000, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_LDCM_W_PU, 4, 0xeda01000, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_LDCM_W_PU],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_LDDPC, 2, 0x48000000, 0xf8000000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDDPC],
+      BFD_RELOC_AVR32_9UW_PCREL, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K7C],
+      },
+    },
+    {
+      AVR32_OPC_LDDPC_EXT, 4, 0xfef00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDDPC_EXT],
+      BFD_RELOC_AVR32_16B_PCREL, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDDSP, 2, 0x40000000, 0xf8000000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDDSP],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K7C],
+      },
+    },
+    {
+      AVR32_OPC_LDINS_B, 4, 0xe1d04000, 0xe1f0c000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDINS_B],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_PART2_K12],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDINS_H, 4, 0xe1d00000, 0xe1f0e000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDINS_H],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_PART1_K12],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDM, 4, 0xe1c00000, 0xfdf00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDM],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_W],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDMTS, 4, 0xe5c00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDMTS],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDMTS_PU, 4, 0xe7c00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDMTS_PU],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_LDSWP_SH, 4, 0xe1d02000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDSWP_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDSWP_UH, 4, 0xe1d03000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDSWP_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LDSWP_W, 4, 0xe1d08000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_LDSWP_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+      },
+    },
+    {
+      AVR32_OPC_LSL1, 4, 0xe0000940, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSL1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LSL3, 4, 0xe0001500, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSL3],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_LSL2, 2, 0xa1600000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LSL2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_LSR1, 4, 0xe0000a40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSR1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_LSR3, 4, 0xe0001600, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_LSR3],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_LSR2, 2, 0xa1800000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_LSR2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_MAC, 4, 0xe0000340, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MAC],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MACHH_D, 4, 0xe0000580, 0xe1f0ffc1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACHH_D],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MACHH_W, 4, 0xe0000480, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MACHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MACS_D, 4, 0xe0000540, 0xe1f0fff1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACS_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MACSATHH_W, 4, 0xe0000680, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MACSATHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MACUD, 4, 0xe0000740, 0xe1f0fff1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACUD],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MACWH_D, 4, 0xe0000c80, 0xe1f0ffe1,
+      &avr32_syntax_table[AVR32_SYNTAX_MACWH_D],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MAX, 4, 0xe0000c40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MAX],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MCALL, 4, 0xf0100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MCALL],
+      BFD_RELOC_AVR32_18W_PCREL, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_MFDR, 4, 0xe5b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MFDR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MFSR, 4, 0xe1b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MFSR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MIN, 4, 0xe0000d40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MIN],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MOV3, 2, 0x00900000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOV3],
+      BFD_RELOC_NONE, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOV1, 2, 0x30000000, 0xf0000000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOV1],
+      BFD_RELOC_AVR32_8S, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_MOV2, 4, 0xe0600000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOV2],
+      BFD_RELOC_AVR32_21S, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_MOVEQ1, 4, 0xe0001700, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVEQ1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVNE1, 4, 0xe0001710, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVNE1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVCC1, 4, 0xe0001720, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVCS1, 4, 0xe0001730, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLO1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVGE1, 4, 0xe0001740, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGE1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVLT1, 4, 0xe0001750, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLT1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVMI1, 4, 0xe0001760, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVMI1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVPL1, 4, 0xe0001770, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVPL1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVLS1, 4, 0xe0001780, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVGT1, 4, 0xe0001790, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGT1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVLE1, 4, 0xe00017a0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLE1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVHI1, 4, 0xe00017b0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHI1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVVS1, 4, 0xe00017c0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVVC1, 4, 0xe00017d0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVC1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVQS1, 4, 0xe00017e0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVQS1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVAL1, 4, 0xe00017f0, 0xe1f0ffff,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVAL1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MOVEQ2, 4, 0xf9b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVEQ2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVNE2, 4, 0xf9b00100, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVNE2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVCC2, 4, 0xf9b00200, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVCS2, 4, 0xf9b00300, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLO2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVGE2, 4, 0xf9b00400, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGE2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVLT2, 4, 0xf9b00500, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLT2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVMI2, 4, 0xf9b00600, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVMI2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVPL2, 4, 0xf9b00700, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVPL2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVLS2, 4, 0xf9b00800, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVGT2, 4, 0xf9b00900, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVGT2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVLE2, 4, 0xf9b00a00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVLE2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVHI2, 4, 0xf9b00b00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVHI2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVVS2, 4, 0xf9b00c00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVVC2, 4, 0xf9b00d00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVVC2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVQS2, 4, 0xf9b00e00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVQS2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MOVAL2, 4, 0xf9b00f00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVAL2],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MTDR, 4, 0xe7b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MTDR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MTSR, 4, 0xe3b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MTSR],
+      BFD_RELOC_AVR32_8S_EXT, 2, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MUL1, 2, 0xa1300000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MUL1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_MUL2, 4, 0xe0000240, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MUL2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MUL3, 4, 0xe0001000, 0xe1f0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_MUL3],
+      BFD_RELOC_AVR32_8S_EXT, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_MULHH_W, 4, 0xe0000780, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULNHH_W, 4, 0xe0000180, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULNHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULNWH_D, 4, 0xe0000280, 0xe1f0ffe1,
+      &avr32_syntax_table[AVR32_SYNTAX_MULNWH_D],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSD, 4, 0xe0000440, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSD],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MULSATHH_H, 4, 0xe0000880, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATHH_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATHH_W, 4, 0xe0000980, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATRNDHH_H, 4, 0xe0000a80, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATRNDHH_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATRNDWH_W, 4, 0xe0000b80, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATRNDWH_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULSATWH_W, 4, 0xe0000e80, 0xe1f0ffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_MULSATWH_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MULU_D, 4, 0xe0000640, 0xe1f0fff1,
+      &avr32_syntax_table[AVR32_SYNTAX_MULU_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MULWH_D, 4, 0xe0000d80, 0xe1f0ffe1,
+      &avr32_syntax_table[AVR32_SYNTAX_MULWH_D],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_MUSFR, 2, 0x5d300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MUSFR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_MUSTR, 2, 0x5d200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MUSTR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_MVCR_D, 4, 0xefa00010, 0xfff111ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVCR_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_MVCR_W, 4, 0xefa00000, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVCR_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_MVRC_D, 4, 0xefa00030, 0xfff111ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVRC_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_MVRC_W, 4, 0xefa00020, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_MVRC_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_NEG, 2, 0x5c300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_NEG],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_NOP, 2, 0xd7030000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_NOP],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_OR1, 2, 0x00400000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_OR1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_OR2, 4, 0xe1e01000, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_OR2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_OR3, 4, 0xe1e01200, 0xe1f0fe00,
+      &avr32_syntax_table[AVR32_SYNTAX_OR3],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E2],
+      },
+    },
+    {
+      AVR32_OPC_ORH, 4, 0xea100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ORH],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_ORL, 4, 0xe8100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ORL],
+      BFD_RELOC_AVR32_16U, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_PABS_SB, 4, 0xe00023e0, 0xfff0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PABS_SB],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PABS_SH, 4, 0xe00023f0, 0xfff0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PABS_SH],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PACKSH_SB, 4, 0xe00024d0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PACKSH_SB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PACKSH_UB, 4, 0xe00024c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PACKSH_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PACKW_SH, 4, 0xe0002470, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PACKW_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADD_B, 4, 0xe0002300, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADD_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADD_H, 4, 0xe0002000, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADD_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDH_SH, 4, 0xe00020c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDH_UB, 4, 0xe0002360, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDH_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_SB, 4, 0xe0002320, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_SB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_SH, 4, 0xe0002040, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_UB, 4, 0xe0002340, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDS_UH, 4, 0xe0002080, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUB_H, 4, 0xe0002100, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUB_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUBH_SH, 4, 0xe0002280, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUBH_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUBS_SH, 4, 0xe0002180, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUBS_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDSUBS_UH, 4, 0xe0002200, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDSUBS_UH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PADDX_H, 4, 0xe0002020, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDX_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDXH_SH, 4, 0xe00020e0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDXH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDXS_SH, 4, 0xe0002060, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDXS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PADDXS_UH, 4, 0xe00020a0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PADDXS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PASR_B, 4, 0xe0002410, 0xe1f8fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PASR_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_COND3],
+      },
+    },
+    {
+      AVR32_OPC_PASR_H, 4, 0xe0002440, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PASR_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PAVG_SH, 4, 0xe00023d0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PAVG_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PAVG_UB, 4, 0xe00023c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PAVG_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PLSL_B, 4, 0xe0002420, 0xe1f8fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSL_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_COND3],
+      },
+    },
+    {
+      AVR32_OPC_PLSL_H, 4, 0xe0002450, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSL_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PLSR_B, 4, 0xe0002430, 0xe1f8fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSR_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_COND3],
+      },
+    },
+    {
+      AVR32_OPC_PLSR_H, 4, 0xe0002460, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PLSR_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMAX_SH, 4, 0xe0002390, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMAX_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMAX_UB, 4, 0xe0002380, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMAX_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMIN_SH, 4, 0xe00023b0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMIN_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PMIN_UB, 4, 0xe00023a0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PMIN_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_POPJC, 2, 0xd7130000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_POPJC],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_POPM, 2, 0xd0020000, 0xf0070000,
+      &avr32_syntax_table[AVR32_SYNTAX_POPM],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_POPM],
+      },
+    },
+    {
+      AVR32_OPC_POPM_E, 4, 0xe3cd0000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_POPM_E],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_PREF, 4, 0xf2100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_PREF],
+      BFD_RELOC_AVR32_16S, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_PSAD, 4, 0xe0002400, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSAD],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUB_B, 4, 0xe0002310, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUB_B],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUB_H, 4, 0xe0002010, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADD_H, 4, 0xe0002140, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADD_H],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADDH_SH, 4, 0xe00022c0, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADDH_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADDS_SH, 4, 0xe00021c0, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADDS_SH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBADDS_UH, 4, 0xe0002240, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBADDS_UH],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PSUBH_SH, 4, 0xe00020d0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBH_UB, 4, 0xe0002370, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBH_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_SB, 4, 0xe0002330, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_SB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_SH, 4, 0xe0002050, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_UB, 4, 0xe0002350, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_UB],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBS_UH, 4, 0xe0002090, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBX_H, 4, 0xe0002030, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBX_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBXH_SH, 4, 0xe00020f0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBXH_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBXS_SH, 4, 0xe0002070, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBXS_SH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PSUBXS_UH, 4, 0xe00020b0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_PSUBXS_UH],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_PUNPCKSB_H, 4, 0xe00024a0, 0xe1ffffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_PUNPCKSB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PUNPCKUB_H, 4, 0xe0002480, 0xe1ffffe0,
+      &avr32_syntax_table[AVR32_SYNTAX_PUNPCKUB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_PUSHJC, 2, 0xd7230000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_PUSHJC],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_PUSHM, 2, 0xd0010000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_PUSHM],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_PUSHM_E, 4, 0xebcd0000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_PUSHM_E],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_RCALL1, 2, 0xc00c0000, 0xf00c0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RCALL1],
+      BFD_RELOC_AVR32_11H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K10],
+      },
+    },
+    {
+      AVR32_OPC_RCALL2, 4, 0xe0a00000, 0xe1ef0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RCALL2],
+      BFD_RELOC_AVR32_22H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_RETEQ, 2, 0x5e000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETEQ],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETNE, 2, 0x5e100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETNE],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETCC, 2, 0x5e200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETHS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETCS, 2, 0x5e300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLO],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETGE, 2, 0x5e400000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETGE],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETLT, 2, 0x5e500000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLT],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETMI, 2, 0x5e600000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETMI],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETPL, 2, 0x5e700000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETPL],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETLS, 2, 0x5e800000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETGT, 2, 0x5e900000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETGT],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETLE, 2, 0x5ea00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETLE],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETHI, 2, 0x5eb00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETHI],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETVS, 2, 0x5ec00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETVS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETVC, 2, 0x5ed00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETVC],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETQS, 2, 0x5ee00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETQS],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETAL, 2, 0x5ef00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETAL],
+      BFD_RELOC_NONE, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_RETD, 2, 0xd6230000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETD],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RETE, 2, 0xd6030000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETE],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RETJ, 2, 0xd6330000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETJ],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RETS, 2, 0xd6130000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RETS],
+      BFD_RELOC_NONE, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_RJMP, 2, 0xc0080000, 0xf00c0000,
+      &avr32_syntax_table[AVR32_SYNTAX_RJMP],
+      BFD_RELOC_AVR32_11H_PCREL, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K10],
+      },
+    },
+    {
+      AVR32_OPC_ROL, 2, 0x5cf00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ROL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_ROR, 2, 0x5d000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ROR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_RSUB1, 2, 0x00200000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_RSUB1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_RSUB2, 4, 0xe0001100, 0xe1f0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_RSUB2],
+      BFD_RELOC_AVR32_8S_EXT, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SATADD_H, 4, 0xe00002c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATADD_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATADD_W, 4, 0xe00000c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATADD_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATRNDS, 4, 0xf3b00000, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATRNDS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SATRNDU, 4, 0xf3b00400, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATRNDU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SATS, 4, 0xf1b00000, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATS],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SATSUB_H, 4, 0xe00003c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATSUB_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATSUB_W1, 4, 0xe00001c0, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SATSUB_W1],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SATSUB_W2, 4, 0xe0d00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SATSUB_W2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_SATU, 4, 0xf1b00400, 0xfff0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_SATU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+      },
+    },
+    {
+      AVR32_OPC_SBC, 4, 0xe0000140, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_SBC],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SBR, 2, 0xa1a00000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SBR],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_BIT5C],
+      },
+    },
+    {
+      AVR32_OPC_SCALL, 2, 0xd7330000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_SCALL],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_SCR, 2, 0x5c100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SCR],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SLEEP, 4, 0xe9b00000, 0xffffff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SLEEP],
+      BFD_RELOC_AVR32_8S_EXT, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SREQ, 2, 0x5f000000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SREQ],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRNE, 2, 0x5f100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRNE],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRCC, 2, 0x5f200000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRHS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRCS, 2, 0x5f300000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLO],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRGE, 2, 0x5f400000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRGE],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRLT, 2, 0x5f500000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLT],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRMI, 2, 0x5f600000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRMI],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRPL, 2, 0x5f700000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRPL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRLS, 2, 0x5f800000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRGT, 2, 0x5f900000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRGT],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRLE, 2, 0x5fa00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRLE],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRHI, 2, 0x5fb00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRHI],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRVS, 2, 0x5fc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRVS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRVC, 2, 0x5fd00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRVC],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRQS, 2, 0x5fe00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRQS],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SRAL, 2, 0x5ff00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SRAL],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SSRF, 2, 0xd2030000, 0xfe0f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_SSRF],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K5C],
+      },
+    },
+    {
+      AVR32_OPC_ST_B1, 2, 0x00c00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_B2, 2, 0x00f00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_B5, 4, 0xe0000b00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+      },
+    },
+    {
+      AVR32_OPC_ST_B3, 2, 0xa0800000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B3],
+      BFD_RELOC_AVR32_3U, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K3],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_B4, 4, 0xe1600000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_B4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_D1, 2, 0xa1200000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D2, 2, 0xa1210000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D3, 2, 0xa1110000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D3],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D5, 4, 0xe0000800, 0xe1f0ffc1,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_RD_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_D4, 4, 0xe0e10000, 0xe1f10000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_D4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+    &avr32_ifield_table[AVR32_IFIELD_RY_DW],
+      },
+    },
+    {
+      AVR32_OPC_ST_H1, 2, 0x00b00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_H2, 2, 0x00e00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_H5, 4, 0xe0000a00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+      },
+    },
+    {
+      AVR32_OPC_ST_H3, 2, 0xa0000000, 0xe1800000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H3],
+      BFD_RELOC_AVR32_4UH, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K3],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_H4, 4, 0xe1500000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_H4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W1, 2, 0x00a00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W2, 2, 0x00d00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W2],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W5, 4, 0xe0000900, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W5],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+      },
+    },
+    {
+      AVR32_OPC_ST_W3, 2, 0x81000000, 0xe1000000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W3],
+      BFD_RELOC_AVR32_6UW, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K4],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_ST_W4, 4, 0xe1400000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_ST_W4],
+      BFD_RELOC_AVR32_16S, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STC_D1, 4, 0xeba01000, 0xfff01100,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_D1],
+      BFD_RELOC_AVR32_10UW, 4, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC_D2, 4, 0xefa00070, 0xfff011f0,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_D2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC_D3, 4, 0xefa010c0, 0xfff011c0,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_D3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC_W1, 4, 0xeba00000, 0xfff01000,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_W1],
+      BFD_RELOC_AVR32_10UW, 4, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STC_W2, 4, 0xefa00060, 0xfff010ff,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_W2],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STC_W3, 4, 0xefa01080, 0xfff010c0,
+      &avr32_syntax_table[AVR32_SYNTAX_STC_W3],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STC0_D, 4, 0xf7a00000, 0xfff00100,
+      &avr32_syntax_table[AVR32_SYNTAX_STC0_D],
+      BFD_RELOC_AVR32_14UW, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K12CP],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_DW],
+      },
+    },
+    {
+      AVR32_OPC_STC0_W, 4, 0xf5a00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STC0_W],
+      BFD_RELOC_AVR32_14UW, 3, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K12CP],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+      },
+    },
+    {
+      AVR32_OPC_STCM_D, 4, 0xeda00500, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_D],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_STCM_D_PU, 4, 0xeda01500, 0xfff01f00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_D_PU],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_STCM_W, 4, 0xeda00200, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_W],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_STCM_W_PU, 4, 0xeda01200, 0xfff01e00,
+      &avr32_syntax_table[AVR32_SYNTAX_STCM_W_PU],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_CPNO],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+    &avr32_ifield_table[AVR32_IFIELD_CM_HL],
+      },
+    },
+    {
+      AVR32_OPC_STCOND, 4, 0xe1700000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STCOND],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STDSP, 2, 0x50000000, 0xf8000000,
+      &avr32_syntax_table[AVR32_SYNTAX_STDSP],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K7C],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STHH_W2, 4, 0xe1e08000, 0xe1f0c0c0,
+      &avr32_syntax_table[AVR32_SYNTAX_STHH_W2],
+      BFD_RELOC_UNUSED, 7, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_CRD_RI],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X2],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y2],
+      },
+    },
+    {
+      AVR32_OPC_STHH_W1, 4, 0xe1e0c000, 0xe1f0c000,
+      &avr32_syntax_table[AVR32_SYNTAX_STHH_W1],
+      BFD_RELOC_AVR32_STHH_W, 6, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_K8E2],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X2],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y2],
+      },
+    },
+    {
+      AVR32_OPC_STM, 4, 0xe9c00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STM],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STM_PU, 4, 0xebc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STM_PU],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STMTS, 4, 0xedc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STMTS],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STMTS_PU, 4, 0xefc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_STMTS_PU],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_STSWP_H, 4, 0xe1d09000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_STSWP_H],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_STSWP_W, 4, 0xe1d0a000, 0xe1f0f000,
+      &avr32_syntax_table[AVR32_SYNTAX_STSWP_W],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K12],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_SUB1, 2, 0x00100000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB1],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_SUB2, 4, 0xe0000100, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB2],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K2],
+      },
+    },
+    {
+      AVR32_OPC_SUB5, 4, 0xe0c00000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB5],
+      BFD_RELOC_AVR32_SUB5, 3, 2,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+    {
+      AVR32_OPC_SUB3_SP, 2, 0x200d0000, 0xf00f0000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB3_SP],
+      BFD_RELOC_AVR32_10SW, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_SUB3, 2, 0x20000000, 0xf0000000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB3],
+      BFD_RELOC_AVR32_8S, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8C],
+      },
+    },
+    {
+      AVR32_OPC_SUB4, 4, 0xe0200000, 0xe1e00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SUB4],
+      BFD_RELOC_AVR32_21S, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K21],
+      },
+    },
+    {
+      AVR32_OPC_SUBEQ, 4, 0xf7b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBEQ],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBNE, 4, 0xf7b00100, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBNE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBCC, 4, 0xf7b00200, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBHS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBCS, 4, 0xf7b00300, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLO],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBGE, 4, 0xf7b00400, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBGE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBLT, 4, 0xf7b00500, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBMI, 4, 0xf7b00600, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBMI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBPL, 4, 0xf7b00700, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBPL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBLS, 4, 0xf7b00800, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBGT, 4, 0xf7b00900, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBGT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBLE, 4, 0xf7b00a00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBLE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBHI, 4, 0xf7b00b00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBHI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBVS, 4, 0xf7b00c00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBVS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBVC, 4, 0xf7b00d00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBVC],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBQS, 4, 0xf7b00e00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBQS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBAL, 4, 0xf7b00f00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBAL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFEQ, 4, 0xf5b00000, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFEQ],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFNE, 4, 0xf5b00100, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFNE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFCC, 4, 0xf5b00200, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFHS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFCS, 4, 0xf5b00300, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLO],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFGE, 4, 0xf5b00400, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFGE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFLT, 4, 0xf5b00500, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFMI, 4, 0xf5b00600, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFMI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFPL, 4, 0xf5b00700, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFPL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFLS, 4, 0xf5b00800, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFGT, 4, 0xf5b00900, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFGT],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFLE, 4, 0xf5b00a00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFLE],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFHI, 4, 0xf5b00b00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFHI],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFVS, 4, 0xf5b00c00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFVS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFVC, 4, 0xf5b00d00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFVC],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFQS, 4, 0xf5b00e00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFQS],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBFAL, 4, 0xf5b00f00, 0xfff0ff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBFAL],
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      },
+    },
+    {
+      AVR32_OPC_SUBHH_W, 4, 0xe0000f00, 0xe1f0ffc0,
+      &avr32_syntax_table[AVR32_SYNTAX_SUBHH_W],
+      BFD_RELOC_UNUSED, 5, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_X],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_Y],
+      },
+    },
+    {
+      AVR32_OPC_SWAP_B, 2, 0x5cb00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SWAP_B],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_SWAP_BH, 2, 0x5cc00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SWAP_BH],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_SWAP_H, 2, 0x5ca00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_SWAP_H],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_SYNC, 4, 0xebb00000, 0xffffff00,
+      &avr32_syntax_table[AVR32_SYNTAX_SYNC],
+      BFD_RELOC_AVR32_8S_EXT, 1, 0,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_K8E],
+      }
+    },
+    {
+      AVR32_OPC_TLBR, 2, 0xd6430000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_TLBR],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_TLBS, 2, 0xd6530000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_TLBS],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_TLBW, 2, 0xd6630000, 0xffff0000,
+      &avr32_syntax_table[AVR32_SYNTAX_TLBW],
+      BFD_RELOC_UNUSED, 0, -1, { NULL },
+    },
+    {
+      AVR32_OPC_TNBZ, 2, 0x5ce00000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_TNBZ],
+      BFD_RELOC_UNUSED, 1, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      }
+    },
+    {
+      AVR32_OPC_TST, 2, 0x00700000, 0xe1f00000,
+      &avr32_syntax_table[AVR32_SYNTAX_TST],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+      },
+    },
+    {
+      AVR32_OPC_XCHG, 4, 0xe0000b40, 0xe1f0fff0,
+      &avr32_syntax_table[AVR32_SYNTAX_XCHG],
+      BFD_RELOC_UNUSED, 3, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+      },
+    },
+    {
+      AVR32_OPC_MEMC, 4, 0xf6100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MEMC],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_MEM15],
+    &avr32_ifield_table[AVR32_IFIELD_MEMB5],
+      },
+    },
+    {
+      AVR32_OPC_MEMS, 4, 0xf8100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MEMS],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_MEM15],
+    &avr32_ifield_table[AVR32_IFIELD_MEMB5],
+      },
+    },
+    {
+      AVR32_OPC_MEMT, 4, 0xfa100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MEMT],
+      BFD_RELOC_UNUSED, 2, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_MEM15],
+    &avr32_ifield_table[AVR32_IFIELD_MEMB5],
+      },
+    },
+    {
+      AVR32_OPC_BFEXTS, 4, 0xe1d0b000, 0xe1f0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_BFEXTS],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_BFEXTU, 4, 0xe1d0c000, 0xe1f0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_BFEXTU],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+    {
+      AVR32_OPC_BFINS, 4, 0xe1d0d000, 0xe1f0fc00,
+      &avr32_syntax_table[AVR32_SYNTAX_BFINS],
+      BFD_RELOC_UNUSED, 4, -1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RX],
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_S5],
+    &avr32_ifield_table[AVR32_IFIELD_K5E],
+      },
+    },
+#define AVR32_OPCODE_RSUBCOND(cond_name, cond_field)                    \
+    {                                                                   \
+      AVR32_OPC_RSUB ## cond_name , 4,                                  \
+      0xfbb00000 | (cond_field << 8), 0xfff0ff00,                       \
+      &avr32_syntax_table[AVR32_SYNTAX_RSUB ## cond_name ],             \
+      BFD_RELOC_AVR32_8S_EXT, 2, 1,                                     \
+      {                                                                 \
+    &avr32_ifield_table[AVR32_IFIELD_RY],                           \
+    &avr32_ifield_table[AVR32_IFIELD_K8E],                          \
+      },                                                                \
+    },
+
+    AVR32_OPCODE_RSUBCOND (EQ, 0) 
+    AVR32_OPCODE_RSUBCOND (NE, 1) 
+    AVR32_OPCODE_RSUBCOND (CC, 2) 
+    AVR32_OPCODE_RSUBCOND (CS, 3) 
+    AVR32_OPCODE_RSUBCOND (GE, 4) 
+    AVR32_OPCODE_RSUBCOND (LT, 5) 
+    AVR32_OPCODE_RSUBCOND (MI, 6) 
+    AVR32_OPCODE_RSUBCOND (PL, 7) 
+    AVR32_OPCODE_RSUBCOND (LS, 8) 
+    AVR32_OPCODE_RSUBCOND (GT, 9) 
+    AVR32_OPCODE_RSUBCOND (LE, 10) 
+    AVR32_OPCODE_RSUBCOND (HI, 11) 
+    AVR32_OPCODE_RSUBCOND (VS, 12) 
+    AVR32_OPCODE_RSUBCOND (VC, 13) 
+    AVR32_OPCODE_RSUBCOND (QS, 14) 
+    AVR32_OPCODE_RSUBCOND (AL, 15) 
+
+#define AVR32_OPCODE_OP3_COND(op_name, op_field, cond_name, cond_field) \
+    {                                                                   \
+      AVR32_OPC_ ## op_name ## cond_name , 4,                           \
+      0xe1d0e000 | (cond_field << 8) | (op_field << 4), 0xe1f0fff0,     \
+      &avr32_syntax_table[AVR32_SYNTAX_ ## op_name ## cond_name ],      \
+      BFD_RELOC_UNUSED, 3, -1,                                          \
+      {                                                                 \
+    &avr32_ifield_table[AVR32_IFIELD_RD_E],                         \
+    &avr32_ifield_table[AVR32_IFIELD_RX],                           \
+    &avr32_ifield_table[AVR32_IFIELD_RY],                           \
+      },                                                                \
+    },
+
+    AVR32_OPCODE_OP3_COND (ADD, 0, EQ, 0)
+    AVR32_OPCODE_OP3_COND (ADD, 0, NE, 1)
+    AVR32_OPCODE_OP3_COND (ADD, 0, CC, 2)
+    AVR32_OPCODE_OP3_COND (ADD, 0, CS, 3)
+    AVR32_OPCODE_OP3_COND (ADD, 0, GE, 4)
+    AVR32_OPCODE_OP3_COND (ADD, 0, LT, 5)
+    AVR32_OPCODE_OP3_COND (ADD, 0, MI, 6)
+    AVR32_OPCODE_OP3_COND (ADD, 0, PL, 7)
+    AVR32_OPCODE_OP3_COND (ADD, 0, LS, 8)
+    AVR32_OPCODE_OP3_COND (ADD, 0, GT, 9)
+    AVR32_OPCODE_OP3_COND (ADD, 0, LE, 10)
+    AVR32_OPCODE_OP3_COND (ADD, 0, HI, 11)
+    AVR32_OPCODE_OP3_COND (ADD, 0, VS, 12)
+    AVR32_OPCODE_OP3_COND (ADD, 0, VC, 13)
+    AVR32_OPCODE_OP3_COND (ADD, 0, QS, 14)
+    AVR32_OPCODE_OP3_COND (ADD, 0, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (SUB2, 1, EQ, 0)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, NE, 1)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, CC, 2)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, CS, 3)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, GE, 4)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, LT, 5)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, MI, 6)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, PL, 7)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, LS, 8)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, GT, 9)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, LE, 10)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, HI, 11)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, VS, 12)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, VC, 13)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, QS, 14)
+    AVR32_OPCODE_OP3_COND (SUB2, 1, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (AND, 2, EQ, 0)
+    AVR32_OPCODE_OP3_COND (AND, 2, NE, 1)
+    AVR32_OPCODE_OP3_COND (AND, 2, CC, 2)
+    AVR32_OPCODE_OP3_COND (AND, 2, CS, 3)
+    AVR32_OPCODE_OP3_COND (AND, 2, GE, 4)
+    AVR32_OPCODE_OP3_COND (AND, 2, LT, 5)
+    AVR32_OPCODE_OP3_COND (AND, 2, MI, 6)
+    AVR32_OPCODE_OP3_COND (AND, 2, PL, 7)
+    AVR32_OPCODE_OP3_COND (AND, 2, LS, 8)
+    AVR32_OPCODE_OP3_COND (AND, 2, GT, 9)
+    AVR32_OPCODE_OP3_COND (AND, 2, LE, 10)
+    AVR32_OPCODE_OP3_COND (AND, 2, HI, 11)
+    AVR32_OPCODE_OP3_COND (AND, 2, VS, 12)
+    AVR32_OPCODE_OP3_COND (AND, 2, VC, 13)
+    AVR32_OPCODE_OP3_COND (AND, 2, QS, 14)
+    AVR32_OPCODE_OP3_COND (AND, 2, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (OR, 3, EQ, 0)
+    AVR32_OPCODE_OP3_COND (OR, 3, NE, 1)
+    AVR32_OPCODE_OP3_COND (OR, 3, CC, 2)
+    AVR32_OPCODE_OP3_COND (OR, 3, CS, 3)
+    AVR32_OPCODE_OP3_COND (OR, 3, GE, 4)
+    AVR32_OPCODE_OP3_COND (OR, 3, LT, 5)
+    AVR32_OPCODE_OP3_COND (OR, 3, MI, 6)
+    AVR32_OPCODE_OP3_COND (OR, 3, PL, 7)
+    AVR32_OPCODE_OP3_COND (OR, 3, LS, 8)
+    AVR32_OPCODE_OP3_COND (OR, 3, GT, 9)
+    AVR32_OPCODE_OP3_COND (OR, 3, LE, 10)
+    AVR32_OPCODE_OP3_COND (OR, 3, HI, 11)
+    AVR32_OPCODE_OP3_COND (OR, 3, VS, 12)
+    AVR32_OPCODE_OP3_COND (OR, 3, VC, 13)
+    AVR32_OPCODE_OP3_COND (OR, 3, QS, 14)
+    AVR32_OPCODE_OP3_COND (OR, 3, AL, 15)
+
+    AVR32_OPCODE_OP3_COND (EOR, 4, EQ, 0)
+    AVR32_OPCODE_OP3_COND (EOR, 4, NE, 1)
+    AVR32_OPCODE_OP3_COND (EOR, 4, CC, 2)
+    AVR32_OPCODE_OP3_COND (EOR, 4, CS, 3)
+    AVR32_OPCODE_OP3_COND (EOR, 4, GE, 4)
+    AVR32_OPCODE_OP3_COND (EOR, 4, LT, 5)
+    AVR32_OPCODE_OP3_COND (EOR, 4, MI, 6)
+    AVR32_OPCODE_OP3_COND (EOR, 4, PL, 7)
+    AVR32_OPCODE_OP3_COND (EOR, 4, LS, 8)
+    AVR32_OPCODE_OP3_COND (EOR, 4, GT, 9)
+    AVR32_OPCODE_OP3_COND (EOR, 4, LE, 10)
+    AVR32_OPCODE_OP3_COND (EOR, 4, HI, 11)
+    AVR32_OPCODE_OP3_COND (EOR, 4, VS, 12)
+    AVR32_OPCODE_OP3_COND (EOR, 4, VC, 13)
+    AVR32_OPCODE_OP3_COND (EOR, 4, QS, 14)
+    AVR32_OPCODE_OP3_COND (EOR, 4, AL, 15) 
+
+#define AVR32_OPCODE_LD_COND(op_name, op_field, cond_name, cond_field)  \
+    {                                                                   \
+      AVR32_OPC_ ## op_name ## cond_name , 4,                           \
+      0xe1f00000 | (cond_field << 12) | (op_field  << 9), 0xe1f0fe00,   \
+      &avr32_syntax_table[AVR32_SYNTAX_ ## op_name ## cond_name ],      \
+      BFD_RELOC_UNUSED, 3, -1,                                          \
+      {                                                                 \
+    &avr32_ifield_table[AVR32_IFIELD_RY],                           \
+    &avr32_ifield_table[AVR32_IFIELD_RX],                           \
+    &avr32_ifield_table[AVR32_IFIELD_K9E],                          \
+      },                                                                \
+    },
+    
+#define AVR32_OPCODE_ST_COND(op_name, op_field, cond_name, cond_field)  \
+    {                                                                   \
+      AVR32_OPC_ ## op_name ## cond_name , 4,                           \
+      0xe1f00000 | (cond_field << 12) | (op_field  << 9), 0xe1f0fe00,   \
+      &avr32_syntax_table[AVR32_SYNTAX_ ## op_name ## cond_name ],      \
+      BFD_RELOC_UNUSED, 3, -1,                                          \
+      {                                                                 \
+    &avr32_ifield_table[AVR32_IFIELD_RX],                           \
+    &avr32_ifield_table[AVR32_IFIELD_K9E],                          \
+    &avr32_ifield_table[AVR32_IFIELD_RY],                           \
+      },                                                                \
+    },
+
+    AVR32_OPCODE_LD_COND (LD_W, 0, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_W, 0, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_SH, 1, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_SH, 1, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_UH, 2, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_UH, 2, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_SH, 2, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_SB, 3, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_SB, 3, AL, 15) 
+
+    AVR32_OPCODE_LD_COND (LD_UB, 4, EQ, 0) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, NE, 1) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, CC, 2) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, CS, 3) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, GE, 4) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, LT, 5) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, MI, 6) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, PL, 7) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, LS, 8) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, GT, 9) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, LE, 10) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, HI, 11) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, VS, 12) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, VC, 13) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, QS, 14) 
+    AVR32_OPCODE_LD_COND (LD_UB, 4, AL, 15) 
+
+    AVR32_OPCODE_ST_COND (ST_W, 5, EQ, 0) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, NE, 1) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, CC, 2) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, CS, 3) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, GE, 4) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, LT, 5) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, MI, 6) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, PL, 7) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, LS, 8) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, GT, 9) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, LE, 10) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, HI, 11) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, VS, 12) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, VC, 13) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, QS, 14) 
+    AVR32_OPCODE_ST_COND (ST_W, 5, AL, 15) 
+
+    AVR32_OPCODE_ST_COND (ST_H, 6, EQ, 0) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, NE, 1) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, CC, 2) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, CS, 3) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, GE, 4) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, LT, 5) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, MI, 6) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, PL, 7) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, LS, 8) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, GT, 9) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, LE, 10) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, HI, 11) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, VS, 12) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, VC, 13) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, QS, 14) 
+    AVR32_OPCODE_ST_COND (ST_H, 6, AL, 15) 
+
+    AVR32_OPCODE_ST_COND (ST_B, 7, EQ, 0) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, NE, 1) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, CC, 2) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, CS, 3) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, GE, 4) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, LT, 5) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, MI, 6) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, PL, 7) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, LS, 8) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, GT, 9) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, LE, 10) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, HI, 11) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, VS, 12) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, VC, 13) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, QS, 14) 
+    AVR32_OPCODE_ST_COND (ST_B, 7, AL, 15) 
+
+    {
+      AVR32_OPC_MOVH, 4, 0xfc100000, 0xfff00000,
+      &avr32_syntax_table[AVR32_SYNTAX_MOVH],
+      BFD_RELOC_AVR32_16U,  2, 1,
+      {
+    &avr32_ifield_table[AVR32_IFIELD_RY],
+    &avr32_ifield_table[AVR32_IFIELD_K16],
+      },
+    },
+
+ };
+
+#define FPALIAS_DXY(name, opcode)           \
+  {                         \
+    AVR32_ALIAS_##name##_S,             \
+    &avr32_opc_table[AVR32_OPC_COP],            \
+    {                           \
+      { 0, 0 },                     \
+      { 1, 0 }, { 1, 1 }, { 1, 2 },         \
+      { 0, opcode },                    \
+    },                          \
+  }, {                          \
+    AVR32_ALIAS_##name##_D,             \
+    &avr32_opc_table[AVR32_OPC_COP],            \
+    {                           \
+      { 0, 0 },                     \
+      { 1, 0 }, { 1, 1 }, { 1, 2 },         \
+      { 0, (opcode) | 0x40 },               \
+    },                          \
+  }
+#define FPALIAS_DX(name, opcode)            \
+  {                         \
+    AVR32_ALIAS_##name##_S,             \
+    &avr32_opc_table[AVR32_OPC_COP],            \
+    {                           \
+      { 0, 0 },                     \
+      { 1, 0 }, { 1, 1 }, { 0, 0 },         \
+      { 0, opcode },                    \
+    },                          \
+  }, {                          \
+    AVR32_ALIAS_##name##_D,             \
+    &avr32_opc_table[AVR32_OPC_COP],            \
+    {                           \
+      { 0, 0 },                     \
+      { 1, 0 }, { 1, 1 }, { 0, 0 },         \
+      { 0, (opcode) | 0x40 },               \
+    },                          \
+  }
+#define FPALIAS_XY(name, opcode)            \
+  {                         \
+    AVR32_ALIAS_##name##_S,             \
+    &avr32_opc_table[AVR32_OPC_COP],            \
+    {                           \
+      { 0, 0 },                     \
+      { 0, 0 }, { 1, 0 }, { 1, 1 },         \
+      { 0, opcode },                    \
+    },                          \
+  }, {                          \
+    AVR32_ALIAS_##name##_D,             \
+    &avr32_opc_table[AVR32_OPC_COP],            \
+    {                           \
+      { 0, 0 },                     \
+      { 0, 0 }, { 1, 0 }, { 1, 1 },         \
+      { 0, (opcode) | 0x40 },               \
+    },                          \
+  }
+
+const struct avr32_alias avr32_alias_table[] =
+  {
+    FPALIAS_DXY(FMAC, 0x00),
+    FPALIAS_DXY(FNMAC, 0x01),
+    FPALIAS_DXY(FMSC, 0x02),
+    FPALIAS_DXY(FNMSC, 0x03),
+    FPALIAS_DXY(FADD, 0x04),
+    FPALIAS_DXY(FSUB, 0x05),
+    FPALIAS_DXY(FMUL, 0x06),
+    FPALIAS_DXY(FNMUL, 0x07),
+    FPALIAS_DX(FNEG, 0x08),
+    FPALIAS_DX(FABS, 0x09),
+    FPALIAS_XY(FCMP, 0x0d),
+    FPALIAS_DX(FMOV1, 0x0a),
+    {
+      AVR32_ALIAS_FMOV2_S,
+      &avr32_opc_table[AVR32_OPC_MVCR_W],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FMOV2_D,
+      &avr32_opc_table[AVR32_OPC_MVCR_D],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FMOV3_S,
+      &avr32_opc_table[AVR32_OPC_MVRC_W],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FMOV3_D,
+      &avr32_opc_table[AVR32_OPC_MVRC_D],
+      { { 0, 0 }, { 1, 0 }, { 1, 1 }, },
+    },
+    {
+      AVR32_ALIAS_FCASTS_D,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, 0 },
+    { 1, 0 }, { 1, 1 }, { 0, 0 },
+    { 0, 0x0f },
+      },
+    },
+    {
+      AVR32_ALIAS_FCASTD_S,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, 0 },
+    { 1, 0 }, { 1, 1 }, { 0, 0 },
+    { 0, 0x10 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x0c },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x0d },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x0e },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMAC3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x0f },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x08 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x09 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x0a },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSVMUL3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x0b },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x04 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x05 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x06 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMAC3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x07 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL0,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x00 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL1,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x01 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL2,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x02 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOVMUL3,
+      &avr32_opc_table[AVR32_OPC_COP],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+    { 0, 0x03 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_D1,
+      &avr32_opc_table[AVR32_OPC_LDC_D1],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_D2,
+      &avr32_opc_table[AVR32_OPC_LDC_D2],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_D3,
+      &avr32_opc_table[AVR32_OPC_LDC_D3],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_W1,
+      &avr32_opc_table[AVR32_OPC_LDC_W1],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_W2,
+      &avr32_opc_table[AVR32_OPC_LDC_W2],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLD_W3,
+      &avr32_opc_table[AVR32_OPC_LDC_W3],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_D,
+      &avr32_opc_table[AVR32_OPC_LDCM_D],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_D_PU,
+      &avr32_opc_table[AVR32_OPC_LDCM_D_PU],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_W,
+      &avr32_opc_table[AVR32_OPC_LDCM_W],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOLDM_W_PU,
+      &avr32_opc_table[AVR32_OPC_LDCM_W_PU],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_D1,
+      &avr32_opc_table[AVR32_OPC_MVCR_D],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_D2,
+      &avr32_opc_table[AVR32_OPC_MVRC_D],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_W1,
+      &avr32_opc_table[AVR32_OPC_MVCR_W],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOMV_W2,
+      &avr32_opc_table[AVR32_OPC_MVRC_W],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_D1,
+      &avr32_opc_table[AVR32_OPC_STC_D1],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_D2,
+      &avr32_opc_table[AVR32_OPC_STC_D2],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_D3,
+      &avr32_opc_table[AVR32_OPC_STC_D3],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_W1,
+      &avr32_opc_table[AVR32_OPC_STC_W1],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_W2,
+      &avr32_opc_table[AVR32_OPC_STC_W2],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOST_W3,
+      &avr32_opc_table[AVR32_OPC_STC_W3],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 }, { 1, 3 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_D,
+      &avr32_opc_table[AVR32_OPC_STCM_D],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_D_PU,
+      &avr32_opc_table[AVR32_OPC_STCM_D_PU],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_W,
+      &avr32_opc_table[AVR32_OPC_STCM_W],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+    {
+      AVR32_ALIAS_PICOSTM_W_PU,
+      &avr32_opc_table[AVR32_OPC_STCM_W_PU],
+      {
+    { 0, PICO_CPNO },
+    { 1, 0 }, { 1, 1 }, { 1, 2 },
+      },
+    },
+  };
+
+
+#define SYNTAX_NORMAL0(id, mne, opc, arch)          \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },     \
+    NULL, 0, { }                    \
+  }
+#define SYNTAX_NORMAL1(id, mne, opc, op0, arch)     \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },     \
+    NULL, 1,                        \
+    {                           \
+      AVR32_OPERAND_##op0,              \
+    }                           \
+  }
+#define SYNTAX_NORMALM1(id, mne, opc, op0, arch)        \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    NULL, -1,                       \
+    {                           \
+      AVR32_OPERAND_##op0,              \
+    }                           \
+  }
+#define SYNTAX_NORMAL2(id, mne, opc, op0, op1, arch)        \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    NULL, 2,                        \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+    }                           \
+  }
+#define SYNTAX_NORMALM2(id, mne, opc, op0, op1, arch)       \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    NULL, -2,                       \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+    }                           \
+  }
+#define SYNTAX_NORMAL3(id, mne, opc, op0, op1, op2, arch)   \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    NULL, 3,                        \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+      AVR32_OPERAND_##op2,              \
+    }                           \
+  }
+#define SYNTAX_NORMALM3(id, mne, opc, op0, op1, op2, arch)  \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    NULL, -3,                       \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+      AVR32_OPERAND_##op2,              \
+    }                           \
+  }
+#define SYNTAX_NORMAL4(id, mne, opc, op0, op1, op2, op3, arch)\
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    NULL, 4,                        \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+      AVR32_OPERAND_##op2, AVR32_OPERAND_##op3,     \
+    }                           \
+  }
+#define SYNTAX_NORMAL5(id, mne, opc, op0, op1, op2, op3, op4, arch) \
+  {                             \
+    AVR32_SYNTAX_##id, arch,                \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],        \
+    AVR32_PARSER_NORMAL,                        \
+    { &avr32_opc_table[AVR32_OPC_##opc], },             \
+    NULL, 5,                            \
+    {                               \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,         \
+      AVR32_OPERAND_##op2, AVR32_OPERAND_##op3,         \
+      AVR32_OPERAND_##op4,                  \
+    }                               \
+  }
+
+#define SYNTAX_NORMAL_C1(id, mne, opc, nxt, op0, arch)  \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], 1,     \
+    {                           \
+      AVR32_OPERAND_##op0,              \
+    }                           \
+  }
+#define SYNTAX_NORMAL_CM1(id, mne, opc, nxt, op0, arch) \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], -1,    \
+    {                           \
+      AVR32_OPERAND_##op0,              \
+    }                           \
+  }
+#define SYNTAX_NORMAL_C2(id, mne, opc, nxt, op0, op1, arch) \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], 2,     \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+    }                           \
+  }
+#define SYNTAX_NORMAL_CM2(id, mne, opc, nxt, op0, op1, arch)    \
+  {                         \
+    AVR32_SYNTAX_##id, arch,            \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],    \
+    AVR32_PARSER_NORMAL,                    \
+    { &avr32_opc_table[AVR32_OPC_##opc], },         \
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], -2,    \
+    {                           \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,     \
+    }                           \
+  }
+#define SYNTAX_NORMAL_C3(id, mne, opc, nxt, op0, op1, op2, arch)    \
+  {                             \
+    AVR32_SYNTAX_##id, arch,                \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],        \
+    AVR32_PARSER_NORMAL,                        \
+    { &avr32_opc_table[AVR32_OPC_##opc], },             \
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], 3,         \
+    {                               \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,         \
+      AVR32_OPERAND_##op2,                  \
+    }                               \
+  }
+#define SYNTAX_NORMAL_CM3(id, mne, opc, nxt, op0, op1, op2, arch)   \
+  {                             \
+    AVR32_SYNTAX_##id, arch,                \
+    &avr32_mnemonic_table[AVR32_MNEMONIC_##mne],        \
+    AVR32_PARSER_NORMAL,                        \
+    { &avr32_opc_table[AVR32_OPC_##opc], },             \
+    &avr32_syntax_table[AVR32_SYNTAX_##nxt], -3,        \
+    {                               \
+      AVR32_OPERAND_##op0, AVR32_OPERAND_##op1,         \
+      AVR32_OPERAND_##op2,                  \
+    }                               \
+  }
+
+#define SYNTAX_FP(name, nr_ops)                 \
+    {                               \
+      AVR32_SYNTAX_##name##_S,                  \
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,           \
+      { .alias = &avr32_alias_table[AVR32_ALIAS_##name##_S] },  \
+      NULL, nr_ops,                     \
+      {                             \
+    AVR32_OPERAND_FPREG_S,                  \
+    AVR32_OPERAND_FPREG_S,                  \
+    AVR32_OPERAND_FPREG_S,                  \
+      },                            \
+    },                              \
+    {                               \
+      AVR32_SYNTAX_##name##_D,                  \
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,           \
+      { .alias = &avr32_alias_table[AVR32_ALIAS_##name##_D] },  \
+      NULL, nr_ops,                     \
+      {                             \
+    AVR32_OPERAND_FPREG_D,                  \
+    AVR32_OPERAND_FPREG_D,                  \
+    AVR32_OPERAND_FPREG_D,                  \
+      },                            \
+    }
+
+const struct avr32_syntax avr32_syntax_table[] =
+  {
+    SYNTAX_NORMAL1(ABS, ABS, ABS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(ACALL, ACALL, ACALL, UNSIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL1(ACR, ACR, ACR, INTREG,AVR32_V1),
+    SYNTAX_NORMAL3(ADC, ADC, ADC, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ADD1, ADD, ADD1, ADD2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(ADD2, ADD, ADD2, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(ADDABS, ADDABS, ADDABS, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(ADDHH_W, ADDHH_W, ADDHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL_C2(AND1, AND, AND1, AND2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(AND2, AND, AND2, AND3, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(AND3, AND, AND3, INTREG, INTREG, INTREG_LSR, AVR32_V1),
+    SYNTAX_NORMAL_C2(ANDH, ANDH, ANDH, ANDH_COH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(ANDH_COH, ANDH, ANDH_COH, INTREG, UNSIGNED_CONST, COH, AVR32_V1),
+    SYNTAX_NORMAL_C2(ANDL, ANDL, ANDL, ANDL_COH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(ANDL_COH, ANDL, ANDL_COH, INTREG, UNSIGNED_CONST, COH, AVR32_V1),
+    SYNTAX_NORMAL2(ANDN, ANDN, ANDN, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(ASR1, ASR, ASR1, ASR3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(ASR3, ASR, ASR3, ASR2, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(ASR2, ASR, ASR2, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL4(BFEXTS, BFEXTS, BFEXTS, INTREG, INTREG, UNSIGNED_NUMBER, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL4(BFEXTU, BFEXTU, BFEXTU, INTREG, INTREG, UNSIGNED_NUMBER, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL4(BFINS, BFINS, BFINS, INTREG, INTREG, UNSIGNED_NUMBER, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(BLD, BLD, BLD, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL_C1(BREQ1, BREQ, BREQ1, BREQ2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRNE1, BRNE, BRNE1, BRNE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRCC1, BRCC, BRCC1, BRCC2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRCS1, BRCS, BRCS1, BRCS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRGE1, BRGE, BRGE1, BRGE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRLT1, BRLT, BRLT1, BRLT2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRMI1, BRMI, BRMI1, BRMI2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRPL1, BRPL, BRPL1, BRPL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRHS1, BRHS, BRCC1, BRHS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL_C1(BRLO1, BRLO, BRCS1, BRLO2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BREQ2, BREQ, BREQ2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRNE2, BRNE, BRNE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRCC2, BRCC, BRCC2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRCS2, BRCS, BRCS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRGE2, BRGE, BRGE2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLT2, BRLT, BRLT2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRMI2, BRMI, BRMI2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRPL2, BRPL, BRPL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLS, BRLS, BRLS, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRGT, BRGT, BRGT, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLE, BRLE, BRLE, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRHI, BRHI, BRHI, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRVS, BRVS, BRVS, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRVC, BRVC, BRVC, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRQS, BRQS, BRQS, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRAL, BRAL, BRAL, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRHS2, BRHS, BRCC2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(BRLO2, BRLO, BRCS2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL0(BREAKPOINT, BREAKPOINT, BREAKPOINT, AVR32_V1),
+    SYNTAX_NORMAL1(BREV, BREV, BREV, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(BST, BST, BST, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(CACHE, CACHE, CACHE, INTREG_SDISP, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL1(CASTS_B, CASTS_B, CASTS_B, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CASTS_H, CASTS_H, CASTS_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CASTU_B, CASTU_B, CASTU_B, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CASTU_H, CASTU_H, CASTU_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(CBR, CBR, CBR, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(CLZ, CLZ, CLZ, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(COM, COM, COM, INTREG, AVR32_V1),
+    SYNTAX_NORMAL5(COP, COP, COP, CPNO, CPREG, CPREG, CPREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(CP_B, CP_B, CP_B, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(CP_H, CP_H, CP_H, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(CP_W1, CP_W, CP_W1, CP_W2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(CP_W2, CP_W, CP_W2, CP_W3, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(CP_W3, CP_W, CP_W3, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(CPC1, CPC, CPC1, CPC2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CPC2, CPC, CPC2, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(CSRF, CSRF, CSRF, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL1(CSRFCZ, CSRFCZ, CSRFCZ, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL3(DIVS, DIVS, DIVS, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(DIVU, DIVU, DIVU, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(EOR1, EOR, EOR1, EOR2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(EOR2, EOR, EOR2, EOR3, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(EOR3, EOR, EOR3, INTREG, INTREG, INTREG_LSR, AVR32_V1),
+    SYNTAX_NORMAL2(EORL, EORL, EORL, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(EORH, EORH, EORH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL0(FRS, FRS, FRS, AVR32_V1),
+    SYNTAX_NORMAL1(ICALL, ICALL, ICALL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(INCJOSP, INCJOSP, INCJOSP, JOSPINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D1, LD_D, LD_D1, LD_D2, DWREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D2, LD_D, LD_D2, LD_D3, DWREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D3, LD_D, LD_D3, LD_D5, DWREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_D5, LD_D, LD_D5, LD_D4, DWREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL2(LD_D4, LD_D, LD_D4, DWREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SB2, LD_SB, LD_SB2, LD_SB1, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL2(LD_SB1, LD_SB, LD_SB1, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB1, LD_UB, LD_UB1, LD_UB2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB2, LD_UB, LD_UB2, LD_UB5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB5, LD_UB, LD_UB5, LD_UB3, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UB3, LD_UB, LD_UB3, LD_UB4, INTREG, INTREG_UDISP, AVR32_V1),
+    SYNTAX_NORMAL2(LD_UB4, LD_UB, LD_UB4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH1, LD_SH, LD_SH1, LD_SH2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH2, LD_SH, LD_SH2, LD_SH5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH5, LD_SH, LD_SH5, LD_SH3, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_SH3, LD_SH, LD_SH3, LD_SH4, INTREG, INTREG_UDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LD_SH4, LD_SH, LD_SH4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH1, LD_UH, LD_UH1, LD_UH2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH2, LD_UH, LD_UH2, LD_UH5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH5, LD_UH, LD_UH5, LD_UH3, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_UH3, LD_UH, LD_UH3, LD_UH4, INTREG, INTREG_UDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LD_UH4, LD_UH, LD_UH4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W1, LD_W, LD_W1, LD_W2, INTREG, INTREG_POSTINC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W2, LD_W, LD_W2, LD_W5, INTREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W5, LD_W, LD_W5, LD_W6, INTREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W6, LD_W, LD_W6, LD_W3, INTREG, INTREG_XINDEX, AVR32_V1),
+    SYNTAX_NORMAL_C2(LD_W3, LD_W, LD_W3, LD_W4, INTREG, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LD_W4, LD_W, LD_W4, INTREG, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL3(LDC_D1, LDC_D, LDC_D1, CPNO, CPREG_D, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_D2, LDC_D, LDC_D2, LDC_D1, CPNO, CPREG_D, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_D3, LDC_D, LDC_D3, LDC_D2, CPNO, CPREG_D, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL3(LDC_W1, LDC_W, LDC_W1, CPNO, CPREG, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_W2, LDC_W, LDC_W2, LDC_W1, CPNO, CPREG, INTREG_PREDEC, AVR32_V1),
+    SYNTAX_NORMAL_C3(LDC_W3, LDC_W, LDC_W3, LDC_W2, CPNO, CPREG, INTREG_INDEX, AVR32_V1),
+    SYNTAX_NORMAL2(LDC0_D, LDC0_D, LDC0_D, CPREG_D, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LDC0_W, LDC0_W, LDC0_W, CPREG, INTREG_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_CM3(LDCM_D, LDCM_D, LDCM_D, LDCM_D_PU, CPNO, INTREG, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMALM3(LDCM_D_PU, LDCM_D, LDCM_D_PU, CPNO, INTREG_POSTINC, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMAL_CM3(LDCM_W, LDCM_W, LDCM_W, LDCM_W_PU, CPNO, INTREG, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMALM3(LDCM_W_PU, LDCM_W, LDCM_W_PU, CPNO, INTREG_POSTINC, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMAL2(LDDPC, LDDPC, LDDPC, INTREG, PC_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LDDPC_EXT, LDDPC, LDDPC_EXT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(LDDSP, LDDSP, LDDSP, INTREG, SP_UDISP_W, AVR32_V1),
+    SYNTAX_NORMAL2(LDINS_B, LDINS_B, LDINS_B, INTREG_BSEL, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL2(LDINS_H, LDINS_H, LDINS_H, INTREG_HSEL, INTREG_SDISP_H, AVR32_V1),
+    SYNTAX_NORMALM1(LDM, LDM, LDM, REGLIST_LDM, AVR32_V1),
+    SYNTAX_NORMAL_CM2(LDMTS, LDMTS, LDMTS, LDMTS_PU, INTREG, REGLIST16, AVR32_V1),
+    SYNTAX_NORMALM2(LDMTS_PU, LDMTS, LDMTS_PU, INTREG_POSTINC, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL2(LDSWP_SH, LDSWP_SH, LDSWP_SH, INTREG, INTREG_SDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LDSWP_UH, LDSWP_UH, LDSWP_UH, INTREG, INTREG_SDISP_H, AVR32_V1),
+    SYNTAX_NORMAL2(LDSWP_W, LDSWP_W, LDSWP_W, INTREG, INTREG_SDISP_W, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSL1, LSL, LSL1, LSL3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSL3, LSL, LSL3, LSL2, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(LSL2, LSL, LSL2, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSR1, LSR, LSR1, LSR3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(LSR3, LSR, LSR3, LSR2, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL2(LSR2, LSR, LSR2, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL3(MAC, MAC, MAC, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MACHH_D, MACHH_D, MACHH_D, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MACHH_W, MACHH_W, MACHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MACS_D, MACS_D, MACS_D, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MACSATHH_W, MACSATHH_W, MACSATHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MACUD, MACU_D, MACUD, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MACWH_D, MACWH_D, MACWH_D, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MAX, MAX, MAX, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(MCALL, MCALL, MCALL, MCALL, AVR32_V1),
+    SYNTAX_NORMAL2(MFDR, MFDR, MFDR, INTREG, UNSIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL2(MFSR, MFSR, MFSR, INTREG, UNSIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL3(MIN, MIN, MIN, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOV3, MOV, MOV3, MOV1, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOV1, MOV, MOV1, MOV2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOV2, MOV, MOV2,INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVEQ1, MOVEQ, MOVEQ1, MOVEQ2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVNE1, MOVNE, MOVNE1, MOVNE2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVCC1, MOVCC, MOVCC1, MOVCC2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVCS1, MOVCS, MOVCS1, MOVCS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVGE1, MOVGE, MOVGE1, MOVGE2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLT1, MOVLT, MOVLT1, MOVLT2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVMI1, MOVMI, MOVMI1, MOVMI2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVPL1, MOVPL, MOVPL1, MOVPL2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLS1, MOVLS, MOVLS1, MOVLS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVGT1, MOVGT, MOVGT1, MOVGT2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLE1, MOVLE, MOVLE1, MOVLE2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVHI1, MOVHI, MOVHI1, MOVHI2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVVS1, MOVVS, MOVVS1, MOVVS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVVC1, MOVVC, MOVVC1, MOVVC2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVQS1, MOVQS, MOVQS1, MOVQS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVAL1, MOVAL, MOVAL1, MOVAL2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVHS1, MOVHS, MOVCC1, MOVHS2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MOVLO1, MOVLO, MOVCS1, MOVLO2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(MOVEQ2, MOVEQ, MOVEQ2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVNE2, MOVNE, MOVNE2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVCC2, MOVCC, MOVCC2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVCS2, MOVCS, MOVCS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVGE2, MOVGE, MOVGE2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLT2, MOVLT, MOVLT2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVMI2, MOVMI, MOVMI2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVPL2, MOVPL, MOVPL2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLS2, MOVLS, MOVLS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVGT2, MOVGT, MOVGT2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLE2, MOVLE, MOVLE2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVHI2, MOVHI, MOVHI2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVVS2, MOVVS, MOVVS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVVC2, MOVVC, MOVVC2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVQS2, MOVQS, MOVQS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVAL2, MOVAL, MOVAL2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVHS2, MOVHS, MOVCC2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MOVLO2, MOVLO, MOVCS2, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(MTDR, MTDR, MTDR, UNSIGNED_CONST_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(MTSR, MTSR, MTSR, UNSIGNED_CONST_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(MUL1, MUL, MUL1, MUL2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(MUL2, MUL, MUL2, MUL3, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MUL3, MUL, MUL3, INTREG, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(MULHH_W, MULHH_W, MULHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULNHH_W, MULNHH_W, MULNHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULNWH_D, MULNWH_D, MULNWH_D, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSD, MULS_D, MULSD, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MULSATHH_H, MULSATHH_H, MULSATHH_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATHH_W, MULSATHH_W, MULSATHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATRNDHH_H, MULSATRNDHH_H, MULSATRNDHH_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATRNDWH_W, MULSATRNDWH_W, MULSATRNDWH_W, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULSATWH_W, MULSATWH_W, MULSATWH_W, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL3(MULU_D, MULU_D, MULU_D, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MULWH_D, MULWH_D, MULWH_D, INTREG, INTREG, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL1(MUSFR, MUSFR, MUSFR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(MUSTR, MUSTR, MUSTR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(MVCR_D, MVCR_D, MVCR_D, CPNO, DWREG, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL3(MVCR_W, MVCR_W, MVCR_W, CPNO, INTREG, CPREG, AVR32_V1),
+    SYNTAX_NORMAL3(MVRC_D, MVRC_D, MVRC_D, CPNO, CPREG_D, DWREG, AVR32_V1),
+    SYNTAX_NORMAL3(MVRC_W, MVRC_W, MVRC_W, CPNO, CPREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(NEG, NEG, NEG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL0(NOP, NOP, NOP, AVR32_V1),
+    SYNTAX_NORMAL_C2(OR1, OR, OR1, OR2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(OR2, OR, OR2, OR3, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL3(OR3, OR, OR3, INTREG, INTREG, INTREG_LSR, AVR32_V1),
+    SYNTAX_NORMAL2(ORH, ORH, ORH, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(ORL, ORL, ORL, INTREG, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(PABS_SB, PABS_SB, PABS_SB, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL2(PABS_SH, PABS_SH, PABS_SH, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PACKSH_SB, PACKSH_SB, PACKSH_SB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PACKSH_UB, PACKSH_UB, PACKSH_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PACKW_SH, PACKW_SH, PACKW_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADD_B, PADD_B, PADD_B, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADD_H, PADD_H, PADD_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDH_SH, PADDH_SH, PADDH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDH_UB, PADDH_UB, PADDH_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_SB, PADDS_SB, PADDS_SB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_SH, PADDS_SH, PADDS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_UB, PADDS_UB, PADDS_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDS_UH, PADDS_UH, PADDS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUB_H, PADDSUB_H, PADDSUB_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUBH_SH, PADDSUBH_SH, PADDSUBH_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUBS_SH, PADDSUBS_SH, PADDSUBS_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDSUBS_UH, PADDSUBS_UH, PADDSUBS_UH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDX_H, PADDX_H, PADDX_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDXH_SH, PADDXH_SH, PADDXH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDXS_SH, PADDXS_SH, PADDXS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PADDXS_UH, PADDXS_UH, PADDXS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PASR_B, PASR_B, PASR_B, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PASR_H, PASR_H, PASR_H, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PAVG_SH, PAVG_SH, PAVG_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PAVG_UB, PAVG_UB, PAVG_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSL_B, PLSL_B, PLSL_B, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSL_H, PLSL_H, PLSL_H, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSR_B, PLSR_B, PLSR_B, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PLSR_H, PLSR_H, PLSR_H, INTREG, INTREG, UNSIGNED_NUMBER, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMAX_SH, PMAX_SH, PMAX_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMAX_UB, PMAX_UB, PMAX_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMIN_SH, PMIN_SH, PMIN_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PMIN_UB, PMIN_UB, PMIN_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL0(POPJC, POPJC, POPJC, AVR32_V1),
+    SYNTAX_NORMAL_CM1(POPM, POPM, POPM, POPM_E, REGLIST9, AVR32_V1),
+    SYNTAX_NORMALM1(POPM_E, POPM, POPM_E, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL1(PREF, PREF, PREF, INTREG_SDISP, AVR32_V1),
+    SYNTAX_NORMAL3(PSAD, PSAD, PSAD, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUB_B, PSUB_B, PSUB_B, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUB_H, PSUB_H, PSUB_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADD_H, PSUBADD_H, PSUBADD_H, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADDH_SH, PSUBADDH_SH, PSUBADDH_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADDS_SH, PSUBADDS_SH, PSUBADDS_SH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBADDS_UH, PSUBADDS_UH, PSUBADDS_UH, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBH_SH, PSUBH_SH, PSUBH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBH_UB, PSUBH_UB, PSUBH_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_SB, PSUBS_SB, PSUBS_SB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_SH, PSUBS_SH, PSUBS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_UB, PSUBS_UB, PSUBS_UB, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBS_UH, PSUBS_UH, PSUBS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBX_H, PSUBX_H, PSUBX_H, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBXH_SH, PSUBXH_SH, PSUBXH_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBXS_SH, PSUBXS_SH, PSUBXS_SH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL3(PSUBXS_UH, PSUBXS_UH, PSUBXS_UH, INTREG, INTREG, INTREG, AVR32_SIMD),
+    SYNTAX_NORMAL2(PUNPCKSB_H, PUNPCKSB_H, PUNPCKSB_H, INTREG, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL2(PUNPCKUB_H, PUNPCKUB_H, PUNPCKUB_H, INTREG, INTREG_HSEL, AVR32_SIMD),
+    SYNTAX_NORMAL0(PUSHJC, PUSHJC, PUSHJC, AVR32_V1),
+    SYNTAX_NORMAL_CM1(PUSHM, PUSHM, PUSHM, PUSHM_E, REGLIST8, AVR32_V1),
+    SYNTAX_NORMALM1(PUSHM_E, PUSHM, PUSHM_E, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL_C1(RCALL1, RCALL, RCALL1, RCALL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(RCALL2, RCALL, RCALL2, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(RETEQ, RETEQ, RETEQ, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETNE, RETNE, RETNE, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETCC, RETCC, RETCC, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETCS, RETCS, RETCS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETGE, RETGE, RETGE, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLT, RETLT, RETLT, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETMI, RETMI, RETMI, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETPL, RETPL, RETPL, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLS, RETLS, RETLS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETGT, RETGT, RETGT, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLE, RETLE, RETLE, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETHI, RETHI, RETHI, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETVS, RETVS, RETVS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETVC, RETVC, RETVC, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETQS, RETQS, RETQS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETAL, RETAL, RETAL, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETHS, RETHS, RETCC, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL1(RETLO, RETLO, RETCS, RETVAL, AVR32_V1),
+    SYNTAX_NORMAL0(RETD, RETD, RETD, AVR32_V1),
+    SYNTAX_NORMAL0(RETE, RETE, RETE, AVR32_V1),
+    SYNTAX_NORMAL0(RETJ, RETJ, RETJ, AVR32_V1),
+    SYNTAX_NORMAL0(RETS, RETS, RETS, AVR32_V1),
+    SYNTAX_NORMAL1(RJMP, RJMP, RJMP, JMPLABEL, AVR32_V1),
+    SYNTAX_NORMAL1(ROL, ROL, ROL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(ROR, ROR, ROR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(RSUB1, RSUB, RSUB1, RSUB2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(RSUB2, RSUB, RSUB2, INTREG, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(SATADD_H, SATADD_H, SATADD_H, INTREG, INTREG, INTREG,  AVR32_DSP),
+    SYNTAX_NORMAL3(SATADD_W, SATADD_W, SATADD_W, INTREG, INTREG, INTREG, AVR32_DSP),
+    SYNTAX_NORMAL2(SATRNDS, SATRNDS, SATRNDS, INTREG_LSR, UNSIGNED_NUMBER, AVR32_DSP),
+    SYNTAX_NORMAL2(SATRNDU, SATRNDU, SATRNDU, INTREG_LSR, UNSIGNED_NUMBER, AVR32_DSP),
+    SYNTAX_NORMAL2(SATS, SATS, SATS, INTREG_LSR, UNSIGNED_NUMBER, AVR32_DSP),
+    SYNTAX_NORMAL3(SATSUB_H, SATSUB_H, SATSUB_H, INTREG, INTREG, INTREG, AVR32_DSP),
+    SYNTAX_NORMAL_C3(SATSUB_W1, SATSUB_W, SATSUB_W1, SATSUB_W2, INTREG, INTREG, INTREG, AVR32_DSP),
+    SYNTAX_NORMAL3(SATSUB_W2, SATSUB_W, SATSUB_W2, INTREG, INTREG, SIGNED_CONST, AVR32_DSP),
+    SYNTAX_NORMAL2(SATU, SATU, SATU, INTREG_LSR, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL3(SBC, SBC, SBC, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(SBR, SBR, SBR, INTREG, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL0(SCALL, SCALL, SCALL, AVR32_V1),
+    SYNTAX_NORMAL1(SCR, SCR, SCR, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SLEEP, SLEEP, SLEEP, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL1(SREQ, SREQ, SREQ, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRNE, SRNE, SRNE, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRCC, SRCC, SRCC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRCS, SRCS, SRCS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRGE, SRGE, SRGE, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLT, SRLT, SRLT, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRMI, SRMI, SRMI, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRPL, SRPL, SRPL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLS, SRLS, SRLS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRGT, SRGT, SRGT, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLE, SRLE, SRLE, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRHI, SRHI, SRHI, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRVS, SRVS, SRVS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRVC, SRVC, SRVC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRQS, SRQS, SRQS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRAL, SRAL, SRAL, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRHS, SRHS, SRCC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SRLO, SRLO, SRCS, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SSRF, SSRF, SSRF, UNSIGNED_NUMBER, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B1, ST_B, ST_B1, ST_B2, INTREG_POSTINC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B2, ST_B, ST_B2, ST_B5, INTREG_PREDEC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B5, ST_B, ST_B5, ST_B3, INTREG_INDEX, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_B3, ST_B, ST_B3, ST_B4, INTREG_UDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_B4, ST_B, ST_B4, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D1, ST_D, ST_D1, ST_D2, INTREG_POSTINC, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D2, ST_D, ST_D2, ST_D3, INTREG_PREDEC, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D3, ST_D, ST_D3, ST_D5, INTREG, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_D5, ST_D, ST_D5, ST_D4, INTREG_INDEX, DWREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_D4, ST_D, ST_D4, INTREG_SDISP, DWREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H1, ST_H, ST_H1, ST_H2, INTREG_POSTINC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H2, ST_H, ST_H2, ST_H5, INTREG_PREDEC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H5, ST_H, ST_H5, ST_H3, INTREG_INDEX, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_H3, ST_H, ST_H3, ST_H4, INTREG_UDISP_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_H4, ST_H, ST_H4, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W1, ST_W, ST_W1, ST_W2, INTREG_POSTINC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W2, ST_W, ST_W2, ST_W5, INTREG_PREDEC, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W5, ST_W, ST_W5, ST_W3, INTREG_INDEX, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(ST_W3, ST_W, ST_W3, ST_W4, INTREG_UDISP_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(ST_W4, ST_W, ST_W4, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(STC_D1, STC_D, STC_D1, CPNO, INTREG_UDISP_W, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_D2, STC_D, STC_D2, STC_D1, CPNO, INTREG_POSTINC, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_D3, STC_D, STC_D3, STC_D2, CPNO, INTREG_INDEX, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL3(STC_W1, STC_W, STC_W1, CPNO, INTREG_UDISP_W, CPREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_W2, STC_W, STC_W2, STC_W1, CPNO, INTREG_POSTINC, CPREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(STC_W3, STC_W, STC_W3, STC_W2, CPNO, INTREG_INDEX, CPREG, AVR32_V1),
+    SYNTAX_NORMAL2(STC0_D, STC0_D, STC0_D, INTREG_UDISP_W, CPREG_D, AVR32_V1),
+    SYNTAX_NORMAL2(STC0_W, STC0_W, STC0_W, INTREG_UDISP_W, CPREG, AVR32_V1),
+    SYNTAX_NORMAL_CM3(STCM_D, STCM_D, STCM_D, STCM_D_PU, CPNO, INTREG, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMALM3(STCM_D_PU, STCM_D, STCM_D_PU, CPNO, INTREG_PREDEC, REGLIST_CPD8, AVR32_V1),
+    SYNTAX_NORMAL_CM3(STCM_W, STCM_W, STCM_W, STCM_W_PU, CPNO, INTREG, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMALM3(STCM_W_PU, STCM_W, STCM_W_PU, CPNO, INTREG_PREDEC, REGLIST_CP8, AVR32_V1),
+    SYNTAX_NORMAL2(STCOND, STCOND, STCOND, INTREG_SDISP, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(STDSP, STDSP, STDSP, SP_UDISP_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(STHH_W2, STHH_W, STHH_W2, STHH_W1, INTREG_INDEX, INTREG_HSEL, INTREG_HSEL, AVR32_V1),
+    SYNTAX_NORMAL3(STHH_W1, STHH_W, STHH_W1, INTREG_UDISP_W, INTREG_HSEL, INTREG_HSEL, AVR32_V1),
+    SYNTAX_NORMAL_CM2(STM, STM, STM, STM_PU, INTREG, REGLIST16, AVR32_V1),
+    SYNTAX_NORMALM2(STM_PU, STM, STM_PU, INTREG_PREDEC, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL_CM2(STMTS, STMTS, STMTS, STMTS_PU, INTREG, REGLIST16, AVR32_V1),
+    SYNTAX_NORMALM2(STMTS_PU, STMTS, STMTS_PU, INTREG_PREDEC, REGLIST16, AVR32_V1),
+    SYNTAX_NORMAL2(STSWP_H, STSWP_H, STSWP_H, INTREG_SDISP_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(STSWP_W, STSWP_W, STSWP_W, INTREG_SDISP_W, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUB1, SUB, SUB1, SUB2, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL_C3(SUB2, SUB, SUB2, SUB5, INTREG, INTREG, INTREG_LSL, AVR32_V1),
+    SYNTAX_NORMAL_C3(SUB5, SUB, SUB5, SUB3_SP, INTREG, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUB3_SP, SUB, SUB3_SP, SUB3, SP, SIGNED_CONST_W, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUB3, SUB, SUB3, SUB4, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUB4, SUB, SUB4, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBEQ, SUBEQ, SUBEQ, SUB2EQ, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBNE, SUBNE, SUBNE, SUB2NE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBCC, SUBCC, SUBCC, SUB2CC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBCS, SUBCS, SUBCS, SUB2CS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBGE, SUBGE, SUBGE, SUB2GE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLT, SUBLT, SUBLT, SUB2LT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBMI, SUBMI, SUBMI, SUB2MI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBPL, SUBPL, SUBPL, SUB2PL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLS, SUBLS, SUBLS, SUB2LS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBGT, SUBGT, SUBGT, SUB2GT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLE, SUBLE, SUBLE, SUB2LE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBHI, SUBHI, SUBHI, SUB2HI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBVS, SUBVS, SUBVS, SUB2VS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBVC, SUBVC, SUBVC, SUB2VC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBQS, SUBQS, SUBQS, SUB2QS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBAL, SUBAL, SUBAL, SUB2AL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBHS, SUBHS, SUBCC, SUB2CC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL_C2(SUBLO, SUBLO, SUBCS, SUB2CS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFEQ, SUBFEQ, SUBFEQ, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFNE, SUBFNE, SUBFNE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFCC, SUBFCC, SUBFCC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFCS, SUBFCS, SUBFCS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFGE, SUBFGE, SUBFGE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLT, SUBFLT, SUBFLT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFMI, SUBFMI, SUBFMI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFPL, SUBFPL, SUBFPL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLS, SUBFLS, SUBFLS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFGT, SUBFGT, SUBFGT, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLE, SUBFLE, SUBFLE, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFHI, SUBFHI, SUBFHI, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFVS, SUBFVS, SUBFVS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFVC, SUBFVC, SUBFVC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFQS, SUBFQS, SUBFQS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFAL, SUBFAL, SUBFAL, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFHS, SUBFHS, SUBFCC, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(SUBFLO, SUBFLO, SUBFCS, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL3(SUBHH_W, SUBHH_W, SUBHH_W, INTREG, INTREG_HSEL, INTREG_HSEL, AVR32_DSP),
+    SYNTAX_NORMAL1(SWAP_B, SWAP_B, SWAP_B, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SWAP_BH, SWAP_BH, SWAP_BH, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SWAP_H, SWAP_H, SWAP_H, INTREG, AVR32_V1),
+    SYNTAX_NORMAL1(SYNC, SYNC, SYNC, UNSIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL0(TLBR, TLBR, TLBR, AVR32_V1),
+    SYNTAX_NORMAL0(TLBS, TLBS, TLBS, AVR32_V1),
+    SYNTAX_NORMAL0(TLBW, TLBW, TLBW, AVR32_V1),
+    SYNTAX_NORMAL1(TNBZ, TNBZ, TNBZ, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(TST, TST, TST, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL3(XCHG, XCHG, XCHG, INTREG, INTREG, INTREG, AVR32_V1),
+    SYNTAX_NORMAL2(MEMC, MEMC, MEMC, SIGNED_CONST_W, UNSIGNED_NUMBER, AVR32_RMW),
+    SYNTAX_NORMAL2(MEMS, MEMS, MEMS, SIGNED_CONST_W, UNSIGNED_NUMBER, AVR32_RMW),
+    SYNTAX_NORMAL2(MEMT, MEMT, MEMT, SIGNED_CONST_W, UNSIGNED_NUMBER, AVR32_RMW),
+    SYNTAX_FP(FADD, 3),
+    SYNTAX_FP(FSUB, 3),
+    SYNTAX_FP(FMAC, 3),
+    SYNTAX_FP(FNMAC, 3),
+    SYNTAX_FP(FMSC, 3),
+    SYNTAX_FP(FNMSC, 3),
+    SYNTAX_FP(FMUL, 3),
+    SYNTAX_FP(FNMUL, 3),
+    SYNTAX_FP(FNEG, 2),
+    SYNTAX_FP(FABS, 2),
+    SYNTAX_FP(FCMP, 2),
+    {
+      AVR32_SYNTAX_FMOV1_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV1_S] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV2_S],
+      2,
+      {
+    AVR32_OPERAND_FPREG_S,
+    AVR32_OPERAND_FPREG_S,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV1_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV1_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV2_D],
+      2,
+      {
+    AVR32_OPERAND_FPREG_D,
+    AVR32_OPERAND_FPREG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV2_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV2_S] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV3_S],
+      2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_FPREG_S,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV2_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV2_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_FMOV3_D],
+      2,
+      {
+    AVR32_OPERAND_DWREG,
+    AVR32_OPERAND_FPREG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV3_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV3_S] }, NULL,
+      2,
+      {
+    AVR32_OPERAND_FPREG_S,
+    AVR32_OPERAND_INTREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_FMOV3_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FMOV3_D] }, NULL,
+      2,
+      {
+    AVR32_OPERAND_FPREG_D,
+    AVR32_OPERAND_DWREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_FCASTS_D,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FCASTS_D] }, NULL,
+      2,
+      {
+    AVR32_OPERAND_FPREG_S,
+    AVR32_OPERAND_FPREG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_FCASTD_S,
+      AVR32_FP, NULL, AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_FCASTD_S] }, NULL,
+      2,
+      {
+    AVR32_OPERAND_FPREG_D,
+    AVR32_OPERAND_FPREG_S,
+      },
+    },
+    {
+      AVR32_SYNTAX_LDA_W,
+      AVR32_V1, NULL, AVR32_PARSER_LDA,
+      { NULL }, NULL,
+      2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_SIGNED_CONST,
+      },
+    },
+    {
+      AVR32_SYNTAX_CALL,
+      AVR32_V1, NULL, AVR32_PARSER_CALL,
+      { NULL }, NULL,
+      1,
+      {
+    AVR32_OPERAND_JMPLABEL,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMAC1], 4,
+      {
+    AVR32_OPERAND_PICO_OUT0,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMAC2], 4,
+      {
+    AVR32_OPERAND_PICO_OUT1,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMAC3], 4,
+      {
+    AVR32_OPERAND_PICO_OUT2,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMAC3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMAC3] },
+      NULL, 4,
+      {
+    AVR32_OPERAND_PICO_OUT3,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMUL1], 4,
+      {
+    AVR32_OPERAND_PICO_OUT0,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMUL2], 4,
+      {
+    AVR32_OPERAND_PICO_OUT1,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSVMUL3], 4,
+      {
+    AVR32_OPERAND_PICO_OUT2,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSVMUL3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSVMUL3] },
+      NULL, 4,
+      {
+    AVR32_OPERAND_PICO_OUT3,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMAC1], 4,
+      {
+    AVR32_OPERAND_PICO_OUT0,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMAC2], 4,
+      {
+    AVR32_OPERAND_PICO_OUT1,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMAC3], 4,
+      {
+    AVR32_OPERAND_PICO_OUT2,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMAC3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMAC], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMAC3] },
+      NULL, 4,
+      {
+    AVR32_OPERAND_PICO_OUT3,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL0,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL0] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMUL1], 4,
+      {
+    AVR32_OPERAND_PICO_OUT0,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMUL2], 4,
+      {
+    AVR32_OPERAND_PICO_OUT1,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOVMUL3], 4,
+      {
+    AVR32_OPERAND_PICO_OUT2,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOVMUL3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOVMUL], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOVMUL3] },
+      NULL, 4,
+      {
+    AVR32_OPERAND_PICO_OUT3,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+    AVR32_OPERAND_PICO_IN,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_D2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_D2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_D3], 2,
+      {
+    AVR32_OPERAND_PICO_REG_D,
+    AVR32_OPERAND_INTREG_PREDEC,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_D3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_D3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_D1], 2,
+      {
+    AVR32_OPERAND_PICO_REG_D,
+    AVR32_OPERAND_INTREG_INDEX,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_D1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_D1] },
+      NULL, 2,
+      {
+    AVR32_OPERAND_PICO_REG_D,
+    AVR32_OPERAND_INTREG_UDISP_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_W2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_W2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_W3], 2,
+      {
+    AVR32_OPERAND_PICO_REG_W,
+    AVR32_OPERAND_INTREG_PREDEC,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_W3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_W3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLD_W1], 2,
+      {
+    AVR32_OPERAND_PICO_REG_W,
+    AVR32_OPERAND_INTREG_INDEX,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLD_W1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLD_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLD_W1] },
+      NULL, 2,
+      {
+    AVR32_OPERAND_PICO_REG_W,
+    AVR32_OPERAND_INTREG_UDISP_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_D,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLDM_D_PU], -2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_D_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_D_PU] },
+      NULL, -2,
+      {
+    AVR32_OPERAND_INTREG_POSTINC,
+    AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_W,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_W] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOLDM_W_PU], -2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOLDM_W_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOLDM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOLDM_W_PU] },
+      NULL, -2,
+      {
+    AVR32_OPERAND_INTREG_POSTINC,
+    AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_D1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_D1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOMV_D2], 2,
+      {
+    AVR32_OPERAND_DWREG,
+    AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_D2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_D2] },
+      NULL, 2,
+      {
+    AVR32_OPERAND_PICO_REG_D,
+    AVR32_OPERAND_DWREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_W1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_W1] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOMV_W2], 2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOMV_W2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOMV_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOMV_W2] },
+      NULL, 2,
+      {
+    AVR32_OPERAND_PICO_REG_W,
+    AVR32_OPERAND_INTREG,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_D2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_D2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_D3], 2,
+      {
+    AVR32_OPERAND_INTREG_POSTINC,
+    AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_D3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_D3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_D1], 2,
+      {
+    AVR32_OPERAND_INTREG_INDEX,
+    AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_D1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_D1] },
+      NULL, 2,
+      {
+    AVR32_OPERAND_INTREG_UDISP_W,
+    AVR32_OPERAND_PICO_REG_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_W2,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_W2] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_W3], 2,
+      {
+    AVR32_OPERAND_INTREG_POSTINC,
+    AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_W3,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_W3] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOST_W1], 2,
+      {
+    AVR32_OPERAND_INTREG_INDEX,
+    AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOST_W1,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOST_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOST_W1] },
+      NULL, 2,
+      {
+    AVR32_OPERAND_INTREG_UDISP_W,
+    AVR32_OPERAND_PICO_REG_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_D,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_D] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSTM_D_PU], -2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_D_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_D], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_D_PU] },
+      NULL, -2,
+      {
+    AVR32_OPERAND_INTREG_PREDEC,
+    AVR32_OPERAND_PICO_REGLIST_D,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_W,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_W] },
+      &avr32_syntax_table[AVR32_SYNTAX_PICOSTM_W_PU], -2,
+      {
+    AVR32_OPERAND_INTREG,
+    AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    {
+      AVR32_SYNTAX_PICOSTM_W_PU,
+      AVR32_PICO, &avr32_mnemonic_table[AVR32_MNEMONIC_PICOSTM_W], AVR32_PARSER_ALIAS,
+      { .alias = &avr32_alias_table[AVR32_ALIAS_PICOSTM_W_PU] },
+      NULL, -2,
+      {
+    AVR32_OPERAND_INTREG_PREDEC,
+    AVR32_OPERAND_PICO_REGLIST_W,
+      },
+    },
+    SYNTAX_NORMAL2(RSUBEQ, RSUBEQ, RSUBEQ, INTREG, SIGNED_CONST, AVR32_V1),
+    SYNTAX_NORMAL2(RSUBNE, RSUBNE, RSUBNE, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBCC, RSUBCC, RSUBCC, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBCS, RSUBCS, RSUBCS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBGE, RSUBGE, RSUBGE, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLT, RSUBLT, RSUBLT, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBMI, RSUBMI, RSUBMI, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBPL, RSUBPL, RSUBPL, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLS, RSUBLS, RSUBLS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBGT, RSUBGT, RSUBGT, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLE, RSUBLE, RSUBLE, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBHI, RSUBHI, RSUBHI, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBVS, RSUBVS, RSUBVS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBVC, RSUBVC, RSUBVC, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBQS, RSUBQS, RSUBQS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBAL, RSUBAL, RSUBAL, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBHS, RSUBHS, RSUBCC, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL2(RSUBLO, RSUBLO, RSUBCS, INTREG, SIGNED_CONST, AVR32_V2),
+    SYNTAX_NORMAL3(ADDEQ, ADDEQ, ADDEQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDNE, ADDNE, ADDNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDCC, ADDCC, ADDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDCS, ADDCS, ADDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDGE, ADDGE, ADDGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLT, ADDLT, ADDLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDMI, ADDMI, ADDMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDPL, ADDPL, ADDPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLS, ADDLS, ADDLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDGT, ADDGT, ADDGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLE, ADDLE, ADDLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDHI, ADDHI, ADDHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDVS, ADDVS, ADDVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDVC, ADDVC, ADDVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDQS, ADDQS, ADDQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDAL, ADDAL, ADDAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDHS, ADDHS, ADDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ADDLO, ADDLO, ADDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2EQ, SUBEQ, SUB2EQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2NE, SUBNE, SUB2NE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2CC, SUBCC, SUB2CC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2CS, SUBCS, SUB2CS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2GE, SUBGE, SUB2GE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LT, SUBLT, SUB2LT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2MI, SUBMI, SUB2MI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2PL, SUBPL, SUB2PL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LS, SUBLS, SUB2LS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2GT, SUBGT, SUB2GT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LE, SUBLE, SUB2LE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2HI, SUBHI, SUB2HI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2VS, SUBVS, SUB2VS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2VC, SUBVC, SUB2VC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2QS, SUBQS, SUB2QS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2AL, SUBAL, SUB2AL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2HS, SUBHS, SUB2CC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(SUB2LO, SUBLO, SUB2CS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDEQ, ANDEQ, ANDEQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDNE, ANDNE, ANDNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDCC, ANDCC, ANDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDCS, ANDCS, ANDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDGE, ANDGE, ANDGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLT, ANDLT, ANDLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDMI, ANDMI, ANDMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDPL, ANDPL, ANDPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLS, ANDLS, ANDLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDGT, ANDGT, ANDGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLE, ANDLE, ANDLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDHI, ANDHI, ANDHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDVS, ANDVS, ANDVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDVC, ANDVC, ANDVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDQS, ANDQS, ANDQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDAL, ANDAL, ANDAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDHS, ANDHS, ANDCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ANDLO, ANDLO, ANDCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(OREQ, OREQ, OREQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORNE, ORNE, ORNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORCC, ORCC, ORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORCS, ORCS, ORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORGE, ORGE, ORGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLT, ORLT, ORLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORMI, ORMI, ORMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORPL, ORPL, ORPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLS, ORLS, ORLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORGT, ORGT, ORGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLE, ORLE, ORLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORHI, ORHI, ORHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORVS, ORVS, ORVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORVC, ORVC, ORVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORQS, ORQS, ORQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORAL, ORAL, ORAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORHS, ORHS, ORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(ORLO, ORLO, ORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EOREQ, EOREQ, EOREQ, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORNE, EORNE, EORNE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORCC, EORCC, EORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORCS, EORCS, EORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORGE, EORGE, EORGE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLT, EORLT, EORLT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORMI, EORMI, EORMI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORPL, EORPL, EORPL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLS, EORLS, EORLS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORGT, EORGT, EORGT, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLE, EORLE, EORLE, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORHI, EORHI, EORHI, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORVS, EORVS, EORVS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORVC, EORVC, EORVC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORQS, EORQS, EORQS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORAL, EORAL, EORAL, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORHS, EORHS, EORCC, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL3(EORLO, EORLO, EORCS, INTREG, INTREG, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WEQ, LD_WEQ, LD_WEQ, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WNE, LD_WNE, LD_WNE, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WCC, LD_WCC, LD_WCC, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WCS, LD_WCS, LD_WCS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WGE, LD_WGE, LD_WGE, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLT, LD_WLT, LD_WLT, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WMI, LD_WMI, LD_WMI, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WPL, LD_WPL, LD_WPL, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLS, LD_WLS, LD_WLS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WGT, LD_WGT, LD_WGT, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLE, LD_WLE, LD_WLE, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WHI, LD_WHI, LD_WHI, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WVS, LD_WVS, LD_WVS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WVC, LD_WVC, LD_WVC, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WQS, LD_WQS, LD_WQS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WAL, LD_WAL, LD_WAL, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WHS, LD_WHS, LD_WCC, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_WLO, LD_WLO, LD_WCS, INTREG, INTREG_UDISP_W, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHEQ, LD_SHEQ, LD_SHEQ, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHNE, LD_SHNE, LD_SHNE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHCC, LD_SHCC, LD_SHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHCS, LD_SHCS, LD_SHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHGE, LD_SHGE, LD_SHGE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLT, LD_SHLT, LD_SHLT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHMI, LD_SHMI, LD_SHMI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHPL, LD_SHPL, LD_SHPL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLS, LD_SHLS, LD_SHLS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHGT, LD_SHGT, LD_SHGT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLE, LD_SHLE, LD_SHLE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHHI, LD_SHHI, LD_SHHI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHVS, LD_SHVS, LD_SHVS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHVC, LD_SHVC, LD_SHVC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHQS, LD_SHQS, LD_SHQS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHAL, LD_SHAL, LD_SHAL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHHS, LD_SHHS, LD_SHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SHLO, LD_SHLO, LD_SHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHEQ, LD_UHEQ, LD_UHEQ, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHNE, LD_UHNE, LD_UHNE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHCC, LD_UHCC, LD_UHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHCS, LD_UHCS, LD_UHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHGE, LD_UHGE, LD_UHGE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLT, LD_UHLT, LD_UHLT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHMI, LD_UHMI, LD_UHMI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHPL, LD_UHPL, LD_UHPL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLS, LD_UHLS, LD_UHLS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHGT, LD_UHGT, LD_UHGT, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLE, LD_UHLE, LD_UHLE, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHHI, LD_UHHI, LD_UHHI, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHVS, LD_UHVS, LD_UHVS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHVC, LD_UHVC, LD_UHVC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHQS, LD_UHQS, LD_UHQS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHAL, LD_UHAL, LD_UHAL, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHHS, LD_UHHS, LD_UHCC, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UHLO, LD_UHLO, LD_UHCS, INTREG, INTREG_UDISP_H, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBEQ, LD_SBEQ, LD_SBEQ, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBNE, LD_SBNE, LD_SBNE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBCC, LD_SBCC, LD_SBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBCS, LD_SBCS, LD_SBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBGE, LD_SBGE, LD_SBGE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLT, LD_SBLT, LD_SBLT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBMI, LD_SBMI, LD_SBMI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBPL, LD_SBPL, LD_SBPL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLS, LD_SBLS, LD_SBLS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBGT, LD_SBGT, LD_SBGT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLE, LD_SBLE, LD_SBLE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBHI, LD_SBHI, LD_SBHI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBVS, LD_SBVS, LD_SBVS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBVC, LD_SBVC, LD_SBVC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBQS, LD_SBQS, LD_SBQS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBAL, LD_SBAL, LD_SBAL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBHS, LD_SBHS, LD_SBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_SBLO, LD_SBLO, LD_SBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBEQ, LD_UBEQ, LD_UBEQ, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBNE, LD_UBNE, LD_UBNE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBCC, LD_UBCC, LD_UBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBCS, LD_UBCS, LD_UBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBGE, LD_UBGE, LD_UBGE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLT, LD_UBLT, LD_UBLT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBMI, LD_UBMI, LD_UBMI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBPL, LD_UBPL, LD_UBPL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLS, LD_UBLS, LD_UBLS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBGT, LD_UBGT, LD_UBGT, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLE, LD_UBLE, LD_UBLE, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBHI, LD_UBHI, LD_UBHI, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBVS, LD_UBVS, LD_UBVS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBVC, LD_UBVC, LD_UBVC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBQS, LD_UBQS, LD_UBQS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBAL, LD_UBAL, LD_UBAL, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBHS, LD_UBHS, LD_UBCC, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(LD_UBLO, LD_UBLO, LD_UBCS, INTREG, INTREG_UDISP, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WEQ, ST_WEQ, ST_WEQ, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WNE, ST_WNE, ST_WNE, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WCC, ST_WCC, ST_WCC, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WCS, ST_WCS, ST_WCS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WGE, ST_WGE, ST_WGE, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLT, ST_WLT, ST_WLT, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WMI, ST_WMI, ST_WMI, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WPL, ST_WPL, ST_WPL, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLS, ST_WLS, ST_WLS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WGT, ST_WGT, ST_WGT, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLE, ST_WLE, ST_WLE, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WHI, ST_WHI, ST_WHI, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WVS, ST_WVS, ST_WVS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WVC, ST_WVC, ST_WVC, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WQS, ST_WQS, ST_WQS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WAL, ST_WAL, ST_WAL, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WHS, ST_WHS, ST_WCC, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_WLO, ST_WLO, ST_WCS, INTREG_UDISP_W, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HEQ, ST_HEQ, ST_HEQ, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HNE, ST_HNE, ST_HNE, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HCC, ST_HCC, ST_HCC, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HCS, ST_HCS, ST_HCS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HGE, ST_HGE, ST_HGE, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLT, ST_HLT, ST_HLT, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HMI, ST_HMI, ST_HMI, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HPL, ST_HPL, ST_HPL, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLS, ST_HLS, ST_HLS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HGT, ST_HGT, ST_HGT, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLE, ST_HLE, ST_HLE, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HHI, ST_HHI, ST_HHI, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HVS, ST_HVS, ST_HVS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HVC, ST_HVC, ST_HVC, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HQS, ST_HQS, ST_HQS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HAL, ST_HAL, ST_HAL, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HHS, ST_HHS, ST_HCC, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_HLO, ST_HLO, ST_HCS, INTREG_UDISP_H, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BEQ, ST_BEQ, ST_BEQ, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BNE, ST_BNE, ST_BNE, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BCC, ST_BCC, ST_BCC, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BCS, ST_BCS, ST_BCS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BGE, ST_BGE, ST_BGE, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLT, ST_BLT, ST_BLT, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BMI, ST_BMI, ST_BMI, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BPL, ST_BPL, ST_BPL, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLS, ST_BLS, ST_BLS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BGT, ST_BGT, ST_BGT, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLE, ST_BLE, ST_BLE, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BHI, ST_BHI, ST_BHI, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BVS, ST_BVS, ST_BVS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BVC, ST_BVC, ST_BVC, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BQS, ST_BQS, ST_BQS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BAL, ST_BAL, ST_BAL, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BHS, ST_BHS, ST_BCC, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(ST_BLO, ST_BLO, ST_BCS, INTREG_UDISP, INTREG, AVR32_V2),
+    SYNTAX_NORMAL2(MOVH, MOVH, MOVH, INTREG, UNSIGNED_CONST, AVR32_V2),
+
+  };
+
+#define NORMAL_MNEMONIC(name, syntax, str)      \
+  {                         \
+    AVR32_MNEMONIC_##name, str,             \
+    &avr32_syntax_table[AVR32_SYNTAX_##syntax],     \
+  }
+#define FP_MNEMONIC(name, syntax, str)          \
+  NORMAL_MNEMONIC(name##_S, syntax##_S, str ".s"),  \
+  NORMAL_MNEMONIC(name##_D, syntax##_D, str ".d")
+
+const struct avr32_mnemonic avr32_mnemonic_table[] =
+  {
+    NORMAL_MNEMONIC(ABS, ABS, "abs"),
+    NORMAL_MNEMONIC(ACALL, ACALL, "acall"),
+    NORMAL_MNEMONIC(ACR, ACR, "acr"),
+    NORMAL_MNEMONIC(ADC, ADC, "adc"),
+    NORMAL_MNEMONIC(ADD, ADD1, "add"),
+    NORMAL_MNEMONIC(ADDABS, ADDABS, "addabs"),
+    NORMAL_MNEMONIC(ADDHH_W, ADDHH_W, "addhh.w"),
+    NORMAL_MNEMONIC(AND, AND1, "and"),
+    NORMAL_MNEMONIC(ANDH, ANDH, "andh"),
+    NORMAL_MNEMONIC(ANDL, ANDL, "andl"),
+    NORMAL_MNEMONIC(ANDN, ANDN, "andn"),
+    NORMAL_MNEMONIC(ASR, ASR1, "asr"),
+    NORMAL_MNEMONIC(BFEXTS, BFEXTS, "bfexts"),
+    NORMAL_MNEMONIC(BFEXTU, BFEXTU, "bfextu"),
+    NORMAL_MNEMONIC(BFINS, BFINS, "bfins"),
+    NORMAL_MNEMONIC(BLD, BLD, "bld"),
+    NORMAL_MNEMONIC(BREQ, BREQ1, "breq"),
+    NORMAL_MNEMONIC(BRNE, BRNE1, "brne"),
+    NORMAL_MNEMONIC(BRCC, BRCC1, "brcc"),
+    NORMAL_MNEMONIC(BRCS, BRCS1, "brcs"),
+    NORMAL_MNEMONIC(BRGE, BRGE1, "brge"),
+    NORMAL_MNEMONIC(BRLT, BRLT1, "brlt"),
+    NORMAL_MNEMONIC(BRMI, BRMI1, "brmi"),
+    NORMAL_MNEMONIC(BRPL, BRPL1, "brpl"),
+    NORMAL_MNEMONIC(BRHS, BRHS1, "brhs"),
+    NORMAL_MNEMONIC(BRLO, BRLO1, "brlo"),
+    NORMAL_MNEMONIC(BRLS, BRLS, "brls"),
+    NORMAL_MNEMONIC(BRGT, BRGT, "brgt"),
+    NORMAL_MNEMONIC(BRLE, BRLE, "brle"),
+    NORMAL_MNEMONIC(BRHI, BRHI, "brhi"),
+    NORMAL_MNEMONIC(BRVS, BRVS, "brvs"),
+    NORMAL_MNEMONIC(BRVC, BRVC, "brvc"),
+    NORMAL_MNEMONIC(BRQS, BRQS, "brqs"),
+    NORMAL_MNEMONIC(BRAL, BRAL, "bral"),
+    NORMAL_MNEMONIC(BREAKPOINT, BREAKPOINT, "breakpoint"),
+    NORMAL_MNEMONIC(BREV, BREV, "brev"),
+    NORMAL_MNEMONIC(BST, BST, "bst"),
+    NORMAL_MNEMONIC(CACHE, CACHE, "cache"),
+    NORMAL_MNEMONIC(CASTS_B, CASTS_B, "casts.b"),
+    NORMAL_MNEMONIC(CASTS_H, CASTS_H, "casts.h"),
+    NORMAL_MNEMONIC(CASTU_B, CASTU_B, "castu.b"),
+    NORMAL_MNEMONIC(CASTU_H, CASTU_H, "castu.h"),
+    NORMAL_MNEMONIC(CBR, CBR, "cbr"),
+    NORMAL_MNEMONIC(CLZ, CLZ, "clz"),
+    NORMAL_MNEMONIC(COM, COM, "com"),
+    NORMAL_MNEMONIC(COP, COP, "cop"),
+    NORMAL_MNEMONIC(CP_B, CP_B, "cp.b"),
+    NORMAL_MNEMONIC(CP_H, CP_H, "cp.h"),
+    NORMAL_MNEMONIC(CP_W, CP_W1, "cp.w"),
+    NORMAL_MNEMONIC(CP, CP_W1, "cp"),
+    NORMAL_MNEMONIC(CPC, CPC1, "cpc"),
+    NORMAL_MNEMONIC(CSRF, CSRF, "csrf"),
+    NORMAL_MNEMONIC(CSRFCZ, CSRFCZ, "csrfcz"),
+    NORMAL_MNEMONIC(DIVS, DIVS, "divs"),
+    NORMAL_MNEMONIC(DIVU, DIVU, "divu"),
+    NORMAL_MNEMONIC(EOR, EOR1, "eor"),
+    NORMAL_MNEMONIC(EORL, EORL, "eorl"),
+    NORMAL_MNEMONIC(EORH, EORH, "eorh"),
+    NORMAL_MNEMONIC(FRS, FRS, "frs"),
+    NORMAL_MNEMONIC(ICALL, ICALL, "icall"),
+    NORMAL_MNEMONIC(INCJOSP, INCJOSP, "incjosp"),
+    NORMAL_MNEMONIC(LD_D, LD_D1, "ld.d"),
+    NORMAL_MNEMONIC(LD_SB, LD_SB2, "ld.sb"),
+    NORMAL_MNEMONIC(LD_UB, LD_UB1, "ld.ub"),
+    NORMAL_MNEMONIC(LD_SH, LD_SH1, "ld.sh"),
+    NORMAL_MNEMONIC(LD_UH, LD_UH1, "ld.uh"),
+    NORMAL_MNEMONIC(LD_W, LD_W1, "ld.w"),
+    NORMAL_MNEMONIC(LDC_D, LDC_D3, "ldc.d"),
+    NORMAL_MNEMONIC(LDC_W, LDC_W3, "ldc.w"),
+    NORMAL_MNEMONIC(LDC0_D, LDC0_D, "ldc0.d"),
+    NORMAL_MNEMONIC(LDC0_W, LDC0_W, "ldc0.w"),
+    NORMAL_MNEMONIC(LDCM_D, LDCM_D, "ldcm.d"),
+    NORMAL_MNEMONIC(LDCM_W, LDCM_W, "ldcm.w"),
+    NORMAL_MNEMONIC(LDDPC, LDDPC, "lddpc"),
+    NORMAL_MNEMONIC(LDDSP, LDDSP, "lddsp"),
+    NORMAL_MNEMONIC(LDINS_B, LDINS_B, "ldins.b"),
+    NORMAL_MNEMONIC(LDINS_H, LDINS_H, "ldins.h"),
+    NORMAL_MNEMONIC(LDM, LDM, "ldm"),
+    NORMAL_MNEMONIC(LDMTS, LDMTS, "ldmts"),
+    NORMAL_MNEMONIC(LDSWP_SH, LDSWP_SH, "ldswp.sh"),
+    NORMAL_MNEMONIC(LDSWP_UH, LDSWP_UH, "ldswp.uh"),
+    NORMAL_MNEMONIC(LDSWP_W, LDSWP_W, "ldswp.w"),
+    NORMAL_MNEMONIC(LSL, LSL1, "lsl"),
+    NORMAL_MNEMONIC(LSR, LSR1, "lsr"),
+    NORMAL_MNEMONIC(MAC, MAC, "mac"),
+    NORMAL_MNEMONIC(MACHH_D, MACHH_D, "machh.d"),
+    NORMAL_MNEMONIC(MACHH_W, MACHH_W, "machh.w"),
+    NORMAL_MNEMONIC(MACS_D, MACS_D, "macs.d"),
+    NORMAL_MNEMONIC(MACSATHH_W, MACSATHH_W, "macsathh.w"),
+    NORMAL_MNEMONIC(MACU_D, MACUD, "macu.d"),
+    NORMAL_MNEMONIC(MACWH_D, MACWH_D, "macwh.d"),
+    NORMAL_MNEMONIC(MAX, MAX, "max"),
+    NORMAL_MNEMONIC(MCALL, MCALL, "mcall"),
+    NORMAL_MNEMONIC(MFDR, MFDR, "mfdr"),
+    NORMAL_MNEMONIC(MFSR, MFSR, "mfsr"),
+    NORMAL_MNEMONIC(MIN, MIN, "min"),
+    NORMAL_MNEMONIC(MOV, MOV3, "mov"),
+    NORMAL_MNEMONIC(MOVEQ, MOVEQ1, "moveq"),
+    NORMAL_MNEMONIC(MOVNE, MOVNE1, "movne"),
+    NORMAL_MNEMONIC(MOVCC, MOVCC1, "movcc"),
+    NORMAL_MNEMONIC(MOVCS, MOVCS1, "movcs"),
+    NORMAL_MNEMONIC(MOVGE, MOVGE1, "movge"),
+    NORMAL_MNEMONIC(MOVLT, MOVLT1, "movlt"),
+    NORMAL_MNEMONIC(MOVMI, MOVMI1, "movmi"),
+    NORMAL_MNEMONIC(MOVPL, MOVPL1, "movpl"),
+    NORMAL_MNEMONIC(MOVLS, MOVLS1, "movls"),
+    NORMAL_MNEMONIC(MOVGT, MOVGT1, "movgt"),
+    NORMAL_MNEMONIC(MOVLE, MOVLE1, "movle"),
+    NORMAL_MNEMONIC(MOVHI, MOVHI1, "movhi"),
+    NORMAL_MNEMONIC(MOVVS, MOVVS1, "movvs"),
+    NORMAL_MNEMONIC(MOVVC, MOVVC1, "movvc"),
+    NORMAL_MNEMONIC(MOVQS, MOVQS1, "movqs"),
+    NORMAL_MNEMONIC(MOVAL, MOVAL1, "moval"),
+    NORMAL_MNEMONIC(MOVHS, MOVHS1, "movhs"),
+    NORMAL_MNEMONIC(MOVLO, MOVLO1, "movlo"),
+    NORMAL_MNEMONIC(MTDR, MTDR, "mtdr"),
+    NORMAL_MNEMONIC(MTSR, MTSR, "mtsr"),
+    NORMAL_MNEMONIC(MUL, MUL1, "mul"),
+    NORMAL_MNEMONIC(MULHH_W, MULHH_W, "mulhh.w"),
+    NORMAL_MNEMONIC(MULNHH_W, MULNHH_W, "mulnhh.w"),
+    NORMAL_MNEMONIC(MULNWH_D, MULNWH_D, "mulnwh.d"),
+    NORMAL_MNEMONIC(MULS_D, MULSD, "muls.d"),
+    NORMAL_MNEMONIC(MULSATHH_H, MULSATHH_H, "mulsathh.h"),
+    NORMAL_MNEMONIC(MULSATHH_W, MULSATHH_W, "mulsathh.w"),
+    NORMAL_MNEMONIC(MULSATRNDHH_H, MULSATRNDHH_H, "mulsatrndhh.h"),
+    NORMAL_MNEMONIC(MULSATRNDWH_W, MULSATRNDWH_W, "mulsatrndwh.w"),
+    NORMAL_MNEMONIC(MULSATWH_W, MULSATWH_W, "mulsatwh.w"),
+    NORMAL_MNEMONIC(MULU_D, MULU_D, "mulu.d"),
+    NORMAL_MNEMONIC(MULWH_D, MULWH_D, "mulwh.d"),
+    NORMAL_MNEMONIC(MUSFR, MUSFR, "musfr"),
+    NORMAL_MNEMONIC(MUSTR, MUSTR, "mustr"),
+    NORMAL_MNEMONIC(MVCR_D, MVCR_D, "mvcr.d"),
+    NORMAL_MNEMONIC(MVCR_W, MVCR_W, "mvcr.w"),
+    NORMAL_MNEMONIC(MVRC_D, MVRC_D, "mvrc.d"),
+    NORMAL_MNEMONIC(MVRC_W, MVRC_W, "mvrc.w"),
+    NORMAL_MNEMONIC(NEG, NEG, "neg"),
+    NORMAL_MNEMONIC(NOP, NOP, "nop"),
+    NORMAL_MNEMONIC(OR, OR1, "or"),
+    NORMAL_MNEMONIC(ORH, ORH, "orh"),
+    NORMAL_MNEMONIC(ORL, ORL, "orl"),
+    NORMAL_MNEMONIC(PABS_SB, PABS_SB, "pabs.sb"),
+    NORMAL_MNEMONIC(PABS_SH, PABS_SH, "pabs.sh"),
+    NORMAL_MNEMONIC(PACKSH_SB, PACKSH_SB, "packsh.sb"),
+    NORMAL_MNEMONIC(PACKSH_UB, PACKSH_UB, "packsh.ub"),
+    NORMAL_MNEMONIC(PACKW_SH, PACKW_SH, "packw.sh"),
+    NORMAL_MNEMONIC(PADD_B, PADD_B, "padd.b"),
+    NORMAL_MNEMONIC(PADD_H, PADD_H, "padd.h"),
+    NORMAL_MNEMONIC(PADDH_SH, PADDH_SH, "paddh.sh"),
+    NORMAL_MNEMONIC(PADDH_UB, PADDH_UB, "paddh.ub"),
+    NORMAL_MNEMONIC(PADDS_SB, PADDS_SB, "padds.sb"),
+    NORMAL_MNEMONIC(PADDS_SH, PADDS_SH, "padds.sh"),
+    NORMAL_MNEMONIC(PADDS_UB, PADDS_UB, "padds.ub"),
+    NORMAL_MNEMONIC(PADDS_UH, PADDS_UH, "padds.uh"),
+    NORMAL_MNEMONIC(PADDSUB_H, PADDSUB_H, "paddsub.h"),
+    NORMAL_MNEMONIC(PADDSUBH_SH, PADDSUBH_SH, "paddsubh.sh"),
+    NORMAL_MNEMONIC(PADDSUBS_SH, PADDSUBS_SH, "paddsubs.sh"),
+    NORMAL_MNEMONIC(PADDSUBS_UH, PADDSUBS_UH, "paddsubs.uh"),
+    NORMAL_MNEMONIC(PADDX_H, PADDX_H, "paddx.h"),
+    NORMAL_MNEMONIC(PADDXH_SH, PADDXH_SH, "paddxh.sh"),
+    NORMAL_MNEMONIC(PADDXS_SH, PADDXS_SH, "paddxs.sh"),
+    NORMAL_MNEMONIC(PADDXS_UH, PADDXS_UH, "paddxs.uh"),
+    NORMAL_MNEMONIC(PASR_B, PASR_B, "pasr.b"),
+    NORMAL_MNEMONIC(PASR_H, PASR_H, "pasr.h"),
+    NORMAL_MNEMONIC(PAVG_SH, PAVG_SH, "pavg.sh"),
+    NORMAL_MNEMONIC(PAVG_UB, PAVG_UB, "pavg.ub"),
+    NORMAL_MNEMONIC(PLSL_B, PLSL_B, "plsl.b"),
+    NORMAL_MNEMONIC(PLSL_H, PLSL_H, "plsl.h"),
+    NORMAL_MNEMONIC(PLSR_B, PLSR_B, "plsr.b"),
+    NORMAL_MNEMONIC(PLSR_H, PLSR_H, "plsr.h"),
+    NORMAL_MNEMONIC(PMAX_SH, PMAX_SH, "pmax.sh"),
+    NORMAL_MNEMONIC(PMAX_UB, PMAX_UB, "pmax.ub"),
+    NORMAL_MNEMONIC(PMIN_SH, PMIN_SH, "pmin.sh"),
+    NORMAL_MNEMONIC(PMIN_UB, PMIN_UB, "pmin.ub"),
+    NORMAL_MNEMONIC(POPJC, POPJC, "popjc"),
+    NORMAL_MNEMONIC(POPM, POPM, "popm"),
+    NORMAL_MNEMONIC(PREF, PREF, "pref"),
+    NORMAL_MNEMONIC(PSAD, PSAD, "psad"),
+    NORMAL_MNEMONIC(PSUB_B, PSUB_B, "psub.b"),
+    NORMAL_MNEMONIC(PSUB_H, PSUB_H, "psub.h"),
+    NORMAL_MNEMONIC(PSUBADD_H, PSUBADD_H, "psubadd.h"),
+    NORMAL_MNEMONIC(PSUBADDH_SH, PSUBADDH_SH, "psubaddh.sh"),
+    NORMAL_MNEMONIC(PSUBADDS_SH, PSUBADDS_SH, "psubadds.sh"),
+    NORMAL_MNEMONIC(PSUBADDS_UH, PSUBADDS_UH, "psubadds.uh"),
+    NORMAL_MNEMONIC(PSUBH_SH, PSUBH_SH, "psubh.sh"),
+    NORMAL_MNEMONIC(PSUBH_UB, PSUBH_UB, "psubh.ub"),
+    NORMAL_MNEMONIC(PSUBS_SB, PSUBS_SB, "psubs.sb"),
+    NORMAL_MNEMONIC(PSUBS_SH, PSUBS_SH, "psubs.sh"),
+    NORMAL_MNEMONIC(PSUBS_UB, PSUBS_UB, "psubs.ub"),
+    NORMAL_MNEMONIC(PSUBS_UH, PSUBS_UH, "psubs.uh"),
+    NORMAL_MNEMONIC(PSUBX_H, PSUBX_H, "psubx.h"),
+    NORMAL_MNEMONIC(PSUBXH_SH, PSUBXH_SH, "psubxh.sh"),
+    NORMAL_MNEMONIC(PSUBXS_SH, PSUBXS_SH, "psubxs.sh"),
+    NORMAL_MNEMONIC(PSUBXS_UH, PSUBXS_UH, "psubxs.uh"),
+    NORMAL_MNEMONIC(PUNPCKSB_H, PUNPCKSB_H, "punpcksb.h"),
+    NORMAL_MNEMONIC(PUNPCKUB_H, PUNPCKUB_H, "punpckub.h"),
+    NORMAL_MNEMONIC(PUSHJC, PUSHJC, "pushjc"),
+    NORMAL_MNEMONIC(PUSHM, PUSHM, "pushm"),
+    NORMAL_MNEMONIC(RCALL, RCALL1, "rcall"),
+    NORMAL_MNEMONIC(RETEQ, RETEQ, "reteq"),
+    NORMAL_MNEMONIC(RETNE, RETNE, "retne"),
+    NORMAL_MNEMONIC(RETCC, RETCC, "retcc"),
+    NORMAL_MNEMONIC(RETCS, RETCS, "retcs"),
+    NORMAL_MNEMONIC(RETGE, RETGE, "retge"),
+    NORMAL_MNEMONIC(RETLT, RETLT, "retlt"),
+    NORMAL_MNEMONIC(RETMI, RETMI, "retmi"),
+    NORMAL_MNEMONIC(RETPL, RETPL, "retpl"),
+    NORMAL_MNEMONIC(RETLS, RETLS, "retls"),
+    NORMAL_MNEMONIC(RETGT, RETGT, "retgt"),
+    NORMAL_MNEMONIC(RETLE, RETLE, "retle"),
+    NORMAL_MNEMONIC(RETHI, RETHI, "rethi"),
+    NORMAL_MNEMONIC(RETVS, RETVS, "retvs"),
+    NORMAL_MNEMONIC(RETVC, RETVC, "retvc"),
+    NORMAL_MNEMONIC(RETQS, RETQS, "retqs"),
+    NORMAL_MNEMONIC(RETAL, RETAL, "retal"),
+    NORMAL_MNEMONIC(RETHS, RETHS, "reths"),
+    NORMAL_MNEMONIC(RETLO, RETLO, "retlo"),
+    NORMAL_MNEMONIC(RET, RETAL, "ret"),
+    NORMAL_MNEMONIC(RETD, RETD, "retd"),
+    NORMAL_MNEMONIC(RETE, RETE, "rete"),
+    NORMAL_MNEMONIC(RETJ, RETJ, "retj"),
+    NORMAL_MNEMONIC(RETS, RETS, "rets"),
+    NORMAL_MNEMONIC(RJMP, RJMP, "rjmp"),
+    NORMAL_MNEMONIC(ROL, ROL, "rol"),
+    NORMAL_MNEMONIC(ROR, ROR, "ror"),
+    NORMAL_MNEMONIC(RSUB, RSUB1, "rsub"),
+    NORMAL_MNEMONIC(SATADD_H, SATADD_H, "satadd.h"),
+    NORMAL_MNEMONIC(SATADD_W, SATADD_W, "satadd.w"),
+    NORMAL_MNEMONIC(SATRNDS, SATRNDS, "satrnds"),
+    NORMAL_MNEMONIC(SATRNDU, SATRNDU, "satrndu"),
+    NORMAL_MNEMONIC(SATS, SATS, "sats"),
+    NORMAL_MNEMONIC(SATSUB_H, SATSUB_H, "satsub.h"),
+    NORMAL_MNEMONIC(SATSUB_W, SATSUB_W1, "satsub.w"),
+    NORMAL_MNEMONIC(SATU, SATU, "satu"),
+    NORMAL_MNEMONIC(SBC, SBC, "sbc"),
+    NORMAL_MNEMONIC(SBR, SBR, "sbr"),
+    NORMAL_MNEMONIC(SCALL, SCALL, "scall"),
+    NORMAL_MNEMONIC(SCR, SCR, "scr"),
+    NORMAL_MNEMONIC(SLEEP, SLEEP, "sleep"),
+    NORMAL_MNEMONIC(SREQ, SREQ, "sreq"),
+    NORMAL_MNEMONIC(SRNE, SRNE, "srne"),
+    NORMAL_MNEMONIC(SRCC, SRCC, "srcc"),
+    NORMAL_MNEMONIC(SRCS, SRCS, "srcs"),
+    NORMAL_MNEMONIC(SRGE, SRGE, "srge"),
+    NORMAL_MNEMONIC(SRLT, SRLT, "srlt"),
+    NORMAL_MNEMONIC(SRMI, SRMI, "srmi"),
+    NORMAL_MNEMONIC(SRPL, SRPL, "srpl"),
+    NORMAL_MNEMONIC(SRLS, SRLS, "srls"),
+    NORMAL_MNEMONIC(SRGT, SRGT, "srgt"),
+    NORMAL_MNEMONIC(SRLE, SRLE, "srle"),
+    NORMAL_MNEMONIC(SRHI, SRHI, "srhi"),
+    NORMAL_MNEMONIC(SRVS, SRVS, "srvs"),
+    NORMAL_MNEMONIC(SRVC, SRVC, "srvc"),
+    NORMAL_MNEMONIC(SRQS, SRQS, "srqs"),
+    NORMAL_MNEMONIC(SRAL, SRAL, "sral"),
+    NORMAL_MNEMONIC(SRHS, SRHS, "srhs"),
+    NORMAL_MNEMONIC(SRLO, SRLO, "srlo"),
+    NORMAL_MNEMONIC(SSRF, SSRF, "ssrf"),
+    NORMAL_MNEMONIC(ST_B, ST_B1, "st.b"),
+    NORMAL_MNEMONIC(ST_D, ST_D1, "st.d"),
+    NORMAL_MNEMONIC(ST_H, ST_H1, "st.h"),
+    NORMAL_MNEMONIC(ST_W, ST_W1, "st.w"),
+    NORMAL_MNEMONIC(STC_D, STC_D3, "stc.d"),
+    NORMAL_MNEMONIC(STC_W, STC_W3, "stc.w"),
+    NORMAL_MNEMONIC(STC0_D, STC0_D, "stc0.d"),
+    NORMAL_MNEMONIC(STC0_W, STC0_W, "stc0.w"),
+    NORMAL_MNEMONIC(STCM_D, STCM_D, "stcm.d"),
+    NORMAL_MNEMONIC(STCM_W, STCM_W, "stcm.w"),
+    NORMAL_MNEMONIC(STCOND, STCOND, "stcond"),
+    NORMAL_MNEMONIC(STDSP, STDSP, "stdsp"),
+    NORMAL_MNEMONIC(STHH_W, STHH_W2, "sthh.w"),
+    NORMAL_MNEMONIC(STM, STM, "stm"),
+    NORMAL_MNEMONIC(STMTS, STMTS, "stmts"),
+    NORMAL_MNEMONIC(STSWP_H, STSWP_H, "stswp.h"),
+    NORMAL_MNEMONIC(STSWP_W, STSWP_W, "stswp.w"),
+    NORMAL_MNEMONIC(SUB, SUB1, "sub"),
+    NORMAL_MNEMONIC(SUBEQ, SUBEQ, "subeq"),
+    NORMAL_MNEMONIC(SUBNE, SUBNE, "subne"),
+    NORMAL_MNEMONIC(SUBCC, SUBCC, "subcc"),
+    NORMAL_MNEMONIC(SUBCS, SUBCS, "subcs"),
+    NORMAL_MNEMONIC(SUBGE, SUBGE, "subge"),
+    NORMAL_MNEMONIC(SUBLT, SUBLT, "sublt"),
+    NORMAL_MNEMONIC(SUBMI, SUBMI, "submi"),
+    NORMAL_MNEMONIC(SUBPL, SUBPL, "subpl"),
+    NORMAL_MNEMONIC(SUBLS, SUBLS, "subls"),
+    NORMAL_MNEMONIC(SUBGT, SUBGT, "subgt"),
+    NORMAL_MNEMONIC(SUBLE, SUBLE, "suble"),
+    NORMAL_MNEMONIC(SUBHI, SUBHI, "subhi"),
+    NORMAL_MNEMONIC(SUBVS, SUBVS, "subvs"),
+    NORMAL_MNEMONIC(SUBVC, SUBVC, "subvc"),
+    NORMAL_MNEMONIC(SUBQS, SUBQS, "subqs"),
+    NORMAL_MNEMONIC(SUBAL, SUBAL, "subal"),
+    NORMAL_MNEMONIC(SUBHS, SUBHS, "subhs"),
+    NORMAL_MNEMONIC(SUBLO, SUBLO, "sublo"),
+    NORMAL_MNEMONIC(SUBFEQ, SUBFEQ, "subfeq"),
+    NORMAL_MNEMONIC(SUBFNE, SUBFNE, "subfne"),
+    NORMAL_MNEMONIC(SUBFCC, SUBFCC, "subfcc"),
+    NORMAL_MNEMONIC(SUBFCS, SUBFCS, "subfcs"),
+    NORMAL_MNEMONIC(SUBFGE, SUBFGE, "subfge"),
+    NORMAL_MNEMONIC(SUBFLT, SUBFLT, "subflt"),
+    NORMAL_MNEMONIC(SUBFMI, SUBFMI, "subfmi"),
+    NORMAL_MNEMONIC(SUBFPL, SUBFPL, "subfpl"),
+    NORMAL_MNEMONIC(SUBFLS, SUBFLS, "subfls"),
+    NORMAL_MNEMONIC(SUBFGT, SUBFGT, "subfgt"),
+    NORMAL_MNEMONIC(SUBFLE, SUBFLE, "subfle"),
+    NORMAL_MNEMONIC(SUBFHI, SUBFHI, "subfhi"),
+    NORMAL_MNEMONIC(SUBFVS, SUBFVS, "subfvs"),
+    NORMAL_MNEMONIC(SUBFVC, SUBFVC, "subfvc"),
+    NORMAL_MNEMONIC(SUBFQS, SUBFQS, "subfqs"),
+    NORMAL_MNEMONIC(SUBFAL, SUBFAL, "subfal"),
+    NORMAL_MNEMONIC(SUBFHS, SUBFHS, "subfhs"),
+    NORMAL_MNEMONIC(SUBFLO, SUBFLO, "subflo"),
+    NORMAL_MNEMONIC(SUBHH_W, SUBHH_W, "subhh.w"),
+    NORMAL_MNEMONIC(SWAP_B, SWAP_B, "swap.b"),
+    NORMAL_MNEMONIC(SWAP_BH, SWAP_BH, "swap.bh"),
+    NORMAL_MNEMONIC(SWAP_H, SWAP_H, "swap.h"),
+    NORMAL_MNEMONIC(SYNC, SYNC, "sync"),
+    NORMAL_MNEMONIC(TLBR, TLBR, "tlbr"),
+    NORMAL_MNEMONIC(TLBS, TLBS, "tlbs"),
+    NORMAL_MNEMONIC(TLBW, TLBW, "tlbw"),
+    NORMAL_MNEMONIC(TNBZ, TNBZ, "tnbz"),
+    NORMAL_MNEMONIC(TST, TST, "tst"),
+    NORMAL_MNEMONIC(XCHG, XCHG, "xchg"),
+    NORMAL_MNEMONIC(MEMC, MEMC, "memc"),
+    NORMAL_MNEMONIC(MEMS, MEMS, "mems"),
+    NORMAL_MNEMONIC(MEMT, MEMT, "memt"),
+    FP_MNEMONIC(FADD, FADD, "fadd"),
+    FP_MNEMONIC(FSUB, FSUB, "fsub"),
+    FP_MNEMONIC(FMAC, FMAC, "fmac"),
+    FP_MNEMONIC(FNMAC, FNMAC, "fnmac"),
+    FP_MNEMONIC(FMSC, FMSC, "fmsc"),
+    FP_MNEMONIC(FNMSC, FNMSC, "fnmsc"),
+    FP_MNEMONIC(FMUL, FMUL, "fmul"),
+    FP_MNEMONIC(FNMUL, FNMUL, "fnmul"),
+    FP_MNEMONIC(FNEG, FNEG, "fneg"),
+    FP_MNEMONIC(FABS, FABS, "fabs"),
+    FP_MNEMONIC(FCMP, FCMP, "fcmp"),
+    FP_MNEMONIC(FMOV, FMOV1, "fmov"),
+    NORMAL_MNEMONIC(FCASTS_D, FCASTS_D, "fcasts.d"),
+    NORMAL_MNEMONIC(FCASTD_S, FCASTD_S, "fcastd.s"),
+    NORMAL_MNEMONIC(LDA_W, LDA_W, "lda.w"),
+    NORMAL_MNEMONIC(CALL, CALL, "call"),
+    NORMAL_MNEMONIC(PICOSVMAC, PICOSVMAC0, "picosvmac"),
+    NORMAL_MNEMONIC(PICOSVMUL, PICOSVMUL0, "picosvmul"),
+    NORMAL_MNEMONIC(PICOVMAC, PICOVMAC0, "picovmac"),
+    NORMAL_MNEMONIC(PICOVMUL, PICOVMUL0, "picovmul"),
+    NORMAL_MNEMONIC(PICOLD_D, PICOLD_D2, "picold.d"),
+    NORMAL_MNEMONIC(PICOLD_W, PICOLD_W2, "picold.w"),
+    NORMAL_MNEMONIC(PICOLDM_D, PICOLDM_D, "picoldm.d"),
+    NORMAL_MNEMONIC(PICOLDM_W, PICOLDM_W, "picoldm.w"),
+    NORMAL_MNEMONIC(PICOMV_D, PICOMV_D1, "picomv.d"),
+    NORMAL_MNEMONIC(PICOMV_W, PICOMV_W1, "picomv.w"),
+    NORMAL_MNEMONIC(PICOST_D, PICOST_D2, "picost.d"),
+    NORMAL_MNEMONIC(PICOST_W, PICOST_W2, "picost.w"),
+    NORMAL_MNEMONIC(PICOSTM_D, PICOSTM_D, "picostm.d"),
+    NORMAL_MNEMONIC(PICOSTM_W, PICOSTM_W, "picostm.w"),
+    NORMAL_MNEMONIC(RSUBEQ, RSUBEQ, "rsubeq"),
+    NORMAL_MNEMONIC(RSUBNE, RSUBNE, "rsubne"),
+    NORMAL_MNEMONIC(RSUBCC, RSUBCC, "rsubcc"),
+    NORMAL_MNEMONIC(RSUBCS, RSUBCS, "rsubcs"),
+    NORMAL_MNEMONIC(RSUBGE, RSUBGE, "rsubge"),
+    NORMAL_MNEMONIC(RSUBLT, RSUBLT, "rsublt"),
+    NORMAL_MNEMONIC(RSUBMI, RSUBMI, "rsubmi"),
+    NORMAL_MNEMONIC(RSUBPL, RSUBPL, "rsubpl"),
+    NORMAL_MNEMONIC(RSUBLS, RSUBLS, "rsubls"),
+    NORMAL_MNEMONIC(RSUBGT, RSUBGT, "rsubgt"),
+    NORMAL_MNEMONIC(RSUBLE, RSUBLE, "rsuble"),
+    NORMAL_MNEMONIC(RSUBHI, RSUBHI, "rsubhi"),
+    NORMAL_MNEMONIC(RSUBVS, RSUBVS, "rsubvs"),
+    NORMAL_MNEMONIC(RSUBVC, RSUBVC, "rsubvc"),
+    NORMAL_MNEMONIC(RSUBQS, RSUBQS, "rsubqs"),
+    NORMAL_MNEMONIC(RSUBAL, RSUBAL, "rsubal"),
+    NORMAL_MNEMONIC(RSUBHS, RSUBHS, "rsubhs"),
+    NORMAL_MNEMONIC(RSUBLO, RSUBLO, "rsublo"),
+    NORMAL_MNEMONIC(ADDEQ, ADDEQ, "addeq"),
+    NORMAL_MNEMONIC(ADDNE, ADDNE, "addne"),
+    NORMAL_MNEMONIC(ADDCC, ADDCC, "addcc"),
+    NORMAL_MNEMONIC(ADDCS, ADDCS, "addcs"),
+    NORMAL_MNEMONIC(ADDGE, ADDGE, "addge"),
+    NORMAL_MNEMONIC(ADDLT, ADDLT, "addlt"),
+    NORMAL_MNEMONIC(ADDMI, ADDMI, "addmi"),
+    NORMAL_MNEMONIC(ADDPL, ADDPL, "addpl"),
+    NORMAL_MNEMONIC(ADDLS, ADDLS, "addls"),
+    NORMAL_MNEMONIC(ADDGT, ADDGT, "addgt"),
+    NORMAL_MNEMONIC(ADDLE, ADDLE, "addle"),
+    NORMAL_MNEMONIC(ADDHI, ADDHI, "addhi"),
+    NORMAL_MNEMONIC(ADDVS, ADDVS, "addvs"),
+    NORMAL_MNEMONIC(ADDVC, ADDVC, "addvc"),
+    NORMAL_MNEMONIC(ADDQS, ADDQS, "addqs"),
+    NORMAL_MNEMONIC(ADDAL, ADDAL, "addal"),
+    NORMAL_MNEMONIC(ADDHS, ADDHS, "addhs"),
+    NORMAL_MNEMONIC(ADDLO, ADDLO, "addlo"),
+    NORMAL_MNEMONIC(ANDEQ, ANDEQ, "andeq"),
+    NORMAL_MNEMONIC(ANDNE, ANDNE, "andne"),
+    NORMAL_MNEMONIC(ANDCC, ANDCC, "andcc"),
+    NORMAL_MNEMONIC(ANDCS, ANDCS, "andcs"),
+    NORMAL_MNEMONIC(ANDGE, ANDGE, "andge"),
+    NORMAL_MNEMONIC(ANDLT, ANDLT, "andlt"),
+    NORMAL_MNEMONIC(ANDMI, ANDMI, "andmi"),
+    NORMAL_MNEMONIC(ANDPL, ANDPL, "andpl"),
+    NORMAL_MNEMONIC(ANDLS, ANDLS, "andls"),
+    NORMAL_MNEMONIC(ANDGT, ANDGT, "andgt"),
+    NORMAL_MNEMONIC(ANDLE, ANDLE, "andle"),
+    NORMAL_MNEMONIC(ANDHI, ANDHI, "andhi"),
+    NORMAL_MNEMONIC(ANDVS, ANDVS, "andvs"),
+    NORMAL_MNEMONIC(ANDVC, ANDVC, "andvc"),
+    NORMAL_MNEMONIC(ANDQS, ANDQS, "andqs"),
+    NORMAL_MNEMONIC(ANDAL, ANDAL, "andal"),
+    NORMAL_MNEMONIC(ANDHS, ANDHS, "andhs"),
+    NORMAL_MNEMONIC(ANDLO, ANDLO, "andlo"),
+    NORMAL_MNEMONIC(OREQ, OREQ, "oreq"),
+    NORMAL_MNEMONIC(ORNE, ORNE, "orne"),
+    NORMAL_MNEMONIC(ORCC, ORCC, "orcc"),
+    NORMAL_MNEMONIC(ORCS, ORCS, "orcs"),
+    NORMAL_MNEMONIC(ORGE, ORGE, "orge"),
+    NORMAL_MNEMONIC(ORLT, ORLT, "orlt"),
+    NORMAL_MNEMONIC(ORMI, ORMI, "ormi"),
+    NORMAL_MNEMONIC(ORPL, ORPL, "orpl"),
+    NORMAL_MNEMONIC(ORLS, ORLS, "orls"),
+    NORMAL_MNEMONIC(ORGT, ORGT, "orgt"),
+    NORMAL_MNEMONIC(ORLE, ORLE, "orle"),
+    NORMAL_MNEMONIC(ORHI, ORHI, "orhi"),
+    NORMAL_MNEMONIC(ORVS, ORVS, "orvs"),
+    NORMAL_MNEMONIC(ORVC, ORVC, "orvc"),
+    NORMAL_MNEMONIC(ORQS, ORQS, "orqs"),
+    NORMAL_MNEMONIC(ORAL, ORAL, "oral"),
+    NORMAL_MNEMONIC(ORHS, ORHS, "orhs"),
+    NORMAL_MNEMONIC(ORLO, ORLO, "orlo"),
+    NORMAL_MNEMONIC(EOREQ, EOREQ, "eoreq"),
+    NORMAL_MNEMONIC(EORNE, EORNE, "eorne"),
+    NORMAL_MNEMONIC(EORCC, EORCC, "eorcc"),
+    NORMAL_MNEMONIC(EORCS, EORCS, "eorcs"),
+    NORMAL_MNEMONIC(EORGE, EORGE, "eorge"),
+    NORMAL_MNEMONIC(EORLT, EORLT, "eorlt"),
+    NORMAL_MNEMONIC(EORMI, EORMI, "eormi"),
+    NORMAL_MNEMONIC(EORPL, EORPL, "eorpl"),
+    NORMAL_MNEMONIC(EORLS, EORLS, "eorls"),
+    NORMAL_MNEMONIC(EORGT, EORGT, "eorgt"),
+    NORMAL_MNEMONIC(EORLE, EORLE, "eorle"),
+    NORMAL_MNEMONIC(EORHI, EORHI, "eorhi"),
+    NORMAL_MNEMONIC(EORVS, EORVS, "eorvs"),
+    NORMAL_MNEMONIC(EORVC, EORVC, "eorvc"),
+    NORMAL_MNEMONIC(EORQS, EORQS, "eorqs"),
+    NORMAL_MNEMONIC(EORAL, EORAL, "eoral"),
+    NORMAL_MNEMONIC(EORHS, EORHS, "eorhs"),
+    NORMAL_MNEMONIC(EORLO, EORLO, "eorlo"),
+    NORMAL_MNEMONIC(LD_WEQ, LD_WEQ, "ld.weq"),
+    NORMAL_MNEMONIC(LD_WNE, LD_WNE, "ld.wne"),
+    NORMAL_MNEMONIC(LD_WCC, LD_WCC, "ld.wcc"),
+    NORMAL_MNEMONIC(LD_WCS, LD_WCS, "ld.wcs"),
+    NORMAL_MNEMONIC(LD_WGE, LD_WGE, "ld.wge"),
+    NORMAL_MNEMONIC(LD_WLT, LD_WLT, "ld.wlt"),
+    NORMAL_MNEMONIC(LD_WMI, LD_WMI, "ld.wmi"),
+    NORMAL_MNEMONIC(LD_WPL, LD_WPL, "ld.wpl"),
+    NORMAL_MNEMONIC(LD_WLS, LD_WLS, "ld.wls"),
+    NORMAL_MNEMONIC(LD_WGT, LD_WGT, "ld.wgt"),
+    NORMAL_MNEMONIC(LD_WLE, LD_WLE, "ld.wle"),
+    NORMAL_MNEMONIC(LD_WHI, LD_WHI, "ld.whi"),
+    NORMAL_MNEMONIC(LD_WVS, LD_WVS, "ld.wvs"),
+    NORMAL_MNEMONIC(LD_WVC, LD_WVC, "ld.wvc"),
+    NORMAL_MNEMONIC(LD_WQS, LD_WQS, "ld.wqs"),
+    NORMAL_MNEMONIC(LD_WAL, LD_WAL, "ld.wal"),
+    NORMAL_MNEMONIC(LD_WHS, LD_WHS, "ld.whs"),
+    NORMAL_MNEMONIC(LD_WLO, LD_WLO, "ld.wlo"),
+    NORMAL_MNEMONIC(LD_SHEQ, LD_SHEQ, "ld.sheq"),
+    NORMAL_MNEMONIC(LD_SHNE, LD_SHNE, "ld.shne"),
+    NORMAL_MNEMONIC(LD_SHCC, LD_SHCC, "ld.shcc"),
+    NORMAL_MNEMONIC(LD_SHCS, LD_SHCS, "ld.shcs"),
+    NORMAL_MNEMONIC(LD_SHGE, LD_SHGE, "ld.shge"),
+    NORMAL_MNEMONIC(LD_SHLT, LD_SHLT, "ld.shlt"),
+    NORMAL_MNEMONIC(LD_SHMI, LD_SHMI, "ld.shmi"),
+    NORMAL_MNEMONIC(LD_SHPL, LD_SHPL, "ld.shpl"),
+    NORMAL_MNEMONIC(LD_SHLS, LD_SHLS, "ld.shls"),
+    NORMAL_MNEMONIC(LD_SHGT, LD_SHGT, "ld.shgt"),
+    NORMAL_MNEMONIC(LD_SHLE, LD_SHLE, "ld.shle"),
+    NORMAL_MNEMONIC(LD_SHHI, LD_SHHI, "ld.shhi"),
+    NORMAL_MNEMONIC(LD_SHVS, LD_SHVS, "ld.shvs"),
+    NORMAL_MNEMONIC(LD_SHVC, LD_SHVC, "ld.shvc"),
+    NORMAL_MNEMONIC(LD_SHQS, LD_SHQS, "ld.shqs"),
+    NORMAL_MNEMONIC(LD_SHAL, LD_SHAL, "ld.shal"),
+    NORMAL_MNEMONIC(LD_SHHS, LD_SHHS, "ld.shhs"),
+    NORMAL_MNEMONIC(LD_SHLO, LD_SHLO, "ld.shlo"),
+    NORMAL_MNEMONIC(LD_UHEQ, LD_UHEQ, "ld.uheq"),
+    NORMAL_MNEMONIC(LD_UHNE, LD_UHNE, "ld.uhne"),
+    NORMAL_MNEMONIC(LD_UHCC, LD_UHCC, "ld.uhcc"),
+    NORMAL_MNEMONIC(LD_UHCS, LD_UHCS, "ld.uhcs"),
+    NORMAL_MNEMONIC(LD_UHGE, LD_UHGE, "ld.uhge"),
+    NORMAL_MNEMONIC(LD_UHLT, LD_UHLT, "ld.uhlt"),
+    NORMAL_MNEMONIC(LD_UHMI, LD_UHMI, "ld.uhmi"),
+    NORMAL_MNEMONIC(LD_UHPL, LD_UHPL, "ld.uhpl"),
+    NORMAL_MNEMONIC(LD_UHLS, LD_UHLS, "ld.uhls"),
+    NORMAL_MNEMONIC(LD_UHGT, LD_UHGT, "ld.uhgt"),
+    NORMAL_MNEMONIC(LD_UHLE, LD_UHLE, "ld.uhle"),
+    NORMAL_MNEMONIC(LD_UHHI, LD_UHHI, "ld.uhhi"),
+    NORMAL_MNEMONIC(LD_UHVS, LD_UHVS, "ld.uhvs"),
+    NORMAL_MNEMONIC(LD_UHVC, LD_UHVC, "ld.uhvc"),
+    NORMAL_MNEMONIC(LD_UHQS, LD_UHQS, "ld.uhqs"),
+    NORMAL_MNEMONIC(LD_UHAL, LD_UHAL, "ld.uhal"),
+    NORMAL_MNEMONIC(LD_UHHS, LD_UHHS, "ld.uhhs"),
+    NORMAL_MNEMONIC(LD_UHLO, LD_UHLO, "ld.uhlo"),
+    NORMAL_MNEMONIC(LD_SBEQ, LD_SBEQ, "ld.sbeq"),
+    NORMAL_MNEMONIC(LD_SBNE, LD_SBNE, "ld.sbne"),
+    NORMAL_MNEMONIC(LD_SBCC, LD_SBCC, "ld.sbcc"),
+    NORMAL_MNEMONIC(LD_SBCS, LD_SBCS, "ld.sbcs"),
+    NORMAL_MNEMONIC(LD_SBGE, LD_SBGE, "ld.sbge"),
+    NORMAL_MNEMONIC(LD_SBLT, LD_SBLT, "ld.sblt"),
+    NORMAL_MNEMONIC(LD_SBMI, LD_SBMI, "ld.sbmi"),
+    NORMAL_MNEMONIC(LD_SBPL, LD_SBPL, "ld.sbpl"),
+    NORMAL_MNEMONIC(LD_SBLS, LD_SBLS, "ld.sbls"),
+    NORMAL_MNEMONIC(LD_SBGT, LD_SBGT, "ld.sbgt"),
+    NORMAL_MNEMONIC(LD_SBLE, LD_SBLE, "ld.sble"),
+    NORMAL_MNEMONIC(LD_SBHI, LD_SBHI, "ld.sbhi"),
+    NORMAL_MNEMONIC(LD_SBVS, LD_SBVS, "ld.sbvs"),
+    NORMAL_MNEMONIC(LD_SBVC, LD_SBVC, "ld.sbvc"),
+    NORMAL_MNEMONIC(LD_SBQS, LD_SBQS, "ld.sbqs"),
+    NORMAL_MNEMONIC(LD_SBAL, LD_SBAL, "ld.sbal"),
+    NORMAL_MNEMONIC(LD_SBHS, LD_SBHS, "ld.sbhs"),
+    NORMAL_MNEMONIC(LD_SBLO, LD_SBLO, "ld.sblo"),
+    NORMAL_MNEMONIC(LD_UBEQ, LD_UBEQ, "ld.ubeq"),
+    NORMAL_MNEMONIC(LD_UBNE, LD_UBNE, "ld.ubne"),
+    NORMAL_MNEMONIC(LD_UBCC, LD_UBCC, "ld.ubcc"),
+    NORMAL_MNEMONIC(LD_UBCS, LD_UBCS, "ld.ubcs"),
+    NORMAL_MNEMONIC(LD_UBGE, LD_UBGE, "ld.ubge"),
+    NORMAL_MNEMONIC(LD_UBLT, LD_UBLT, "ld.ublt"),
+    NORMAL_MNEMONIC(LD_UBMI, LD_UBMI, "ld.ubmi"),
+    NORMAL_MNEMONIC(LD_UBPL, LD_UBPL, "ld.ubpl"),
+    NORMAL_MNEMONIC(LD_UBLS, LD_UBLS, "ld.ubls"),
+    NORMAL_MNEMONIC(LD_UBGT, LD_UBGT, "ld.ubgt"),
+    NORMAL_MNEMONIC(LD_UBLE, LD_UBLE, "ld.uble"),
+    NORMAL_MNEMONIC(LD_UBHI, LD_UBHI, "ld.ubhi"),
+    NORMAL_MNEMONIC(LD_UBVS, LD_UBVS, "ld.ubvs"),
+    NORMAL_MNEMONIC(LD_UBVC, LD_UBVC, "ld.ubvc"),
+    NORMAL_MNEMONIC(LD_UBQS, LD_UBQS, "ld.ubqs"),
+    NORMAL_MNEMONIC(LD_UBAL, LD_UBAL, "ld.ubal"),
+    NORMAL_MNEMONIC(LD_UBHS, LD_UBHS, "ld.ubhs"),
+    NORMAL_MNEMONIC(LD_UBLO, LD_UBLO, "ld.ublo"),
+    NORMAL_MNEMONIC(ST_WEQ, ST_WEQ, "st.weq"),
+    NORMAL_MNEMONIC(ST_WNE, ST_WNE, "st.wne"),
+    NORMAL_MNEMONIC(ST_WCC, ST_WCC, "st.wcc"),
+    NORMAL_MNEMONIC(ST_WCS, ST_WCS, "st.wcs"),
+    NORMAL_MNEMONIC(ST_WGE, ST_WGE, "st.wge"),
+    NORMAL_MNEMONIC(ST_WLT, ST_WLT, "st.wlt"),
+    NORMAL_MNEMONIC(ST_WMI, ST_WMI, "st.wmi"),
+    NORMAL_MNEMONIC(ST_WPL, ST_WPL, "st.wpl"),
+    NORMAL_MNEMONIC(ST_WLS, ST_WLS, "st.wls"),
+    NORMAL_MNEMONIC(ST_WGT, ST_WGT, "st.wgt"),
+    NORMAL_MNEMONIC(ST_WLE, ST_WLE, "st.wle"),
+    NORMAL_MNEMONIC(ST_WHI, ST_WHI, "st.whi"),
+    NORMAL_MNEMONIC(ST_WVS, ST_WVS, "st.wvs"),
+    NORMAL_MNEMONIC(ST_WVC, ST_WVC, "st.wvc"),
+    NORMAL_MNEMONIC(ST_WQS, ST_WQS, "st.wqs"),
+    NORMAL_MNEMONIC(ST_WAL, ST_WAL, "st.wal"),
+    NORMAL_MNEMONIC(ST_WHS, ST_WHS, "st.whs"),
+    NORMAL_MNEMONIC(ST_WLO, ST_WLO, "st.wlo"),
+    NORMAL_MNEMONIC(ST_HEQ, ST_HEQ, "st.heq"),
+    NORMAL_MNEMONIC(ST_HNE, ST_HNE, "st.hne"),
+    NORMAL_MNEMONIC(ST_HCC, ST_HCC, "st.hcc"),
+    NORMAL_MNEMONIC(ST_HCS, ST_HCS, "st.hcs"),
+    NORMAL_MNEMONIC(ST_HGE, ST_HGE, "st.hge"),
+    NORMAL_MNEMONIC(ST_HLT, ST_HLT, "st.hlt"),
+    NORMAL_MNEMONIC(ST_HMI, ST_HMI, "st.hmi"),
+    NORMAL_MNEMONIC(ST_HPL, ST_HPL, "st.hpl"),
+    NORMAL_MNEMONIC(ST_HLS, ST_HLS, "st.hls"),
+    NORMAL_MNEMONIC(ST_HGT, ST_HGT, "st.hgt"),
+    NORMAL_MNEMONIC(ST_HLE, ST_HLE, "st.hle"),
+    NORMAL_MNEMONIC(ST_HHI, ST_HHI, "st.hhi"),
+    NORMAL_MNEMONIC(ST_HVS, ST_HVS, "st.hvs"),
+    NORMAL_MNEMONIC(ST_HVC, ST_HVC, "st.hvc"),
+    NORMAL_MNEMONIC(ST_HQS, ST_HQS, "st.hqs"),
+    NORMAL_MNEMONIC(ST_HAL, ST_HAL, "st.hal"),
+    NORMAL_MNEMONIC(ST_HHS, ST_HHS, "st.hhs"),
+    NORMAL_MNEMONIC(ST_HLO, ST_HLO, "st.hlo"),
+    NORMAL_MNEMONIC(ST_BEQ, ST_BEQ, "st.beq"),
+    NORMAL_MNEMONIC(ST_BNE, ST_BNE, "st.bne"),
+    NORMAL_MNEMONIC(ST_BCC, ST_BCC, "st.bcc"),
+    NORMAL_MNEMONIC(ST_BCS, ST_BCS, "st.bcs"),
+    NORMAL_MNEMONIC(ST_BGE, ST_BGE, "st.bge"),
+    NORMAL_MNEMONIC(ST_BLT, ST_BLT, "st.blt"),
+    NORMAL_MNEMONIC(ST_BMI, ST_BMI, "st.bmi"),
+    NORMAL_MNEMONIC(ST_BPL, ST_BPL, "st.bpl"),
+    NORMAL_MNEMONIC(ST_BLS, ST_BLS, "st.bls"),
+    NORMAL_MNEMONIC(ST_BGT, ST_BGT, "st.bgt"),
+    NORMAL_MNEMONIC(ST_BLE, ST_BLE, "st.ble"),
+    NORMAL_MNEMONIC(ST_BHI, ST_BHI, "st.bhi"),
+    NORMAL_MNEMONIC(ST_BVS, ST_BVS, "st.bvs"),
+    NORMAL_MNEMONIC(ST_BVC, ST_BVC, "st.bvc"),
+    NORMAL_MNEMONIC(ST_BQS, ST_BQS, "st.bqs"),
+    NORMAL_MNEMONIC(ST_BAL, ST_BAL, "st.bal"),
+    NORMAL_MNEMONIC(ST_BHS, ST_BHS, "st.bhs"),
+    NORMAL_MNEMONIC(ST_BLO, ST_BLO, "st.blo"),
+    NORMAL_MNEMONIC(MOVH, MOVH, "movh"),
+
+  };
+#undef NORMAL_MNEMONIC
+#undef ALIAS_MNEMONIC
+#undef FP_MNEMONIC
diff -Nrup gdb-6.7.1/opcodes/avr32-opc.h gdb-6.7.1-atmel/opcodes/avr32-opc.h
--- gdb-6.7.1/opcodes/avr32-opc.h	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/opcodes/avr32-opc.h	2008-04-03 15:00:36.000000000 +0200
@@ -0,0 +1,2371 @@
+/* Opcode tables for AVR32.
+   Copyright 2005, 2006 Atmel Corporation.
+
+   Written by Haavard Skinnemoen, Atmel Norway, <hskinnemoen@atmel.com>
+
+   This file is part of libopcodes.
+
+   This program is free software; you can redistribute it and/or
+   modify it under the terms of the GNU General Public License as
+   published by the Free Software Foundation; either version 2 of the
+   License, or (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with this program; if not, write to the Free Software
+   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+   02111-1307, USA.  */
+
+#include "bfd.h"
+
+#define AVR32_MAX_OPERANDS  8
+#define AVR32_MAX_FIELDS    8
+
+#define AVR32_V1            (1 << 1)
+#define AVR32_SIMD      (1 << 2)
+#define AVR32_DSP       (1 << 3)
+#define AVR32_RMW       (1 << 4)
+#define AVR32_V2            (1 << 5)
+#define AVR32_FP        (1 << 16)
+#define AVR32_PICO      (1 << 17)
+
+/* Registers we commonly refer to */
+#define AVR32_REG_R12       12
+#define AVR32_REG_SP        13
+#define AVR32_REG_LR        14
+#define AVR32_REG_PC        15
+
+struct avr32_ifield
+{
+  int id;
+  unsigned short bitsize;
+  unsigned short shift;
+  unsigned long mask;
+
+  /* If the value doesn't fit, it will be truncated with no warning */
+  void (*insert)(const struct avr32_ifield *, void *, unsigned long);
+  void (*extract)(const struct avr32_ifield *, void *, unsigned long *);
+};
+
+struct avr32_opcode
+{
+  int id;
+  int size;
+  unsigned long value;
+  unsigned long mask;
+  const struct avr32_syntax *syntax;
+  bfd_reloc_code_real_type reloc_type;
+  unsigned int nr_fields;
+  /* if relaxable, which field is variable, otherwise -1 */
+  int var_field;
+  const struct avr32_ifield *fields[AVR32_MAX_FIELDS];
+};
+
+struct avr32_alias
+{
+  int id;
+  const struct avr32_opcode *opc;
+  struct {
+    int is_opindex;
+    unsigned long value;
+  } operand_map[AVR32_MAX_OPERANDS];
+};
+
+struct avr32_syntax
+{
+  int id;
+  unsigned long isa_flags;
+  const struct avr32_mnemonic *mnemonic;
+  int type;
+  union {
+    const struct avr32_opcode *opc;
+    const struct avr32_alias *alias;
+  } u;
+  const struct avr32_syntax *next;
+  /* negative means "vararg" */
+  int nr_operands;
+  int operand[AVR32_MAX_OPERANDS];
+};
+
+#if 0
+#define AVR32_ALIAS_MAKE_CONST(val) ((val) | 0x80000000UL)
+#define AVR32_ALIAS_IS_CONST(mapval) (((mapval) & 0x80000000UL) != 0)
+#define AVR32_ALIAS_GET_CONST(mapval) ((mapval) & ~0x80000000UL)
+#endif
+
+struct avr32_mnemonic
+{
+  int id;
+  const char *name;
+  const struct avr32_syntax *syntax;
+};
+
+extern const struct avr32_ifield avr32_ifield_table[];
+extern struct avr32_opcode avr32_opc_table[];
+extern const struct avr32_syntax avr32_syntax_table[];
+extern const struct avr32_alias avr32_alias_table[];
+extern const struct avr32_mnemonic avr32_mnemonic_table[];
+
+extern void avr32_insert_simple(const struct avr32_ifield *field,
+                void *buf, unsigned long value);
+extern void avr32_insert_bit5c(const struct avr32_ifield *field,
+                   void *buf, unsigned long value);
+extern void avr32_insert_k10(const struct avr32_ifield *field,
+                 void *buf, unsigned long value);
+extern void avr32_insert_k21(const struct avr32_ifield *field,
+                 void *buf, unsigned long value);
+extern void avr32_insert_cpop(const struct avr32_ifield *field,
+                  void *buf, unsigned long value);
+extern void avr32_insert_k12cp(const struct avr32_ifield *field,
+                   void *buf, unsigned long value);
+
+extern void avr32_extract_simple(const struct avr32_ifield *field,
+                 void *buf, unsigned long *value);
+extern void avr32_extract_bit5c(const struct avr32_ifield *field,
+                void *buf, unsigned long *value);
+extern void avr32_extract_k10(const struct avr32_ifield *field,
+                  void *buf, unsigned long *value);
+extern void avr32_extract_k21(const struct avr32_ifield *field,
+                  void *buf, unsigned long *value);
+extern void avr32_extract_cpop(const struct avr32_ifield *field,
+                   void *buf, unsigned long *value);
+extern void avr32_extract_k12cp(const struct avr32_ifield *field,
+                void *buf, unsigned long *value);
+
+enum avr32_operand_type
+{
+  AVR32_OPERAND_INTREG,     /* just a register */
+  AVR32_OPERAND_INTREG_PREDEC,  /* register with pre-decrement */
+  AVR32_OPERAND_INTREG_POSTINC, /* register with post-increment */
+  AVR32_OPERAND_INTREG_LSL, /* register with left shift */
+  AVR32_OPERAND_INTREG_LSR, /* register with right shift */
+  AVR32_OPERAND_INTREG_BSEL,    /* register with byte selector */
+  AVR32_OPERAND_INTREG_HSEL,    /* register with halfword selector */
+  AVR32_OPERAND_INTREG_SDISP,   /* Rp[signed disp] */
+  AVR32_OPERAND_INTREG_SDISP_H, /* Rp[signed hword-aligned disp] */
+  AVR32_OPERAND_INTREG_SDISP_W, /* Rp[signed word-aligned disp] */
+  AVR32_OPERAND_INTREG_UDISP,   /* Rp[unsigned disp] */
+  AVR32_OPERAND_INTREG_UDISP_H, /* Rp[unsigned hword-aligned disp] */
+  AVR32_OPERAND_INTREG_UDISP_W, /* Rp[unsigned word-aligned disp] */
+  AVR32_OPERAND_INTREG_INDEX,   /* Rp[Ri << sa] */
+  AVR32_OPERAND_INTREG_XINDEX,  /* Rp[Ri:bytesel << 2] */
+  AVR32_OPERAND_DWREG,      /* Even-numbered register */
+  AVR32_OPERAND_PC_UDISP_W, /* PC[unsigned word-aligned disp] or label */
+  AVR32_OPERAND_SP,     /* Just SP */
+  AVR32_OPERAND_SP_UDISP_W, /* SP[unsigned word-aligned disp] */
+  AVR32_OPERAND_CPNO,
+  AVR32_OPERAND_CPREG,
+  AVR32_OPERAND_CPREG_D,
+  AVR32_OPERAND_UNSIGNED_CONST,
+  AVR32_OPERAND_UNSIGNED_CONST_W,
+  AVR32_OPERAND_SIGNED_CONST,
+  AVR32_OPERAND_SIGNED_CONST_W,
+  AVR32_OPERAND_JMPLABEL,
+  AVR32_OPERAND_UNSIGNED_NUMBER,
+  AVR32_OPERAND_UNSIGNED_NUMBER_W,
+  AVR32_OPERAND_REGLIST8,
+  AVR32_OPERAND_REGLIST9,
+  AVR32_OPERAND_REGLIST16,
+  AVR32_OPERAND_REGLIST_LDM,
+  AVR32_OPERAND_REGLIST_CP8,
+  AVR32_OPERAND_REGLIST_CPD8,
+  AVR32_OPERAND_RETVAL,
+  AVR32_OPERAND_MCALL,
+  AVR32_OPERAND_JOSPINC,
+  AVR32_OPERAND_COH,
+  AVR32_OPERAND_FPREG_S,
+  AVR32_OPERAND_FPREG_D,
+  AVR32_OPERAND_PICO_REG_W,
+  AVR32_OPERAND_PICO_REG_D,
+  AVR32_OPERAND_PICO_REGLIST_W,
+  AVR32_OPERAND_PICO_REGLIST_D,
+  AVR32_OPERAND_PICO_IN,
+  AVR32_OPERAND_PICO_OUT0,
+  AVR32_OPERAND_PICO_OUT1,
+  AVR32_OPERAND_PICO_OUT2,
+  AVR32_OPERAND_PICO_OUT3,
+  AVR32_OPERAND__END_
+};
+#define AVR32_OPERAND_UNKNOWN AVR32_OPERAND__END_
+#define AVR32_NR_OPERANDS AVR32_OPERAND__END_
+
+enum avr32_ifield_type
+{
+  AVR32_IFIELD_RX,
+  AVR32_IFIELD_RY,
+  AVR32_IFIELD_COND4C,
+  AVR32_IFIELD_K8C,
+  AVR32_IFIELD_K7C,
+  AVR32_IFIELD_K5C,
+  AVR32_IFIELD_K3,
+  AVR32_IFIELD_RY_DW,
+  AVR32_IFIELD_COND4E,
+  AVR32_IFIELD_K8E,
+  AVR32_IFIELD_BIT5C,
+  AVR32_IFIELD_COND3,
+  AVR32_IFIELD_K10,
+  AVR32_IFIELD_POPM,
+  AVR32_IFIELD_K2,
+  AVR32_IFIELD_RD_E,
+  AVR32_IFIELD_RD_DW,
+  AVR32_IFIELD_X,
+  AVR32_IFIELD_Y,
+  AVR32_IFIELD_X2,
+  AVR32_IFIELD_Y2,
+  AVR32_IFIELD_K5E,
+  AVR32_IFIELD_PART2,
+  AVR32_IFIELD_PART1,
+  AVR32_IFIELD_K16,
+  AVR32_IFIELD_CACHEOP,
+  AVR32_IFIELD_K11,
+  AVR32_IFIELD_K21,
+  AVR32_IFIELD_CPOP,
+  AVR32_IFIELD_CPNO,
+  AVR32_IFIELD_CRD_RI,
+  AVR32_IFIELD_CRX,
+  AVR32_IFIELD_CRY,
+  AVR32_IFIELD_K7E,
+  AVR32_IFIELD_CRD_DW,
+  AVR32_IFIELD_PART1_K12,
+  AVR32_IFIELD_PART2_K12,
+  AVR32_IFIELD_K12,
+  AVR32_IFIELD_S5,
+  AVR32_IFIELD_K5E2,
+  AVR32_IFIELD_K4,
+  AVR32_IFIELD_COND4E2,
+  AVR32_IFIELD_K8E2,
+  AVR32_IFIELD_K6,
+  AVR32_IFIELD_MEM15,
+  AVR32_IFIELD_MEMB5,
+  AVR32_IFIELD_W,
+  AVR32_IFIELD_CM_HL,
+  AVR32_IFIELD_K12CP,
+  AVR32_IFIELD_K9E,
+  AVR32_IFIELD__END_,
+};
+#define AVR32_NR_IFIELDS AVR32_IFIELD__END_
+
+enum avr32_opc_type
+{
+  AVR32_OPC_ABS,
+  AVR32_OPC_ACALL,
+  AVR32_OPC_ACR,
+  AVR32_OPC_ADC,
+  AVR32_OPC_ADD1,
+  AVR32_OPC_ADD2,
+  AVR32_OPC_ADDABS,
+  AVR32_OPC_ADDHH_W,
+  AVR32_OPC_AND1,
+  AVR32_OPC_AND2,
+  AVR32_OPC_AND3,
+  AVR32_OPC_ANDH,
+  AVR32_OPC_ANDH_COH,
+  AVR32_OPC_ANDL,
+  AVR32_OPC_ANDL_COH,
+  AVR32_OPC_ANDN,
+  AVR32_OPC_ASR1,
+  AVR32_OPC_ASR3,
+  AVR32_OPC_ASR2,
+  AVR32_OPC_BLD,
+  AVR32_OPC_BREQ1,
+  AVR32_OPC_BRNE1,
+  AVR32_OPC_BRCC1,
+  AVR32_OPC_BRCS1,
+  AVR32_OPC_BRGE1,
+  AVR32_OPC_BRLT1,
+  AVR32_OPC_BRMI1,
+  AVR32_OPC_BRPL1,
+  AVR32_OPC_BREQ2,
+  AVR32_OPC_BRNE2,
+  AVR32_OPC_BRCC2,
+  AVR32_OPC_BRCS2,
+  AVR32_OPC_BRGE2,
+  AVR32_OPC_BRLT2,
+  AVR32_OPC_BRMI2,
+  AVR32_OPC_BRPL2,
+  AVR32_OPC_BRLS,
+  AVR32_OPC_BRGT,
+  AVR32_OPC_BRLE,
+  AVR32_OPC_BRHI,
+  AVR32_OPC_BRVS,
+  AVR32_OPC_BRVC,
+  AVR32_OPC_BRQS,
+  AVR32_OPC_BRAL,
+  AVR32_OPC_BREAKPOINT,
+  AVR32_OPC_BREV,
+  AVR32_OPC_BST,
+  AVR32_OPC_CACHE,
+  AVR32_OPC_CASTS_B,
+  AVR32_OPC_CASTS_H,
+  AVR32_OPC_CASTU_B,
+  AVR32_OPC_CASTU_H,
+  AVR32_OPC_CBR,
+  AVR32_OPC_CLZ,
+  AVR32_OPC_COM,
+  AVR32_OPC_COP,
+  AVR32_OPC_CP_B,
+  AVR32_OPC_CP_H,
+  AVR32_OPC_CP_W1,
+  AVR32_OPC_CP_W2,
+  AVR32_OPC_CP_W3,
+  AVR32_OPC_CPC1,
+  AVR32_OPC_CPC2,
+  AVR32_OPC_CSRF,
+  AVR32_OPC_CSRFCZ,
+  AVR32_OPC_DIVS,
+  AVR32_OPC_DIVU,
+  AVR32_OPC_EOR1,
+  AVR32_OPC_EOR2,
+  AVR32_OPC_EOR3,
+  AVR32_OPC_EORL,
+  AVR32_OPC_EORH,
+  AVR32_OPC_FRS,
+  AVR32_OPC_ICALL,
+  AVR32_OPC_INCJOSP,
+  AVR32_OPC_LD_D1,
+  AVR32_OPC_LD_D2,
+  AVR32_OPC_LD_D3,
+  AVR32_OPC_LD_D5,
+  AVR32_OPC_LD_D4,
+  AVR32_OPC_LD_SB2,
+  AVR32_OPC_LD_SB1,
+  AVR32_OPC_LD_UB1,
+  AVR32_OPC_LD_UB2,
+  AVR32_OPC_LD_UB5,
+  AVR32_OPC_LD_UB3,
+  AVR32_OPC_LD_UB4,
+  AVR32_OPC_LD_SH1,
+  AVR32_OPC_LD_SH2,
+  AVR32_OPC_LD_SH5,
+  AVR32_OPC_LD_SH3,
+  AVR32_OPC_LD_SH4,
+  AVR32_OPC_LD_UH1,
+  AVR32_OPC_LD_UH2,
+  AVR32_OPC_LD_UH5,
+  AVR32_OPC_LD_UH3,
+  AVR32_OPC_LD_UH4,
+  AVR32_OPC_LD_W1,
+  AVR32_OPC_LD_W2,
+  AVR32_OPC_LD_W5,
+  AVR32_OPC_LD_W6,
+  AVR32_OPC_LD_W3,
+  AVR32_OPC_LD_W4,
+  AVR32_OPC_LDC_D1,
+  AVR32_OPC_LDC_D2,
+  AVR32_OPC_LDC_D3,
+  AVR32_OPC_LDC_W1,
+  AVR32_OPC_LDC_W2,
+  AVR32_OPC_LDC_W3,
+  AVR32_OPC_LDC0_D,
+  AVR32_OPC_LDC0_W,
+  AVR32_OPC_LDCM_D,
+  AVR32_OPC_LDCM_D_PU,
+  AVR32_OPC_LDCM_W,
+  AVR32_OPC_LDCM_W_PU,
+  AVR32_OPC_LDDPC,
+  AVR32_OPC_LDDPC_EXT,
+  AVR32_OPC_LDDSP,
+  AVR32_OPC_LDINS_B,
+  AVR32_OPC_LDINS_H,
+  AVR32_OPC_LDM,
+  AVR32_OPC_LDMTS,
+  AVR32_OPC_LDMTS_PU,
+  AVR32_OPC_LDSWP_SH,
+  AVR32_OPC_LDSWP_UH,
+  AVR32_OPC_LDSWP_W,
+  AVR32_OPC_LSL1,
+  AVR32_OPC_LSL3,
+  AVR32_OPC_LSL2,
+  AVR32_OPC_LSR1,
+  AVR32_OPC_LSR3,
+  AVR32_OPC_LSR2,
+  AVR32_OPC_MAC,
+  AVR32_OPC_MACHH_D,
+  AVR32_OPC_MACHH_W,
+  AVR32_OPC_MACS_D,
+  AVR32_OPC_MACSATHH_W,
+  AVR32_OPC_MACUD,
+  AVR32_OPC_MACWH_D,
+  AVR32_OPC_MAX,
+  AVR32_OPC_MCALL,
+  AVR32_OPC_MFDR,
+  AVR32_OPC_MFSR,
+  AVR32_OPC_MIN,
+  AVR32_OPC_MOV3,
+  AVR32_OPC_MOV1,
+  AVR32_OPC_MOV2,
+  AVR32_OPC_MOVEQ1,
+  AVR32_OPC_MOVNE1,
+  AVR32_OPC_MOVCC1,
+  AVR32_OPC_MOVCS1,
+  AVR32_OPC_MOVGE1,
+  AVR32_OPC_MOVLT1,
+  AVR32_OPC_MOVMI1,
+  AVR32_OPC_MOVPL1,
+  AVR32_OPC_MOVLS1,
+  AVR32_OPC_MOVGT1,
+  AVR32_OPC_MOVLE1,
+  AVR32_OPC_MOVHI1,
+  AVR32_OPC_MOVVS1,
+  AVR32_OPC_MOVVC1,
+  AVR32_OPC_MOVQS1,
+  AVR32_OPC_MOVAL1,
+  AVR32_OPC_MOVEQ2,
+  AVR32_OPC_MOVNE2,
+  AVR32_OPC_MOVCC2,
+  AVR32_OPC_MOVCS2,
+  AVR32_OPC_MOVGE2,
+  AVR32_OPC_MOVLT2,
+  AVR32_OPC_MOVMI2,
+  AVR32_OPC_MOVPL2,
+  AVR32_OPC_MOVLS2,
+  AVR32_OPC_MOVGT2,
+  AVR32_OPC_MOVLE2,
+  AVR32_OPC_MOVHI2,
+  AVR32_OPC_MOVVS2,
+  AVR32_OPC_MOVVC2,
+  AVR32_OPC_MOVQS2,
+  AVR32_OPC_MOVAL2,
+  AVR32_OPC_MTDR,
+  AVR32_OPC_MTSR,
+  AVR32_OPC_MUL1,
+  AVR32_OPC_MUL2,
+  AVR32_OPC_MUL3,
+  AVR32_OPC_MULHH_W,
+  AVR32_OPC_MULNHH_W,
+  AVR32_OPC_MULNWH_D,
+  AVR32_OPC_MULSD,
+  AVR32_OPC_MULSATHH_H,
+  AVR32_OPC_MULSATHH_W,
+  AVR32_OPC_MULSATRNDHH_H,
+  AVR32_OPC_MULSATRNDWH_W,
+  AVR32_OPC_MULSATWH_W,
+  AVR32_OPC_MULU_D,
+  AVR32_OPC_MULWH_D,
+  AVR32_OPC_MUSFR,
+  AVR32_OPC_MUSTR,
+  AVR32_OPC_MVCR_D,
+  AVR32_OPC_MVCR_W,
+  AVR32_OPC_MVRC_D,
+  AVR32_OPC_MVRC_W,
+  AVR32_OPC_NEG,
+  AVR32_OPC_NOP,
+  AVR32_OPC_OR1,
+  AVR32_OPC_OR2,
+  AVR32_OPC_OR3,
+  AVR32_OPC_ORH,
+  AVR32_OPC_ORL,
+  AVR32_OPC_PABS_SB,
+  AVR32_OPC_PABS_SH,
+  AVR32_OPC_PACKSH_SB,
+  AVR32_OPC_PACKSH_UB,
+  AVR32_OPC_PACKW_SH,
+  AVR32_OPC_PADD_B,
+  AVR32_OPC_PADD_H,
+  AVR32_OPC_PADDH_SH,
+  AVR32_OPC_PADDH_UB,
+  AVR32_OPC_PADDS_SB,
+  AVR32_OPC_PADDS_SH,
+  AVR32_OPC_PADDS_UB,
+  AVR32_OPC_PADDS_UH,
+  AVR32_OPC_PADDSUB_H,
+  AVR32_OPC_PADDSUBH_SH,
+  AVR32_OPC_PADDSUBS_SH,
+  AVR32_OPC_PADDSUBS_UH,
+  AVR32_OPC_PADDX_H,
+  AVR32_OPC_PADDXH_SH,
+  AVR32_OPC_PADDXS_SH,
+  AVR32_OPC_PADDXS_UH,
+  AVR32_OPC_PASR_B,
+  AVR32_OPC_PASR_H,
+  AVR32_OPC_PAVG_SH,
+  AVR32_OPC_PAVG_UB,
+  AVR32_OPC_PLSL_B,
+  AVR32_OPC_PLSL_H,
+  AVR32_OPC_PLSR_B,
+  AVR32_OPC_PLSR_H,
+  AVR32_OPC_PMAX_SH,
+  AVR32_OPC_PMAX_UB,
+  AVR32_OPC_PMIN_SH,
+  AVR32_OPC_PMIN_UB,
+  AVR32_OPC_POPJC,
+  AVR32_OPC_POPM,
+  AVR32_OPC_POPM_E,
+  AVR32_OPC_PREF,
+  AVR32_OPC_PSAD,
+  AVR32_OPC_PSUB_B,
+  AVR32_OPC_PSUB_H,
+  AVR32_OPC_PSUBADD_H,
+  AVR32_OPC_PSUBADDH_SH,
+  AVR32_OPC_PSUBADDS_SH,
+  AVR32_OPC_PSUBADDS_UH,
+  AVR32_OPC_PSUBH_SH,
+  AVR32_OPC_PSUBH_UB,
+  AVR32_OPC_PSUBS_SB,
+  AVR32_OPC_PSUBS_SH,
+  AVR32_OPC_PSUBS_UB,
+  AVR32_OPC_PSUBS_UH,
+  AVR32_OPC_PSUBX_H,
+  AVR32_OPC_PSUBXH_SH,
+  AVR32_OPC_PSUBXS_SH,
+  AVR32_OPC_PSUBXS_UH,
+  AVR32_OPC_PUNPCKSB_H,
+  AVR32_OPC_PUNPCKUB_H,
+  AVR32_OPC_PUSHJC,
+  AVR32_OPC_PUSHM,
+  AVR32_OPC_PUSHM_E,
+  AVR32_OPC_RCALL1,
+  AVR32_OPC_RCALL2,
+  AVR32_OPC_RETEQ,
+  AVR32_OPC_RETNE,
+  AVR32_OPC_RETCC,
+  AVR32_OPC_RETCS,
+  AVR32_OPC_RETGE,
+  AVR32_OPC_RETLT,
+  AVR32_OPC_RETMI,
+  AVR32_OPC_RETPL,
+  AVR32_OPC_RETLS,
+  AVR32_OPC_RETGT,
+  AVR32_OPC_RETLE,
+  AVR32_OPC_RETHI,
+  AVR32_OPC_RETVS,
+  AVR32_OPC_RETVC,
+  AVR32_OPC_RETQS,
+  AVR32_OPC_RETAL,
+  AVR32_OPC_RETD,
+  AVR32_OPC_RETE,
+  AVR32_OPC_RETJ,
+  AVR32_OPC_RETS,
+  AVR32_OPC_RJMP,
+  AVR32_OPC_ROL,
+  AVR32_OPC_ROR,
+  AVR32_OPC_RSUB1,
+  AVR32_OPC_RSUB2,
+  AVR32_OPC_SATADD_H,
+  AVR32_OPC_SATADD_W,
+  AVR32_OPC_SATRNDS,
+  AVR32_OPC_SATRNDU,
+  AVR32_OPC_SATS,
+  AVR32_OPC_SATSUB_H,
+  AVR32_OPC_SATSUB_W1,
+  AVR32_OPC_SATSUB_W2,
+  AVR32_OPC_SATU,
+  AVR32_OPC_SBC,
+  AVR32_OPC_SBR,
+  AVR32_OPC_SCALL,
+  AVR32_OPC_SCR,
+  AVR32_OPC_SLEEP,
+  AVR32_OPC_SREQ,
+  AVR32_OPC_SRNE,
+  AVR32_OPC_SRCC,
+  AVR32_OPC_SRCS,
+  AVR32_OPC_SRGE,
+  AVR32_OPC_SRLT,
+  AVR32_OPC_SRMI,
+  AVR32_OPC_SRPL,
+  AVR32_OPC_SRLS,
+  AVR32_OPC_SRGT,
+  AVR32_OPC_SRLE,
+  AVR32_OPC_SRHI,
+  AVR32_OPC_SRVS,
+  AVR32_OPC_SRVC,
+  AVR32_OPC_SRQS,
+  AVR32_OPC_SRAL,
+  AVR32_OPC_SSRF,
+  AVR32_OPC_ST_B1,
+  AVR32_OPC_ST_B2,
+  AVR32_OPC_ST_B5,
+  AVR32_OPC_ST_B3,
+  AVR32_OPC_ST_B4,
+  AVR32_OPC_ST_D1,
+  AVR32_OPC_ST_D2,
+  AVR32_OPC_ST_D3,
+  AVR32_OPC_ST_D5,
+  AVR32_OPC_ST_D4,
+  AVR32_OPC_ST_H1,
+  AVR32_OPC_ST_H2,
+  AVR32_OPC_ST_H5,
+  AVR32_OPC_ST_H3,
+  AVR32_OPC_ST_H4,
+  AVR32_OPC_ST_W1,
+  AVR32_OPC_ST_W2,
+  AVR32_OPC_ST_W5,
+  AVR32_OPC_ST_W3,
+  AVR32_OPC_ST_W4,
+  AVR32_OPC_STC_D1,
+  AVR32_OPC_STC_D2,
+  AVR32_OPC_STC_D3,
+  AVR32_OPC_STC_W1,
+  AVR32_OPC_STC_W2,
+  AVR32_OPC_STC_W3,
+  AVR32_OPC_STC0_D,
+  AVR32_OPC_STC0_W,
+  AVR32_OPC_STCM_D,
+  AVR32_OPC_STCM_D_PU,
+  AVR32_OPC_STCM_W,
+  AVR32_OPC_STCM_W_PU,
+  AVR32_OPC_STCOND,
+  AVR32_OPC_STDSP,
+  AVR32_OPC_STHH_W2,
+  AVR32_OPC_STHH_W1,
+  AVR32_OPC_STM,
+  AVR32_OPC_STM_PU,
+  AVR32_OPC_STMTS,
+  AVR32_OPC_STMTS_PU,
+  AVR32_OPC_STSWP_H,
+  AVR32_OPC_STSWP_W,
+  AVR32_OPC_SUB1,
+  AVR32_OPC_SUB2,
+  AVR32_OPC_SUB5,
+  AVR32_OPC_SUB3_SP,
+  AVR32_OPC_SUB3,
+  AVR32_OPC_SUB4,
+  AVR32_OPC_SUBEQ,
+  AVR32_OPC_SUBNE,
+  AVR32_OPC_SUBCC,
+  AVR32_OPC_SUBCS,
+  AVR32_OPC_SUBGE,
+  AVR32_OPC_SUBLT,
+  AVR32_OPC_SUBMI,
+  AVR32_OPC_SUBPL,
+  AVR32_OPC_SUBLS,
+  AVR32_OPC_SUBGT,
+  AVR32_OPC_SUBLE,
+  AVR32_OPC_SUBHI,
+  AVR32_OPC_SUBVS,
+  AVR32_OPC_SUBVC,
+  AVR32_OPC_SUBQS,
+  AVR32_OPC_SUBAL,
+  AVR32_OPC_SUBFEQ,
+  AVR32_OPC_SUBFNE,
+  AVR32_OPC_SUBFCC,
+  AVR32_OPC_SUBFCS,
+  AVR32_OPC_SUBFGE,
+  AVR32_OPC_SUBFLT,
+  AVR32_OPC_SUBFMI,
+  AVR32_OPC_SUBFPL,
+  AVR32_OPC_SUBFLS,
+  AVR32_OPC_SUBFGT,
+  AVR32_OPC_SUBFLE,
+  AVR32_OPC_SUBFHI,
+  AVR32_OPC_SUBFVS,
+  AVR32_OPC_SUBFVC,
+  AVR32_OPC_SUBFQS,
+  AVR32_OPC_SUBFAL,
+  AVR32_OPC_SUBHH_W,
+  AVR32_OPC_SWAP_B,
+  AVR32_OPC_SWAP_BH,
+  AVR32_OPC_SWAP_H,
+  AVR32_OPC_SYNC,
+  AVR32_OPC_TLBR,
+  AVR32_OPC_TLBS,
+  AVR32_OPC_TLBW,
+  AVR32_OPC_TNBZ,
+  AVR32_OPC_TST,
+  AVR32_OPC_XCHG,
+  AVR32_OPC_MEMC,
+  AVR32_OPC_MEMS,
+  AVR32_OPC_MEMT,
+  AVR32_OPC_BFEXTS,
+  AVR32_OPC_BFEXTU,
+  AVR32_OPC_BFINS,
+  AVR32_OPC_RSUBEQ,
+  AVR32_OPC_RSUBNE,
+  AVR32_OPC_RSUBCC,
+  AVR32_OPC_RSUBCS,
+  AVR32_OPC_RSUBGE,
+  AVR32_OPC_RSUBLT,
+  AVR32_OPC_RSUBMI,
+  AVR32_OPC_RSUBPL,
+  AVR32_OPC_RSUBLS,
+  AVR32_OPC_RSUBGT,
+  AVR32_OPC_RSUBLE,
+  AVR32_OPC_RSUBHI,
+  AVR32_OPC_RSUBVS,
+  AVR32_OPC_RSUBVC,
+  AVR32_OPC_RSUBQS,
+  AVR32_OPC_RSUBAL,
+  AVR32_OPC_ADDEQ,
+  AVR32_OPC_ADDNE,
+  AVR32_OPC_ADDCC,
+  AVR32_OPC_ADDCS,
+  AVR32_OPC_ADDGE,
+  AVR32_OPC_ADDLT,
+  AVR32_OPC_ADDMI,
+  AVR32_OPC_ADDPL,
+  AVR32_OPC_ADDLS,
+  AVR32_OPC_ADDGT,
+  AVR32_OPC_ADDLE,
+  AVR32_OPC_ADDHI,
+  AVR32_OPC_ADDVS,
+  AVR32_OPC_ADDVC,
+  AVR32_OPC_ADDQS,
+  AVR32_OPC_ADDAL,
+  AVR32_OPC_SUB2EQ,
+  AVR32_OPC_SUB2NE,
+  AVR32_OPC_SUB2CC,
+  AVR32_OPC_SUB2CS,
+  AVR32_OPC_SUB2GE,
+  AVR32_OPC_SUB2LT,
+  AVR32_OPC_SUB2MI,
+  AVR32_OPC_SUB2PL,
+  AVR32_OPC_SUB2LS,
+  AVR32_OPC_SUB2GT,
+  AVR32_OPC_SUB2LE,
+  AVR32_OPC_SUB2HI,
+  AVR32_OPC_SUB2VS,
+  AVR32_OPC_SUB2VC,
+  AVR32_OPC_SUB2QS,
+  AVR32_OPC_SUB2AL,
+  AVR32_OPC_ANDEQ,
+  AVR32_OPC_ANDNE,
+  AVR32_OPC_ANDCC,
+  AVR32_OPC_ANDCS,
+  AVR32_OPC_ANDGE,
+  AVR32_OPC_ANDLT,
+  AVR32_OPC_ANDMI,
+  AVR32_OPC_ANDPL,
+  AVR32_OPC_ANDLS,
+  AVR32_OPC_ANDGT,
+  AVR32_OPC_ANDLE,
+  AVR32_OPC_ANDHI,
+  AVR32_OPC_ANDVS,
+  AVR32_OPC_ANDVC,
+  AVR32_OPC_ANDQS,
+  AVR32_OPC_ANDAL,
+  AVR32_OPC_OREQ,
+  AVR32_OPC_ORNE,
+  AVR32_OPC_ORCC,
+  AVR32_OPC_ORCS,
+  AVR32_OPC_ORGE,
+  AVR32_OPC_ORLT,
+  AVR32_OPC_ORMI,
+  AVR32_OPC_ORPL,
+  AVR32_OPC_ORLS,
+  AVR32_OPC_ORGT,
+  AVR32_OPC_ORLE,
+  AVR32_OPC_ORHI,
+  AVR32_OPC_ORVS,
+  AVR32_OPC_ORVC,
+  AVR32_OPC_ORQS,
+  AVR32_OPC_ORAL,
+  AVR32_OPC_EOREQ,
+  AVR32_OPC_EORNE,
+  AVR32_OPC_EORCC,
+  AVR32_OPC_EORCS,
+  AVR32_OPC_EORGE,
+  AVR32_OPC_EORLT,
+  AVR32_OPC_EORMI,
+  AVR32_OPC_EORPL,
+  AVR32_OPC_EORLS,
+  AVR32_OPC_EORGT,
+  AVR32_OPC_EORLE,
+  AVR32_OPC_EORHI,
+  AVR32_OPC_EORVS,
+  AVR32_OPC_EORVC,
+  AVR32_OPC_EORQS,
+  AVR32_OPC_EORAL,
+  AVR32_OPC_LD_WEQ,
+  AVR32_OPC_LD_WNE,
+  AVR32_OPC_LD_WCC,
+  AVR32_OPC_LD_WCS,
+  AVR32_OPC_LD_WGE,
+  AVR32_OPC_LD_WLT,
+  AVR32_OPC_LD_WMI,
+  AVR32_OPC_LD_WPL,
+  AVR32_OPC_LD_WLS,
+  AVR32_OPC_LD_WGT,
+  AVR32_OPC_LD_WLE,
+  AVR32_OPC_LD_WHI,
+  AVR32_OPC_LD_WVS,
+  AVR32_OPC_LD_WVC,
+  AVR32_OPC_LD_WQS,
+  AVR32_OPC_LD_WAL,
+  AVR32_OPC_LD_SHEQ,
+  AVR32_OPC_LD_SHNE,
+  AVR32_OPC_LD_SHCC,
+  AVR32_OPC_LD_SHCS,
+  AVR32_OPC_LD_SHGE,
+  AVR32_OPC_LD_SHLT,
+  AVR32_OPC_LD_SHMI,
+  AVR32_OPC_LD_SHPL,
+  AVR32_OPC_LD_SHLS,
+  AVR32_OPC_LD_SHGT,
+  AVR32_OPC_LD_SHLE,
+  AVR32_OPC_LD_SHHI,
+  AVR32_OPC_LD_SHVS,
+  AVR32_OPC_LD_SHVC,
+  AVR32_OPC_LD_SHQS,
+  AVR32_OPC_LD_SHAL,
+  AVR32_OPC_LD_UHEQ,
+  AVR32_OPC_LD_UHNE,
+  AVR32_OPC_LD_UHCC,
+  AVR32_OPC_LD_UHCS,
+  AVR32_OPC_LD_UHGE,
+  AVR32_OPC_LD_UHLT,
+  AVR32_OPC_LD_UHMI,
+  AVR32_OPC_LD_UHPL,
+  AVR32_OPC_LD_UHLS,
+  AVR32_OPC_LD_UHGT,
+  AVR32_OPC_LD_UHLE,
+  AVR32_OPC_LD_UHHI,
+  AVR32_OPC_LD_UHVS,
+  AVR32_OPC_LD_UHVC,
+  AVR32_OPC_LD_UHQS,
+  AVR32_OPC_LD_UHAL,
+  AVR32_OPC_LD_SBEQ,
+  AVR32_OPC_LD_SBNE,
+  AVR32_OPC_LD_SBCC,
+  AVR32_OPC_LD_SBCS,
+  AVR32_OPC_LD_SBGE,
+  AVR32_OPC_LD_SBLT,
+  AVR32_OPC_LD_SBMI,
+  AVR32_OPC_LD_SBPL,
+  AVR32_OPC_LD_SBLS,
+  AVR32_OPC_LD_SBGT,
+  AVR32_OPC_LD_SBLE,
+  AVR32_OPC_LD_SBHI,
+  AVR32_OPC_LD_SBVS,
+  AVR32_OPC_LD_SBVC,
+  AVR32_OPC_LD_SBQS,
+  AVR32_OPC_LD_SBAL,
+  AVR32_OPC_LD_UBEQ,
+  AVR32_OPC_LD_UBNE,
+  AVR32_OPC_LD_UBCC,
+  AVR32_OPC_LD_UBCS,
+  AVR32_OPC_LD_UBGE,
+  AVR32_OPC_LD_UBLT,
+  AVR32_OPC_LD_UBMI,
+  AVR32_OPC_LD_UBPL,
+  AVR32_OPC_LD_UBLS,
+  AVR32_OPC_LD_UBGT,
+  AVR32_OPC_LD_UBLE,
+  AVR32_OPC_LD_UBHI,
+  AVR32_OPC_LD_UBVS,
+  AVR32_OPC_LD_UBVC,
+  AVR32_OPC_LD_UBQS,
+  AVR32_OPC_LD_UBAL,
+  AVR32_OPC_ST_WEQ,
+  AVR32_OPC_ST_WNE,
+  AVR32_OPC_ST_WCC,
+  AVR32_OPC_ST_WCS,
+  AVR32_OPC_ST_WGE,
+  AVR32_OPC_ST_WLT,
+  AVR32_OPC_ST_WMI,
+  AVR32_OPC_ST_WPL,
+  AVR32_OPC_ST_WLS,
+  AVR32_OPC_ST_WGT,
+  AVR32_OPC_ST_WLE,
+  AVR32_OPC_ST_WHI,
+  AVR32_OPC_ST_WVS,
+  AVR32_OPC_ST_WVC,
+  AVR32_OPC_ST_WQS,
+  AVR32_OPC_ST_WAL,
+  AVR32_OPC_ST_HEQ,
+  AVR32_OPC_ST_HNE,
+  AVR32_OPC_ST_HCC,
+  AVR32_OPC_ST_HCS,
+  AVR32_OPC_ST_HGE,
+  AVR32_OPC_ST_HLT,
+  AVR32_OPC_ST_HMI,
+  AVR32_OPC_ST_HPL,
+  AVR32_OPC_ST_HLS,
+  AVR32_OPC_ST_HGT,
+  AVR32_OPC_ST_HLE,
+  AVR32_OPC_ST_HHI,
+  AVR32_OPC_ST_HVS,
+  AVR32_OPC_ST_HVC,
+  AVR32_OPC_ST_HQS,
+  AVR32_OPC_ST_HAL,
+  AVR32_OPC_ST_BEQ,
+  AVR32_OPC_ST_BNE,
+  AVR32_OPC_ST_BCC,
+  AVR32_OPC_ST_BCS,
+  AVR32_OPC_ST_BGE,
+  AVR32_OPC_ST_BLT,
+  AVR32_OPC_ST_BMI,
+  AVR32_OPC_ST_BPL,
+  AVR32_OPC_ST_BLS,
+  AVR32_OPC_ST_BGT,
+  AVR32_OPC_ST_BLE,
+  AVR32_OPC_ST_BHI,
+  AVR32_OPC_ST_BVS,
+  AVR32_OPC_ST_BVC,
+  AVR32_OPC_ST_BQS,
+  AVR32_OPC_ST_BAL,
+  AVR32_OPC_MOVH,
+
+  AVR32_OPC__END_
+};
+#define AVR32_NR_OPCODES AVR32_OPC__END_
+
+enum avr32_syntax_type
+{
+  AVR32_SYNTAX_ABS,
+  AVR32_SYNTAX_ACALL,
+  AVR32_SYNTAX_ACR,
+  AVR32_SYNTAX_ADC,
+  AVR32_SYNTAX_ADD1,
+  AVR32_SYNTAX_ADD2,
+  AVR32_SYNTAX_ADDABS,
+  AVR32_SYNTAX_ADDHH_W,
+  AVR32_SYNTAX_AND1,
+  AVR32_SYNTAX_AND2,
+  AVR32_SYNTAX_AND3,
+  AVR32_SYNTAX_ANDH,
+  AVR32_SYNTAX_ANDH_COH,
+  AVR32_SYNTAX_ANDL,
+  AVR32_SYNTAX_ANDL_COH,
+  AVR32_SYNTAX_ANDN,
+  AVR32_SYNTAX_ASR1,
+  AVR32_SYNTAX_ASR3,
+  AVR32_SYNTAX_ASR2,
+  AVR32_SYNTAX_BFEXTS,
+  AVR32_SYNTAX_BFEXTU,
+  AVR32_SYNTAX_BFINS,
+  AVR32_SYNTAX_BLD,
+  AVR32_SYNTAX_BREQ1,
+  AVR32_SYNTAX_BRNE1,
+  AVR32_SYNTAX_BRCC1,
+  AVR32_SYNTAX_BRCS1,
+  AVR32_SYNTAX_BRGE1,
+  AVR32_SYNTAX_BRLT1,
+  AVR32_SYNTAX_BRMI1,
+  AVR32_SYNTAX_BRPL1,
+  AVR32_SYNTAX_BRHS1,
+  AVR32_SYNTAX_BRLO1,
+  AVR32_SYNTAX_BREQ2,
+  AVR32_SYNTAX_BRNE2,
+  AVR32_SYNTAX_BRCC2,
+  AVR32_SYNTAX_BRCS2,
+  AVR32_SYNTAX_BRGE2,
+  AVR32_SYNTAX_BRLT2,
+  AVR32_SYNTAX_BRMI2,
+  AVR32_SYNTAX_BRPL2,
+  AVR32_SYNTAX_BRLS,
+  AVR32_SYNTAX_BRGT,
+  AVR32_SYNTAX_BRLE,
+  AVR32_SYNTAX_BRHI,
+  AVR32_SYNTAX_BRVS,
+  AVR32_SYNTAX_BRVC,
+  AVR32_SYNTAX_BRQS,
+  AVR32_SYNTAX_BRAL,
+  AVR32_SYNTAX_BRHS2,
+  AVR32_SYNTAX_BRLO2,
+  AVR32_SYNTAX_BREAKPOINT,
+  AVR32_SYNTAX_BREV,
+  AVR32_SYNTAX_BST,
+  AVR32_SYNTAX_CACHE,
+  AVR32_SYNTAX_CASTS_B,
+  AVR32_SYNTAX_CASTS_H,
+  AVR32_SYNTAX_CASTU_B,
+  AVR32_SYNTAX_CASTU_H,
+  AVR32_SYNTAX_CBR,
+  AVR32_SYNTAX_CLZ,
+  AVR32_SYNTAX_COM,
+  AVR32_SYNTAX_COP,
+  AVR32_SYNTAX_CP_B,
+  AVR32_SYNTAX_CP_H,
+  AVR32_SYNTAX_CP_W1,
+  AVR32_SYNTAX_CP_W2,
+  AVR32_SYNTAX_CP_W3,
+  AVR32_SYNTAX_CPC1,
+  AVR32_SYNTAX_CPC2,
+  AVR32_SYNTAX_CSRF,
+  AVR32_SYNTAX_CSRFCZ,
+  AVR32_SYNTAX_DIVS,
+  AVR32_SYNTAX_DIVU,
+  AVR32_SYNTAX_EOR1,
+  AVR32_SYNTAX_EOR2,
+  AVR32_SYNTAX_EOR3,
+  AVR32_SYNTAX_EORL,
+  AVR32_SYNTAX_EORH,
+  AVR32_SYNTAX_FRS,
+  AVR32_SYNTAX_ICALL,
+  AVR32_SYNTAX_INCJOSP,
+  AVR32_SYNTAX_LD_D1,
+  AVR32_SYNTAX_LD_D2,
+  AVR32_SYNTAX_LD_D3,
+  AVR32_SYNTAX_LD_D5,
+  AVR32_SYNTAX_LD_D4,
+  AVR32_SYNTAX_LD_SB2,
+  AVR32_SYNTAX_LD_SB1,
+  AVR32_SYNTAX_LD_UB1,
+  AVR32_SYNTAX_LD_UB2,
+  AVR32_SYNTAX_LD_UB5,
+  AVR32_SYNTAX_LD_UB3,
+  AVR32_SYNTAX_LD_UB4,
+  AVR32_SYNTAX_LD_SH1,
+  AVR32_SYNTAX_LD_SH2,
+  AVR32_SYNTAX_LD_SH5,
+  AVR32_SYNTAX_LD_SH3,
+  AVR32_SYNTAX_LD_SH4,
+  AVR32_SYNTAX_LD_UH1,
+  AVR32_SYNTAX_LD_UH2,
+  AVR32_SYNTAX_LD_UH5,
+  AVR32_SYNTAX_LD_UH3,
+  AVR32_SYNTAX_LD_UH4,
+  AVR32_SYNTAX_LD_W1,
+  AVR32_SYNTAX_LD_W2,
+  AVR32_SYNTAX_LD_W5,
+  AVR32_SYNTAX_LD_W6,
+  AVR32_SYNTAX_LD_W3,
+  AVR32_SYNTAX_LD_W4,
+  AVR32_SYNTAX_LDC_D1,
+  AVR32_SYNTAX_LDC_D2,
+  AVR32_SYNTAX_LDC_D3,
+  AVR32_SYNTAX_LDC_W1,
+  AVR32_SYNTAX_LDC_W2,
+  AVR32_SYNTAX_LDC_W3,
+  AVR32_SYNTAX_LDC0_D,
+  AVR32_SYNTAX_LDC0_W,
+  AVR32_SYNTAX_LDCM_D,
+  AVR32_SYNTAX_LDCM_D_PU,
+  AVR32_SYNTAX_LDCM_W,
+  AVR32_SYNTAX_LDCM_W_PU,
+  AVR32_SYNTAX_LDDPC,
+  AVR32_SYNTAX_LDDPC_EXT,
+  AVR32_SYNTAX_LDDSP,
+  AVR32_SYNTAX_LDINS_B,
+  AVR32_SYNTAX_LDINS_H,
+  AVR32_SYNTAX_LDM,
+  AVR32_SYNTAX_LDMTS,
+  AVR32_SYNTAX_LDMTS_PU,
+  AVR32_SYNTAX_LDSWP_SH,
+  AVR32_SYNTAX_LDSWP_UH,
+  AVR32_SYNTAX_LDSWP_W,
+  AVR32_SYNTAX_LSL1,
+  AVR32_SYNTAX_LSL3,
+  AVR32_SYNTAX_LSL2,
+  AVR32_SYNTAX_LSR1,
+  AVR32_SYNTAX_LSR3,
+  AVR32_SYNTAX_LSR2,
+  AVR32_SYNTAX_MAC,
+  AVR32_SYNTAX_MACHH_D,
+  AVR32_SYNTAX_MACHH_W,
+  AVR32_SYNTAX_MACS_D,
+  AVR32_SYNTAX_MACSATHH_W,
+  AVR32_SYNTAX_MACUD,
+  AVR32_SYNTAX_MACWH_D,
+  AVR32_SYNTAX_MAX,
+  AVR32_SYNTAX_MCALL,
+  AVR32_SYNTAX_MFDR,
+  AVR32_SYNTAX_MFSR,
+  AVR32_SYNTAX_MIN,
+  AVR32_SYNTAX_MOV3,
+  AVR32_SYNTAX_MOV1,
+  AVR32_SYNTAX_MOV2,
+  AVR32_SYNTAX_MOVEQ1,
+  AVR32_SYNTAX_MOVNE1,
+  AVR32_SYNTAX_MOVCC1,
+  AVR32_SYNTAX_MOVCS1,
+  AVR32_SYNTAX_MOVGE1,
+  AVR32_SYNTAX_MOVLT1,
+  AVR32_SYNTAX_MOVMI1,
+  AVR32_SYNTAX_MOVPL1,
+  AVR32_SYNTAX_MOVLS1,
+  AVR32_SYNTAX_MOVGT1,
+  AVR32_SYNTAX_MOVLE1,
+  AVR32_SYNTAX_MOVHI1,
+  AVR32_SYNTAX_MOVVS1,
+  AVR32_SYNTAX_MOVVC1,
+  AVR32_SYNTAX_MOVQS1,
+  AVR32_SYNTAX_MOVAL1,
+  AVR32_SYNTAX_MOVHS1,
+  AVR32_SYNTAX_MOVLO1,
+  AVR32_SYNTAX_MOVEQ2,
+  AVR32_SYNTAX_MOVNE2,
+  AVR32_SYNTAX_MOVCC2,
+  AVR32_SYNTAX_MOVCS2,
+  AVR32_SYNTAX_MOVGE2,
+  AVR32_SYNTAX_MOVLT2,
+  AVR32_SYNTAX_MOVMI2,
+  AVR32_SYNTAX_MOVPL2,
+  AVR32_SYNTAX_MOVLS2,
+  AVR32_SYNTAX_MOVGT2,
+  AVR32_SYNTAX_MOVLE2,
+  AVR32_SYNTAX_MOVHI2,
+  AVR32_SYNTAX_MOVVS2,
+  AVR32_SYNTAX_MOVVC2,
+  AVR32_SYNTAX_MOVQS2,
+  AVR32_SYNTAX_MOVAL2,
+  AVR32_SYNTAX_MOVHS2,
+  AVR32_SYNTAX_MOVLO2,
+  AVR32_SYNTAX_MTDR,
+  AVR32_SYNTAX_MTSR,
+  AVR32_SYNTAX_MUL1,
+  AVR32_SYNTAX_MUL2,
+  AVR32_SYNTAX_MUL3,
+  AVR32_SYNTAX_MULHH_W,
+  AVR32_SYNTAX_MULNHH_W,
+  AVR32_SYNTAX_MULNWH_D,
+  AVR32_SYNTAX_MULSD,
+  AVR32_SYNTAX_MULSATHH_H,
+  AVR32_SYNTAX_MULSATHH_W,
+  AVR32_SYNTAX_MULSATRNDHH_H,
+  AVR32_SYNTAX_MULSATRNDWH_W,
+  AVR32_SYNTAX_MULSATWH_W,
+  AVR32_SYNTAX_MULU_D,
+  AVR32_SYNTAX_MULWH_D,
+  AVR32_SYNTAX_MUSFR,
+  AVR32_SYNTAX_MUSTR,
+  AVR32_SYNTAX_MVCR_D,
+  AVR32_SYNTAX_MVCR_W,
+  AVR32_SYNTAX_MVRC_D,
+  AVR32_SYNTAX_MVRC_W,
+  AVR32_SYNTAX_NEG,
+  AVR32_SYNTAX_NOP,
+  AVR32_SYNTAX_OR1,
+  AVR32_SYNTAX_OR2,
+  AVR32_SYNTAX_OR3,
+  AVR32_SYNTAX_ORH,
+  AVR32_SYNTAX_ORL,
+  AVR32_SYNTAX_PABS_SB,
+  AVR32_SYNTAX_PABS_SH,
+  AVR32_SYNTAX_PACKSH_SB,
+  AVR32_SYNTAX_PACKSH_UB,
+  AVR32_SYNTAX_PACKW_SH,
+  AVR32_SYNTAX_PADD_B,
+  AVR32_SYNTAX_PADD_H,
+  AVR32_SYNTAX_PADDH_SH,
+  AVR32_SYNTAX_PADDH_UB,
+  AVR32_SYNTAX_PADDS_SB,
+  AVR32_SYNTAX_PADDS_SH,
+  AVR32_SYNTAX_PADDS_UB,
+  AVR32_SYNTAX_PADDS_UH,
+  AVR32_SYNTAX_PADDSUB_H,
+  AVR32_SYNTAX_PADDSUBH_SH,
+  AVR32_SYNTAX_PADDSUBS_SH,
+  AVR32_SYNTAX_PADDSUBS_UH,
+  AVR32_SYNTAX_PADDX_H,
+  AVR32_SYNTAX_PADDXH_SH,
+  AVR32_SYNTAX_PADDXS_SH,
+  AVR32_SYNTAX_PADDXS_UH,
+  AVR32_SYNTAX_PASR_B,
+  AVR32_SYNTAX_PASR_H,
+  AVR32_SYNTAX_PAVG_SH,
+  AVR32_SYNTAX_PAVG_UB,
+  AVR32_SYNTAX_PLSL_B,
+  AVR32_SYNTAX_PLSL_H,
+  AVR32_SYNTAX_PLSR_B,
+  AVR32_SYNTAX_PLSR_H,
+  AVR32_SYNTAX_PMAX_SH,
+  AVR32_SYNTAX_PMAX_UB,
+  AVR32_SYNTAX_PMIN_SH,
+  AVR32_SYNTAX_PMIN_UB,
+  AVR32_SYNTAX_POPJC,
+  AVR32_SYNTAX_POPM,
+  AVR32_SYNTAX_POPM_E,
+  AVR32_SYNTAX_PREF,
+  AVR32_SYNTAX_PSAD,
+  AVR32_SYNTAX_PSUB_B,
+  AVR32_SYNTAX_PSUB_H,
+  AVR32_SYNTAX_PSUBADD_H,
+  AVR32_SYNTAX_PSUBADDH_SH,
+  AVR32_SYNTAX_PSUBADDS_SH,
+  AVR32_SYNTAX_PSUBADDS_UH,
+  AVR32_SYNTAX_PSUBH_SH,
+  AVR32_SYNTAX_PSUBH_UB,
+  AVR32_SYNTAX_PSUBS_SB,
+  AVR32_SYNTAX_PSUBS_SH,
+  AVR32_SYNTAX_PSUBS_UB,
+  AVR32_SYNTAX_PSUBS_UH,
+  AVR32_SYNTAX_PSUBX_H,
+  AVR32_SYNTAX_PSUBXH_SH,
+  AVR32_SYNTAX_PSUBXS_SH,
+  AVR32_SYNTAX_PSUBXS_UH,
+  AVR32_SYNTAX_PUNPCKSB_H,
+  AVR32_SYNTAX_PUNPCKUB_H,
+  AVR32_SYNTAX_PUSHJC,
+  AVR32_SYNTAX_PUSHM,
+  AVR32_SYNTAX_PUSHM_E,
+  AVR32_SYNTAX_RCALL1,
+  AVR32_SYNTAX_RCALL2,
+  AVR32_SYNTAX_RETEQ,
+  AVR32_SYNTAX_RETNE,
+  AVR32_SYNTAX_RETCC,
+  AVR32_SYNTAX_RETCS,
+  AVR32_SYNTAX_RETGE,
+  AVR32_SYNTAX_RETLT,
+  AVR32_SYNTAX_RETMI,
+  AVR32_SYNTAX_RETPL,
+  AVR32_SYNTAX_RETLS,
+  AVR32_SYNTAX_RETGT,
+  AVR32_SYNTAX_RETLE,
+  AVR32_SYNTAX_RETHI,
+  AVR32_SYNTAX_RETVS,
+  AVR32_SYNTAX_RETVC,
+  AVR32_SYNTAX_RETQS,
+  AVR32_SYNTAX_RETAL,
+  AVR32_SYNTAX_RETHS,
+  AVR32_SYNTAX_RETLO,
+  AVR32_SYNTAX_RETD,
+  AVR32_SYNTAX_RETE,
+  AVR32_SYNTAX_RETJ,
+  AVR32_SYNTAX_RETS,
+  AVR32_SYNTAX_RJMP,
+  AVR32_SYNTAX_ROL,
+  AVR32_SYNTAX_ROR,
+  AVR32_SYNTAX_RSUB1,
+  AVR32_SYNTAX_RSUB2,
+  AVR32_SYNTAX_SATADD_H,
+  AVR32_SYNTAX_SATADD_W,
+  AVR32_SYNTAX_SATRNDS,
+  AVR32_SYNTAX_SATRNDU,
+  AVR32_SYNTAX_SATS,
+  AVR32_SYNTAX_SATSUB_H,
+  AVR32_SYNTAX_SATSUB_W1,
+  AVR32_SYNTAX_SATSUB_W2,
+  AVR32_SYNTAX_SATU,
+  AVR32_SYNTAX_SBC,
+  AVR32_SYNTAX_SBR,
+  AVR32_SYNTAX_SCALL,
+  AVR32_SYNTAX_SCR,
+  AVR32_SYNTAX_SLEEP,
+  AVR32_SYNTAX_SREQ,
+  AVR32_SYNTAX_SRNE,
+  AVR32_SYNTAX_SRCC,
+  AVR32_SYNTAX_SRCS,
+  AVR32_SYNTAX_SRGE,
+  AVR32_SYNTAX_SRLT,
+  AVR32_SYNTAX_SRMI,
+  AVR32_SYNTAX_SRPL,
+  AVR32_SYNTAX_SRLS,
+  AVR32_SYNTAX_SRGT,
+  AVR32_SYNTAX_SRLE,
+  AVR32_SYNTAX_SRHI,
+  AVR32_SYNTAX_SRVS,
+  AVR32_SYNTAX_SRVC,
+  AVR32_SYNTAX_SRQS,
+  AVR32_SYNTAX_SRAL,
+  AVR32_SYNTAX_SRHS,
+  AVR32_SYNTAX_SRLO,
+  AVR32_SYNTAX_SSRF,
+  AVR32_SYNTAX_ST_B1,
+  AVR32_SYNTAX_ST_B2,
+  AVR32_SYNTAX_ST_B5,
+  AVR32_SYNTAX_ST_B3,
+  AVR32_SYNTAX_ST_B4,
+  AVR32_SYNTAX_ST_D1,
+  AVR32_SYNTAX_ST_D2,
+  AVR32_SYNTAX_ST_D3,
+  AVR32_SYNTAX_ST_D5,
+  AVR32_SYNTAX_ST_D4,
+  AVR32_SYNTAX_ST_H1,
+  AVR32_SYNTAX_ST_H2,
+  AVR32_SYNTAX_ST_H5,
+  AVR32_SYNTAX_ST_H3,
+  AVR32_SYNTAX_ST_H4,
+  AVR32_SYNTAX_ST_W1,
+  AVR32_SYNTAX_ST_W2,
+  AVR32_SYNTAX_ST_W5,
+  AVR32_SYNTAX_ST_W3,
+  AVR32_SYNTAX_ST_W4,
+  AVR32_SYNTAX_STC_D1,
+  AVR32_SYNTAX_STC_D2,
+  AVR32_SYNTAX_STC_D3,
+  AVR32_SYNTAX_STC_W1,
+  AVR32_SYNTAX_STC_W2,
+  AVR32_SYNTAX_STC_W3,
+  AVR32_SYNTAX_STC0_D,
+  AVR32_SYNTAX_STC0_W,
+  AVR32_SYNTAX_STCM_D,
+  AVR32_SYNTAX_STCM_D_PU,
+  AVR32_SYNTAX_STCM_W,
+  AVR32_SYNTAX_STCM_W_PU,
+  AVR32_SYNTAX_STCOND,
+  AVR32_SYNTAX_STDSP,
+  AVR32_SYNTAX_STHH_W2,
+  AVR32_SYNTAX_STHH_W1,
+  AVR32_SYNTAX_STM,
+  AVR32_SYNTAX_STM_PU,
+  AVR32_SYNTAX_STMTS,
+  AVR32_SYNTAX_STMTS_PU,
+  AVR32_SYNTAX_STSWP_H,
+  AVR32_SYNTAX_STSWP_W,
+  AVR32_SYNTAX_SUB1,
+  AVR32_SYNTAX_SUB2,
+  AVR32_SYNTAX_SUB5,
+  AVR32_SYNTAX_SUB3_SP,
+  AVR32_SYNTAX_SUB3,
+  AVR32_SYNTAX_SUB4,
+  AVR32_SYNTAX_SUBEQ,
+  AVR32_SYNTAX_SUBNE,
+  AVR32_SYNTAX_SUBCC,
+  AVR32_SYNTAX_SUBCS,
+  AVR32_SYNTAX_SUBGE,
+  AVR32_SYNTAX_SUBLT,
+  AVR32_SYNTAX_SUBMI,
+  AVR32_SYNTAX_SUBPL,
+  AVR32_SYNTAX_SUBLS,
+  AVR32_SYNTAX_SUBGT,
+  AVR32_SYNTAX_SUBLE,
+  AVR32_SYNTAX_SUBHI,
+  AVR32_SYNTAX_SUBVS,
+  AVR32_SYNTAX_SUBVC,
+  AVR32_SYNTAX_SUBQS,
+  AVR32_SYNTAX_SUBAL,
+  AVR32_SYNTAX_SUBHS,
+  AVR32_SYNTAX_SUBLO,
+  AVR32_SYNTAX_SUBFEQ,
+  AVR32_SYNTAX_SUBFNE,
+  AVR32_SYNTAX_SUBFCC,
+  AVR32_SYNTAX_SUBFCS,
+  AVR32_SYNTAX_SUBFGE,
+  AVR32_SYNTAX_SUBFLT,
+  AVR32_SYNTAX_SUBFMI,
+  AVR32_SYNTAX_SUBFPL,
+  AVR32_SYNTAX_SUBFLS,
+  AVR32_SYNTAX_SUBFGT,
+  AVR32_SYNTAX_SUBFLE,
+  AVR32_SYNTAX_SUBFHI,
+  AVR32_SYNTAX_SUBFVS,
+  AVR32_SYNTAX_SUBFVC,
+  AVR32_SYNTAX_SUBFQS,
+  AVR32_SYNTAX_SUBFAL,
+  AVR32_SYNTAX_SUBFHS,
+  AVR32_SYNTAX_SUBFLO,
+  AVR32_SYNTAX_SUBHH_W,
+  AVR32_SYNTAX_SWAP_B,
+  AVR32_SYNTAX_SWAP_BH,
+  AVR32_SYNTAX_SWAP_H,
+  AVR32_SYNTAX_SYNC,
+  AVR32_SYNTAX_TLBR,
+  AVR32_SYNTAX_TLBS,
+  AVR32_SYNTAX_TLBW,
+  AVR32_SYNTAX_TNBZ,
+  AVR32_SYNTAX_TST,
+  AVR32_SYNTAX_XCHG,
+  AVR32_SYNTAX_MEMC,
+  AVR32_SYNTAX_MEMS,
+  AVR32_SYNTAX_MEMT,
+  AVR32_SYNTAX_FADD_S,
+  AVR32_SYNTAX_FADD_D,
+  AVR32_SYNTAX_FSUB_S,
+  AVR32_SYNTAX_FSUB_D,
+  AVR32_SYNTAX_FMAC_S,
+  AVR32_SYNTAX_FMAC_D,
+  AVR32_SYNTAX_FNMAC_S,
+  AVR32_SYNTAX_FNMAC_D,
+  AVR32_SYNTAX_FMSC_S,
+  AVR32_SYNTAX_FMSC_D,
+  AVR32_SYNTAX_FNMSC_S,
+  AVR32_SYNTAX_FNMSC_D,
+  AVR32_SYNTAX_FMUL_S,
+  AVR32_SYNTAX_FMUL_D,
+  AVR32_SYNTAX_FNMUL_S,
+  AVR32_SYNTAX_FNMUL_D,
+  AVR32_SYNTAX_FNEG_S,
+  AVR32_SYNTAX_FNEG_D,
+  AVR32_SYNTAX_FABS_S,
+  AVR32_SYNTAX_FABS_D,
+  AVR32_SYNTAX_FCMP_S,
+  AVR32_SYNTAX_FCMP_D,
+  AVR32_SYNTAX_FMOV1_S,
+  AVR32_SYNTAX_FMOV1_D,
+  AVR32_SYNTAX_FMOV2_S,
+  AVR32_SYNTAX_FMOV2_D,
+  AVR32_SYNTAX_FMOV3_S,
+  AVR32_SYNTAX_FMOV3_D,
+  AVR32_SYNTAX_FCASTS_D,
+  AVR32_SYNTAX_FCASTD_S,
+  AVR32_SYNTAX_LDA_W,
+  AVR32_SYNTAX_CALL,
+  AVR32_SYNTAX_PICOSVMAC0,
+  AVR32_SYNTAX_PICOSVMAC1,
+  AVR32_SYNTAX_PICOSVMAC2,
+  AVR32_SYNTAX_PICOSVMAC3,
+  AVR32_SYNTAX_PICOSVMUL0,
+  AVR32_SYNTAX_PICOSVMUL1,
+  AVR32_SYNTAX_PICOSVMUL2,
+  AVR32_SYNTAX_PICOSVMUL3,
+  AVR32_SYNTAX_PICOVMAC0,
+  AVR32_SYNTAX_PICOVMAC1,
+  AVR32_SYNTAX_PICOVMAC2,
+  AVR32_SYNTAX_PICOVMAC3,
+  AVR32_SYNTAX_PICOVMUL0,
+  AVR32_SYNTAX_PICOVMUL1,
+  AVR32_SYNTAX_PICOVMUL2,
+  AVR32_SYNTAX_PICOVMUL3,
+  AVR32_SYNTAX_PICOLD_D2,
+  AVR32_SYNTAX_PICOLD_D3,
+  AVR32_SYNTAX_PICOLD_D1,
+  AVR32_SYNTAX_PICOLD_W2,
+  AVR32_SYNTAX_PICOLD_W3,
+  AVR32_SYNTAX_PICOLD_W1,
+  AVR32_SYNTAX_PICOLDM_D,
+  AVR32_SYNTAX_PICOLDM_D_PU,
+  AVR32_SYNTAX_PICOLDM_W,
+  AVR32_SYNTAX_PICOLDM_W_PU,
+  AVR32_SYNTAX_PICOMV_D1,
+  AVR32_SYNTAX_PICOMV_D2,
+  AVR32_SYNTAX_PICOMV_W1,
+  AVR32_SYNTAX_PICOMV_W2,
+  AVR32_SYNTAX_PICOST_D2,
+  AVR32_SYNTAX_PICOST_D3,
+  AVR32_SYNTAX_PICOST_D1,
+  AVR32_SYNTAX_PICOST_W2,
+  AVR32_SYNTAX_PICOST_W3,
+  AVR32_SYNTAX_PICOST_W1,
+  AVR32_SYNTAX_PICOSTM_D,
+  AVR32_SYNTAX_PICOSTM_D_PU,
+  AVR32_SYNTAX_PICOSTM_W,
+  AVR32_SYNTAX_PICOSTM_W_PU,
+  AVR32_SYNTAX_RSUBEQ,
+  AVR32_SYNTAX_RSUBNE,
+  AVR32_SYNTAX_RSUBCC,
+  AVR32_SYNTAX_RSUBCS,
+  AVR32_SYNTAX_RSUBGE,
+  AVR32_SYNTAX_RSUBLT,
+  AVR32_SYNTAX_RSUBMI,
+  AVR32_SYNTAX_RSUBPL,
+  AVR32_SYNTAX_RSUBLS,
+  AVR32_SYNTAX_RSUBGT,
+  AVR32_SYNTAX_RSUBLE,
+  AVR32_SYNTAX_RSUBHI,
+  AVR32_SYNTAX_RSUBVS,
+  AVR32_SYNTAX_RSUBVC,
+  AVR32_SYNTAX_RSUBQS,
+  AVR32_SYNTAX_RSUBAL,
+  AVR32_SYNTAX_RSUBHS,
+  AVR32_SYNTAX_RSUBLO,
+  AVR32_SYNTAX_ADDEQ,
+  AVR32_SYNTAX_ADDNE,
+  AVR32_SYNTAX_ADDCC,
+  AVR32_SYNTAX_ADDCS,
+  AVR32_SYNTAX_ADDGE,
+  AVR32_SYNTAX_ADDLT,
+  AVR32_SYNTAX_ADDMI,
+  AVR32_SYNTAX_ADDPL,
+  AVR32_SYNTAX_ADDLS,
+  AVR32_SYNTAX_ADDGT,
+  AVR32_SYNTAX_ADDLE,
+  AVR32_SYNTAX_ADDHI,
+  AVR32_SYNTAX_ADDVS,
+  AVR32_SYNTAX_ADDVC,
+  AVR32_SYNTAX_ADDQS,
+  AVR32_SYNTAX_ADDAL,
+  AVR32_SYNTAX_ADDHS,
+  AVR32_SYNTAX_ADDLO,
+  AVR32_SYNTAX_SUB2EQ,
+  AVR32_SYNTAX_SUB2NE,
+  AVR32_SYNTAX_SUB2CC,
+  AVR32_SYNTAX_SUB2CS,
+  AVR32_SYNTAX_SUB2GE,
+  AVR32_SYNTAX_SUB2LT,
+  AVR32_SYNTAX_SUB2MI,
+  AVR32_SYNTAX_SUB2PL,
+  AVR32_SYNTAX_SUB2LS,
+  AVR32_SYNTAX_SUB2GT,
+  AVR32_SYNTAX_SUB2LE,
+  AVR32_SYNTAX_SUB2HI,
+  AVR32_SYNTAX_SUB2VS,
+  AVR32_SYNTAX_SUB2VC,
+  AVR32_SYNTAX_SUB2QS,
+  AVR32_SYNTAX_SUB2AL,
+  AVR32_SYNTAX_SUB2HS,
+  AVR32_SYNTAX_SUB2LO,
+  AVR32_SYNTAX_ANDEQ,
+  AVR32_SYNTAX_ANDNE,
+  AVR32_SYNTAX_ANDCC,
+  AVR32_SYNTAX_ANDCS,
+  AVR32_SYNTAX_ANDGE,
+  AVR32_SYNTAX_ANDLT,
+  AVR32_SYNTAX_ANDMI,
+  AVR32_SYNTAX_ANDPL,
+  AVR32_SYNTAX_ANDLS,
+  AVR32_SYNTAX_ANDGT,
+  AVR32_SYNTAX_ANDLE,
+  AVR32_SYNTAX_ANDHI,
+  AVR32_SYNTAX_ANDVS,
+  AVR32_SYNTAX_ANDVC,
+  AVR32_SYNTAX_ANDQS,
+  AVR32_SYNTAX_ANDAL,
+  AVR32_SYNTAX_ANDHS,
+  AVR32_SYNTAX_ANDLO,
+  AVR32_SYNTAX_OREQ,
+  AVR32_SYNTAX_ORNE,
+  AVR32_SYNTAX_ORCC,
+  AVR32_SYNTAX_ORCS,
+  AVR32_SYNTAX_ORGE,
+  AVR32_SYNTAX_ORLT,
+  AVR32_SYNTAX_ORMI,
+  AVR32_SYNTAX_ORPL,
+  AVR32_SYNTAX_ORLS,
+  AVR32_SYNTAX_ORGT,
+  AVR32_SYNTAX_ORLE,
+  AVR32_SYNTAX_ORHI,
+  AVR32_SYNTAX_ORVS,
+  AVR32_SYNTAX_ORVC,
+  AVR32_SYNTAX_ORQS,
+  AVR32_SYNTAX_ORAL,
+  AVR32_SYNTAX_ORHS,
+  AVR32_SYNTAX_ORLO,
+  AVR32_SYNTAX_EOREQ,
+  AVR32_SYNTAX_EORNE,
+  AVR32_SYNTAX_EORCC,
+  AVR32_SYNTAX_EORCS,
+  AVR32_SYNTAX_EORGE,
+  AVR32_SYNTAX_EORLT,
+  AVR32_SYNTAX_EORMI,
+  AVR32_SYNTAX_EORPL,
+  AVR32_SYNTAX_EORLS,
+  AVR32_SYNTAX_EORGT,
+  AVR32_SYNTAX_EORLE,
+  AVR32_SYNTAX_EORHI,
+  AVR32_SYNTAX_EORVS,
+  AVR32_SYNTAX_EORVC,
+  AVR32_SYNTAX_EORQS,
+  AVR32_SYNTAX_EORAL,
+  AVR32_SYNTAX_EORHS,
+  AVR32_SYNTAX_EORLO,
+  AVR32_SYNTAX_LD_WEQ,
+  AVR32_SYNTAX_LD_WNE,
+  AVR32_SYNTAX_LD_WCC,
+  AVR32_SYNTAX_LD_WCS,
+  AVR32_SYNTAX_LD_WGE,
+  AVR32_SYNTAX_LD_WLT,
+  AVR32_SYNTAX_LD_WMI,
+  AVR32_SYNTAX_LD_WPL,
+  AVR32_SYNTAX_LD_WLS,
+  AVR32_SYNTAX_LD_WGT,
+  AVR32_SYNTAX_LD_WLE,
+  AVR32_SYNTAX_LD_WHI,
+  AVR32_SYNTAX_LD_WVS,
+  AVR32_SYNTAX_LD_WVC,
+  AVR32_SYNTAX_LD_WQS,
+  AVR32_SYNTAX_LD_WAL,
+  AVR32_SYNTAX_LD_WHS,
+  AVR32_SYNTAX_LD_WLO,
+  AVR32_SYNTAX_LD_SHEQ,
+  AVR32_SYNTAX_LD_SHNE,
+  AVR32_SYNTAX_LD_SHCC,
+  AVR32_SYNTAX_LD_SHCS,
+  AVR32_SYNTAX_LD_SHGE,
+  AVR32_SYNTAX_LD_SHLT,
+  AVR32_SYNTAX_LD_SHMI,
+  AVR32_SYNTAX_LD_SHPL,
+  AVR32_SYNTAX_LD_SHLS,
+  AVR32_SYNTAX_LD_SHGT,
+  AVR32_SYNTAX_LD_SHLE,
+  AVR32_SYNTAX_LD_SHHI,
+  AVR32_SYNTAX_LD_SHVS,
+  AVR32_SYNTAX_LD_SHVC,
+  AVR32_SYNTAX_LD_SHQS,
+  AVR32_SYNTAX_LD_SHAL,
+  AVR32_SYNTAX_LD_SHHS,
+  AVR32_SYNTAX_LD_SHLO,
+  AVR32_SYNTAX_LD_UHEQ,
+  AVR32_SYNTAX_LD_UHNE,
+  AVR32_SYNTAX_LD_UHCC,
+  AVR32_SYNTAX_LD_UHCS,
+  AVR32_SYNTAX_LD_UHGE,
+  AVR32_SYNTAX_LD_UHLT,
+  AVR32_SYNTAX_LD_UHMI,
+  AVR32_SYNTAX_LD_UHPL,
+  AVR32_SYNTAX_LD_UHLS,
+  AVR32_SYNTAX_LD_UHGT,
+  AVR32_SYNTAX_LD_UHLE,
+  AVR32_SYNTAX_LD_UHHI,
+  AVR32_SYNTAX_LD_UHVS,
+  AVR32_SYNTAX_LD_UHVC,
+  AVR32_SYNTAX_LD_UHQS,
+  AVR32_SYNTAX_LD_UHAL,
+  AVR32_SYNTAX_LD_UHHS,
+  AVR32_SYNTAX_LD_UHLO,
+  AVR32_SYNTAX_LD_SBEQ,
+  AVR32_SYNTAX_LD_SBNE,
+  AVR32_SYNTAX_LD_SBCC,
+  AVR32_SYNTAX_LD_SBCS,
+  AVR32_SYNTAX_LD_SBGE,
+  AVR32_SYNTAX_LD_SBLT,
+  AVR32_SYNTAX_LD_SBMI,
+  AVR32_SYNTAX_LD_SBPL,
+  AVR32_SYNTAX_LD_SBLS,
+  AVR32_SYNTAX_LD_SBGT,
+  AVR32_SYNTAX_LD_SBLE,
+  AVR32_SYNTAX_LD_SBHI,
+  AVR32_SYNTAX_LD_SBVS,
+  AVR32_SYNTAX_LD_SBVC,
+  AVR32_SYNTAX_LD_SBQS,
+  AVR32_SYNTAX_LD_SBAL,
+  AVR32_SYNTAX_LD_SBHS,
+  AVR32_SYNTAX_LD_SBLO,
+  AVR32_SYNTAX_LD_UBEQ,
+  AVR32_SYNTAX_LD_UBNE,
+  AVR32_SYNTAX_LD_UBCC,
+  AVR32_SYNTAX_LD_UBCS,
+  AVR32_SYNTAX_LD_UBGE,
+  AVR32_SYNTAX_LD_UBLT,
+  AVR32_SYNTAX_LD_UBMI,
+  AVR32_SYNTAX_LD_UBPL,
+  AVR32_SYNTAX_LD_UBLS,
+  AVR32_SYNTAX_LD_UBGT,
+  AVR32_SYNTAX_LD_UBLE,
+  AVR32_SYNTAX_LD_UBHI,
+  AVR32_SYNTAX_LD_UBVS,
+  AVR32_SYNTAX_LD_UBVC,
+  AVR32_SYNTAX_LD_UBQS,
+  AVR32_SYNTAX_LD_UBAL,
+  AVR32_SYNTAX_LD_UBHS,
+  AVR32_SYNTAX_LD_UBLO,
+  AVR32_SYNTAX_ST_WEQ,
+  AVR32_SYNTAX_ST_WNE,
+  AVR32_SYNTAX_ST_WCC,
+  AVR32_SYNTAX_ST_WCS,
+  AVR32_SYNTAX_ST_WGE,
+  AVR32_SYNTAX_ST_WLT,
+  AVR32_SYNTAX_ST_WMI,
+  AVR32_SYNTAX_ST_WPL,
+  AVR32_SYNTAX_ST_WLS,
+  AVR32_SYNTAX_ST_WGT,
+  AVR32_SYNTAX_ST_WLE,
+  AVR32_SYNTAX_ST_WHI,
+  AVR32_SYNTAX_ST_WVS,
+  AVR32_SYNTAX_ST_WVC,
+  AVR32_SYNTAX_ST_WQS,
+  AVR32_SYNTAX_ST_WAL,
+  AVR32_SYNTAX_ST_WHS,
+  AVR32_SYNTAX_ST_WLO,
+  AVR32_SYNTAX_ST_HEQ,
+  AVR32_SYNTAX_ST_HNE,
+  AVR32_SYNTAX_ST_HCC,
+  AVR32_SYNTAX_ST_HCS,
+  AVR32_SYNTAX_ST_HGE,
+  AVR32_SYNTAX_ST_HLT,
+  AVR32_SYNTAX_ST_HMI,
+  AVR32_SYNTAX_ST_HPL,
+  AVR32_SYNTAX_ST_HLS,
+  AVR32_SYNTAX_ST_HGT,
+  AVR32_SYNTAX_ST_HLE,
+  AVR32_SYNTAX_ST_HHI,
+  AVR32_SYNTAX_ST_HVS,
+  AVR32_SYNTAX_ST_HVC,
+  AVR32_SYNTAX_ST_HQS,
+  AVR32_SYNTAX_ST_HAL,
+  AVR32_SYNTAX_ST_HHS,
+  AVR32_SYNTAX_ST_HLO,
+  AVR32_SYNTAX_ST_BEQ,
+  AVR32_SYNTAX_ST_BNE,
+  AVR32_SYNTAX_ST_BCC,
+  AVR32_SYNTAX_ST_BCS,
+  AVR32_SYNTAX_ST_BGE,
+  AVR32_SYNTAX_ST_BLT,
+  AVR32_SYNTAX_ST_BMI,
+  AVR32_SYNTAX_ST_BPL,
+  AVR32_SYNTAX_ST_BLS,
+  AVR32_SYNTAX_ST_BGT,
+  AVR32_SYNTAX_ST_BLE,
+  AVR32_SYNTAX_ST_BHI,
+  AVR32_SYNTAX_ST_BVS,
+  AVR32_SYNTAX_ST_BVC,
+  AVR32_SYNTAX_ST_BQS,
+  AVR32_SYNTAX_ST_BAL,
+  AVR32_SYNTAX_ST_BHS,
+  AVR32_SYNTAX_ST_BLO,
+  AVR32_SYNTAX_MOVH,
+  AVR32_SYNTAX__END_
+};
+#define AVR32_NR_SYNTAX AVR32_SYNTAX__END_
+
+enum avr32_alias_type
+  {
+    AVR32_ALIAS_FMAC_S,
+    AVR32_ALIAS_FMAC_D,
+    AVR32_ALIAS_FNMAC_S,
+    AVR32_ALIAS_FNMAC_D,
+    AVR32_ALIAS_FMSC_S,
+    AVR32_ALIAS_FMSC_D,
+    AVR32_ALIAS_FNMSC_S,
+    AVR32_ALIAS_FNMSC_D,
+    AVR32_ALIAS_FADD_S,
+    AVR32_ALIAS_FADD_D,
+    AVR32_ALIAS_FSUB_S,
+    AVR32_ALIAS_FSUB_D,
+    AVR32_ALIAS_FMUL_S,
+    AVR32_ALIAS_FMUL_D,
+    AVR32_ALIAS_FNMUL_S,
+    AVR32_ALIAS_FNMUL_D,
+    AVR32_ALIAS_FNEG_S,
+    AVR32_ALIAS_FNEG_D,
+    AVR32_ALIAS_FABS_S,
+    AVR32_ALIAS_FABS_D,
+    AVR32_ALIAS_FCMP_S,
+    AVR32_ALIAS_FCMP_D,
+    AVR32_ALIAS_FMOV1_S,
+    AVR32_ALIAS_FMOV1_D,
+    AVR32_ALIAS_FMOV2_S,
+    AVR32_ALIAS_FMOV2_D,
+    AVR32_ALIAS_FMOV3_S,
+    AVR32_ALIAS_FMOV3_D,
+    AVR32_ALIAS_FCASTS_D,
+    AVR32_ALIAS_FCASTD_S,
+    AVR32_ALIAS_PICOSVMAC0,
+    AVR32_ALIAS_PICOSVMAC1,
+    AVR32_ALIAS_PICOSVMAC2,
+    AVR32_ALIAS_PICOSVMAC3,
+    AVR32_ALIAS_PICOSVMUL0,
+    AVR32_ALIAS_PICOSVMUL1,
+    AVR32_ALIAS_PICOSVMUL2,
+    AVR32_ALIAS_PICOSVMUL3,
+    AVR32_ALIAS_PICOVMAC0,
+    AVR32_ALIAS_PICOVMAC1,
+    AVR32_ALIAS_PICOVMAC2,
+    AVR32_ALIAS_PICOVMAC3,
+    AVR32_ALIAS_PICOVMUL0,
+    AVR32_ALIAS_PICOVMUL1,
+    AVR32_ALIAS_PICOVMUL2,
+    AVR32_ALIAS_PICOVMUL3,
+    AVR32_ALIAS_PICOLD_D1,
+    AVR32_ALIAS_PICOLD_D2,
+    AVR32_ALIAS_PICOLD_D3,
+    AVR32_ALIAS_PICOLD_W1,
+    AVR32_ALIAS_PICOLD_W2,
+    AVR32_ALIAS_PICOLD_W3,
+    AVR32_ALIAS_PICOLDM_D,
+    AVR32_ALIAS_PICOLDM_D_PU,
+    AVR32_ALIAS_PICOLDM_W,
+    AVR32_ALIAS_PICOLDM_W_PU,
+    AVR32_ALIAS_PICOMV_D1,
+    AVR32_ALIAS_PICOMV_D2,
+    AVR32_ALIAS_PICOMV_W1,
+    AVR32_ALIAS_PICOMV_W2,
+    AVR32_ALIAS_PICOST_D1,
+    AVR32_ALIAS_PICOST_D2,
+    AVR32_ALIAS_PICOST_D3,
+    AVR32_ALIAS_PICOST_W1,
+    AVR32_ALIAS_PICOST_W2,
+    AVR32_ALIAS_PICOST_W3,
+    AVR32_ALIAS_PICOSTM_D,
+    AVR32_ALIAS_PICOSTM_D_PU,
+    AVR32_ALIAS_PICOSTM_W,
+    AVR32_ALIAS_PICOSTM_W_PU,
+    AVR32_ALIAS__END_
+  };
+#define AVR32_NR_ALIAS AVR32_ALIAS__END_
+
+enum avr32_mnemonic_type
+{
+  AVR32_MNEMONIC_ABS,
+  AVR32_MNEMONIC_ACALL,
+  AVR32_MNEMONIC_ACR,
+  AVR32_MNEMONIC_ADC,
+  AVR32_MNEMONIC_ADD,
+  AVR32_MNEMONIC_ADDABS,
+  AVR32_MNEMONIC_ADDHH_W,
+  AVR32_MNEMONIC_AND,
+  AVR32_MNEMONIC_ANDH,
+  AVR32_MNEMONIC_ANDL,
+  AVR32_MNEMONIC_ANDN,
+  AVR32_MNEMONIC_ASR,
+  AVR32_MNEMONIC_BFEXTS,
+  AVR32_MNEMONIC_BFEXTU,
+  AVR32_MNEMONIC_BFINS,
+  AVR32_MNEMONIC_BLD,
+  AVR32_MNEMONIC_BREQ,
+  AVR32_MNEMONIC_BRNE,
+  AVR32_MNEMONIC_BRCC,
+  AVR32_MNEMONIC_BRCS,
+  AVR32_MNEMONIC_BRGE,
+  AVR32_MNEMONIC_BRLT,
+  AVR32_MNEMONIC_BRMI,
+  AVR32_MNEMONIC_BRPL,
+  AVR32_MNEMONIC_BRHS,
+  AVR32_MNEMONIC_BRLO,
+  AVR32_MNEMONIC_BRLS,
+  AVR32_MNEMONIC_BRGT,
+  AVR32_MNEMONIC_BRLE,
+  AVR32_MNEMONIC_BRHI,
+  AVR32_MNEMONIC_BRVS,
+  AVR32_MNEMONIC_BRVC,
+  AVR32_MNEMONIC_BRQS,
+  AVR32_MNEMONIC_BRAL,
+  AVR32_MNEMONIC_BREAKPOINT,
+  AVR32_MNEMONIC_BREV,
+  AVR32_MNEMONIC_BST,
+  AVR32_MNEMONIC_CACHE,
+  AVR32_MNEMONIC_CASTS_B,
+  AVR32_MNEMONIC_CASTS_H,
+  AVR32_MNEMONIC_CASTU_B,
+  AVR32_MNEMONIC_CASTU_H,
+  AVR32_MNEMONIC_CBR,
+  AVR32_MNEMONIC_CLZ,
+  AVR32_MNEMONIC_COM,
+  AVR32_MNEMONIC_COP,
+  AVR32_MNEMONIC_CP_B,
+  AVR32_MNEMONIC_CP_H,
+  AVR32_MNEMONIC_CP_W,
+  AVR32_MNEMONIC_CP,
+  AVR32_MNEMONIC_CPC,
+  AVR32_MNEMONIC_CSRF,
+  AVR32_MNEMONIC_CSRFCZ,
+  AVR32_MNEMONIC_DIVS,
+  AVR32_MNEMONIC_DIVU,
+  AVR32_MNEMONIC_EOR,
+  AVR32_MNEMONIC_EORL,
+  AVR32_MNEMONIC_EORH,
+  AVR32_MNEMONIC_FRS,
+  AVR32_MNEMONIC_ICALL,
+  AVR32_MNEMONIC_INCJOSP,
+  AVR32_MNEMONIC_LD_D,
+  AVR32_MNEMONIC_LD_SB,
+  AVR32_MNEMONIC_LD_UB,
+  AVR32_MNEMONIC_LD_SH,
+  AVR32_MNEMONIC_LD_UH,
+  AVR32_MNEMONIC_LD_W,
+  AVR32_MNEMONIC_LDC_D,
+  AVR32_MNEMONIC_LDC_W,
+  AVR32_MNEMONIC_LDC0_D,
+  AVR32_MNEMONIC_LDC0_W,
+  AVR32_MNEMONIC_LDCM_D,
+  AVR32_MNEMONIC_LDCM_W,
+  AVR32_MNEMONIC_LDDPC,
+  AVR32_MNEMONIC_LDDSP,
+  AVR32_MNEMONIC_LDINS_B,
+  AVR32_MNEMONIC_LDINS_H,
+  AVR32_MNEMONIC_LDM,
+  AVR32_MNEMONIC_LDMTS,
+  AVR32_MNEMONIC_LDSWP_SH,
+  AVR32_MNEMONIC_LDSWP_UH,
+  AVR32_MNEMONIC_LDSWP_W,
+  AVR32_MNEMONIC_LSL,
+  AVR32_MNEMONIC_LSR,
+  AVR32_MNEMONIC_MAC,
+  AVR32_MNEMONIC_MACHH_D,
+  AVR32_MNEMONIC_MACHH_W,
+  AVR32_MNEMONIC_MACS_D,
+  AVR32_MNEMONIC_MACSATHH_W,
+  AVR32_MNEMONIC_MACU_D,
+  AVR32_MNEMONIC_MACWH_D,
+  AVR32_MNEMONIC_MAX,
+  AVR32_MNEMONIC_MCALL,
+  AVR32_MNEMONIC_MFDR,
+  AVR32_MNEMONIC_MFSR,
+  AVR32_MNEMONIC_MIN,
+  AVR32_MNEMONIC_MOV,
+  AVR32_MNEMONIC_MOVEQ,
+  AVR32_MNEMONIC_MOVNE,
+  AVR32_MNEMONIC_MOVCC,
+  AVR32_MNEMONIC_MOVCS,
+  AVR32_MNEMONIC_MOVGE,
+  AVR32_MNEMONIC_MOVLT,
+  AVR32_MNEMONIC_MOVMI,
+  AVR32_MNEMONIC_MOVPL,
+  AVR32_MNEMONIC_MOVLS,
+  AVR32_MNEMONIC_MOVGT,
+  AVR32_MNEMONIC_MOVLE,
+  AVR32_MNEMONIC_MOVHI,
+  AVR32_MNEMONIC_MOVVS,
+  AVR32_MNEMONIC_MOVVC,
+  AVR32_MNEMONIC_MOVQS,
+  AVR32_MNEMONIC_MOVAL,
+  AVR32_MNEMONIC_MOVHS,
+  AVR32_MNEMONIC_MOVLO,
+  AVR32_MNEMONIC_MTDR,
+  AVR32_MNEMONIC_MTSR,
+  AVR32_MNEMONIC_MUL,
+  AVR32_MNEMONIC_MULHH_W,
+  AVR32_MNEMONIC_MULNHH_W,
+  AVR32_MNEMONIC_MULNWH_D,
+  AVR32_MNEMONIC_MULS_D,
+  AVR32_MNEMONIC_MULSATHH_H,
+  AVR32_MNEMONIC_MULSATHH_W,
+  AVR32_MNEMONIC_MULSATRNDHH_H,
+  AVR32_MNEMONIC_MULSATRNDWH_W,
+  AVR32_MNEMONIC_MULSATWH_W,
+  AVR32_MNEMONIC_MULU_D,
+  AVR32_MNEMONIC_MULWH_D,
+  AVR32_MNEMONIC_MUSFR,
+  AVR32_MNEMONIC_MUSTR,
+  AVR32_MNEMONIC_MVCR_D,
+  AVR32_MNEMONIC_MVCR_W,
+  AVR32_MNEMONIC_MVRC_D,
+  AVR32_MNEMONIC_MVRC_W,
+  AVR32_MNEMONIC_NEG,
+  AVR32_MNEMONIC_NOP,
+  AVR32_MNEMONIC_OR,
+  AVR32_MNEMONIC_ORH,
+  AVR32_MNEMONIC_ORL,
+  AVR32_MNEMONIC_PABS_SB,
+  AVR32_MNEMONIC_PABS_SH,
+  AVR32_MNEMONIC_PACKSH_SB,
+  AVR32_MNEMONIC_PACKSH_UB,
+  AVR32_MNEMONIC_PACKW_SH,
+  AVR32_MNEMONIC_PADD_B,
+  AVR32_MNEMONIC_PADD_H,
+  AVR32_MNEMONIC_PADDH_SH,
+  AVR32_MNEMONIC_PADDH_UB,
+  AVR32_MNEMONIC_PADDS_SB,
+  AVR32_MNEMONIC_PADDS_SH,
+  AVR32_MNEMONIC_PADDS_UB,
+  AVR32_MNEMONIC_PADDS_UH,
+  AVR32_MNEMONIC_PADDSUB_H,
+  AVR32_MNEMONIC_PADDSUBH_SH,
+  AVR32_MNEMONIC_PADDSUBS_SH,
+  AVR32_MNEMONIC_PADDSUBS_UH,
+  AVR32_MNEMONIC_PADDX_H,
+  AVR32_MNEMONIC_PADDXH_SH,
+  AVR32_MNEMONIC_PADDXS_SH,
+  AVR32_MNEMONIC_PADDXS_UH,
+  AVR32_MNEMONIC_PASR_B,
+  AVR32_MNEMONIC_PASR_H,
+  AVR32_MNEMONIC_PAVG_SH,
+  AVR32_MNEMONIC_PAVG_UB,
+  AVR32_MNEMONIC_PLSL_B,
+  AVR32_MNEMONIC_PLSL_H,
+  AVR32_MNEMONIC_PLSR_B,
+  AVR32_MNEMONIC_PLSR_H,
+  AVR32_MNEMONIC_PMAX_SH,
+  AVR32_MNEMONIC_PMAX_UB,
+  AVR32_MNEMONIC_PMIN_SH,
+  AVR32_MNEMONIC_PMIN_UB,
+  AVR32_MNEMONIC_POPJC,
+  AVR32_MNEMONIC_POPM,
+  AVR32_MNEMONIC_PREF,
+  AVR32_MNEMONIC_PSAD,
+  AVR32_MNEMONIC_PSUB_B,
+  AVR32_MNEMONIC_PSUB_H,
+  AVR32_MNEMONIC_PSUBADD_H,
+  AVR32_MNEMONIC_PSUBADDH_SH,
+  AVR32_MNEMONIC_PSUBADDS_SH,
+  AVR32_MNEMONIC_PSUBADDS_UH,
+  AVR32_MNEMONIC_PSUBH_SH,
+  AVR32_MNEMONIC_PSUBH_UB,
+  AVR32_MNEMONIC_PSUBS_SB,
+  AVR32_MNEMONIC_PSUBS_SH,
+  AVR32_MNEMONIC_PSUBS_UB,
+  AVR32_MNEMONIC_PSUBS_UH,
+  AVR32_MNEMONIC_PSUBX_H,
+  AVR32_MNEMONIC_PSUBXH_SH,
+  AVR32_MNEMONIC_PSUBXS_SH,
+  AVR32_MNEMONIC_PSUBXS_UH,
+  AVR32_MNEMONIC_PUNPCKSB_H,
+  AVR32_MNEMONIC_PUNPCKUB_H,
+  AVR32_MNEMONIC_PUSHJC,
+  AVR32_MNEMONIC_PUSHM,
+  AVR32_MNEMONIC_RCALL,
+  AVR32_MNEMONIC_RETEQ,
+  AVR32_MNEMONIC_RETNE,
+  AVR32_MNEMONIC_RETCC,
+  AVR32_MNEMONIC_RETCS,
+  AVR32_MNEMONIC_RETGE,
+  AVR32_MNEMONIC_RETLT,
+  AVR32_MNEMONIC_RETMI,
+  AVR32_MNEMONIC_RETPL,
+  AVR32_MNEMONIC_RETLS,
+  AVR32_MNEMONIC_RETGT,
+  AVR32_MNEMONIC_RETLE,
+  AVR32_MNEMONIC_RETHI,
+  AVR32_MNEMONIC_RETVS,
+  AVR32_MNEMONIC_RETVC,
+  AVR32_MNEMONIC_RETQS,
+  AVR32_MNEMONIC_RETAL,
+  AVR32_MNEMONIC_RETHS,
+  AVR32_MNEMONIC_RETLO,
+  AVR32_MNEMONIC_RET,
+  AVR32_MNEMONIC_RETD,
+  AVR32_MNEMONIC_RETE,
+  AVR32_MNEMONIC_RETJ,
+  AVR32_MNEMONIC_RETS,
+  AVR32_MNEMONIC_RJMP,
+  AVR32_MNEMONIC_ROL,
+  AVR32_MNEMONIC_ROR,
+  AVR32_MNEMONIC_RSUB,
+  AVR32_MNEMONIC_SATADD_H,
+  AVR32_MNEMONIC_SATADD_W,
+  AVR32_MNEMONIC_SATRNDS,
+  AVR32_MNEMONIC_SATRNDU,
+  AVR32_MNEMONIC_SATS,
+  AVR32_MNEMONIC_SATSUB_H,
+  AVR32_MNEMONIC_SATSUB_W,
+  AVR32_MNEMONIC_SATU,
+  AVR32_MNEMONIC_SBC,
+  AVR32_MNEMONIC_SBR,
+  AVR32_MNEMONIC_SCALL,
+  AVR32_MNEMONIC_SCR,
+  AVR32_MNEMONIC_SLEEP,
+  AVR32_MNEMONIC_SREQ,
+  AVR32_MNEMONIC_SRNE,
+  AVR32_MNEMONIC_SRCC,
+  AVR32_MNEMONIC_SRCS,
+  AVR32_MNEMONIC_SRGE,
+  AVR32_MNEMONIC_SRLT,
+  AVR32_MNEMONIC_SRMI,
+  AVR32_MNEMONIC_SRPL,
+  AVR32_MNEMONIC_SRLS,
+  AVR32_MNEMONIC_SRGT,
+  AVR32_MNEMONIC_SRLE,
+  AVR32_MNEMONIC_SRHI,
+  AVR32_MNEMONIC_SRVS,
+  AVR32_MNEMONIC_SRVC,
+  AVR32_MNEMONIC_SRQS,
+  AVR32_MNEMONIC_SRAL,
+  AVR32_MNEMONIC_SRHS,
+  AVR32_MNEMONIC_SRLO,
+  AVR32_MNEMONIC_SSRF,
+  AVR32_MNEMONIC_ST_B,
+  AVR32_MNEMONIC_ST_D,
+  AVR32_MNEMONIC_ST_H,
+  AVR32_MNEMONIC_ST_W,
+  AVR32_MNEMONIC_STC_D,
+  AVR32_MNEMONIC_STC_W,
+  AVR32_MNEMONIC_STC0_D,
+  AVR32_MNEMONIC_STC0_W,
+  AVR32_MNEMONIC_STCM_D,
+  AVR32_MNEMONIC_STCM_W,
+  AVR32_MNEMONIC_STCOND,
+  AVR32_MNEMONIC_STDSP,
+  AVR32_MNEMONIC_STHH_W,
+  AVR32_MNEMONIC_STM,
+  AVR32_MNEMONIC_STMTS,
+  AVR32_MNEMONIC_STSWP_H,
+  AVR32_MNEMONIC_STSWP_W,
+  AVR32_MNEMONIC_SUB,
+  AVR32_MNEMONIC_SUBEQ,
+  AVR32_MNEMONIC_SUBNE,
+  AVR32_MNEMONIC_SUBCC,
+  AVR32_MNEMONIC_SUBCS,
+  AVR32_MNEMONIC_SUBGE,
+  AVR32_MNEMONIC_SUBLT,
+  AVR32_MNEMONIC_SUBMI,
+  AVR32_MNEMONIC_SUBPL,
+  AVR32_MNEMONIC_SUBLS,
+  AVR32_MNEMONIC_SUBGT,
+  AVR32_MNEMONIC_SUBLE,
+  AVR32_MNEMONIC_SUBHI,
+  AVR32_MNEMONIC_SUBVS,
+  AVR32_MNEMONIC_SUBVC,
+  AVR32_MNEMONIC_SUBQS,
+  AVR32_MNEMONIC_SUBAL,
+  AVR32_MNEMONIC_SUBHS,
+  AVR32_MNEMONIC_SUBLO,
+  AVR32_MNEMONIC_SUBFEQ,
+  AVR32_MNEMONIC_SUBFNE,
+  AVR32_MNEMONIC_SUBFCC,
+  AVR32_MNEMONIC_SUBFCS,
+  AVR32_MNEMONIC_SUBFGE,
+  AVR32_MNEMONIC_SUBFLT,
+  AVR32_MNEMONIC_SUBFMI,
+  AVR32_MNEMONIC_SUBFPL,
+  AVR32_MNEMONIC_SUBFLS,
+  AVR32_MNEMONIC_SUBFGT,
+  AVR32_MNEMONIC_SUBFLE,
+  AVR32_MNEMONIC_SUBFHI,
+  AVR32_MNEMONIC_SUBFVS,
+  AVR32_MNEMONIC_SUBFVC,
+  AVR32_MNEMONIC_SUBFQS,
+  AVR32_MNEMONIC_SUBFAL,
+  AVR32_MNEMONIC_SUBFHS,
+  AVR32_MNEMONIC_SUBFLO,
+  AVR32_MNEMONIC_SUBHH_W,
+  AVR32_MNEMONIC_SWAP_B,
+  AVR32_MNEMONIC_SWAP_BH,
+  AVR32_MNEMONIC_SWAP_H,
+  AVR32_MNEMONIC_SYNC,
+  AVR32_MNEMONIC_TLBR,
+  AVR32_MNEMONIC_TLBS,
+  AVR32_MNEMONIC_TLBW,
+  AVR32_MNEMONIC_TNBZ,
+  AVR32_MNEMONIC_TST,
+  AVR32_MNEMONIC_XCHG,
+  AVR32_MNEMONIC_MEMC,
+  AVR32_MNEMONIC_MEMS,
+  AVR32_MNEMONIC_MEMT,
+  AVR32_MNEMONIC_FADD_S,
+  AVR32_MNEMONIC_FADD_D,
+  AVR32_MNEMONIC_FSUB_S,
+  AVR32_MNEMONIC_FSUB_D,
+  AVR32_MNEMONIC_FMAC_S,
+  AVR32_MNEMONIC_FMAC_D,
+  AVR32_MNEMONIC_FNMAC_S,
+  AVR32_MNEMONIC_FNMAC_D,
+  AVR32_MNEMONIC_FMSC_S,
+  AVR32_MNEMONIC_FMSC_D,
+  AVR32_MNEMONIC_FNMSC_S,
+  AVR32_MNEMONIC_FNMSC_D,
+  AVR32_MNEMONIC_FMUL_S,
+  AVR32_MNEMONIC_FMUL_D,
+  AVR32_MNEMONIC_FNMUL_S,
+  AVR32_MNEMONIC_FNMUL_D,
+  AVR32_MNEMONIC_FNEG_S,
+  AVR32_MNEMONIC_FNEG_D,
+  AVR32_MNEMONIC_FABS_S,
+  AVR32_MNEMONIC_FABS_D,
+  AVR32_MNEMONIC_FCMP_S,
+  AVR32_MNEMONIC_FCMP_D,
+  AVR32_MNEMONIC_FMOV_S,
+  AVR32_MNEMONIC_FMOV_D,
+  AVR32_MNEMONIC_FCASTS_D,
+  AVR32_MNEMONIC_FCASTD_S,
+  /* AVR32_MNEMONIC_FLD_S,
+     AVR32_MNEMONIC_FLD_D,
+     AVR32_MNEMONIC_FST_S,
+     AVR32_MNEMONIC_FST_D, */
+  AVR32_MNEMONIC_LDA_W,
+  AVR32_MNEMONIC_CALL,
+  AVR32_MNEMONIC_PICOSVMAC,
+  AVR32_MNEMONIC_PICOSVMUL,
+  AVR32_MNEMONIC_PICOVMAC,
+  AVR32_MNEMONIC_PICOVMUL,
+  AVR32_MNEMONIC_PICOLD_D,
+  AVR32_MNEMONIC_PICOLD_W,
+  AVR32_MNEMONIC_PICOLDM_D,
+  AVR32_MNEMONIC_PICOLDM_W,
+  AVR32_MNEMONIC_PICOMV_D,
+  AVR32_MNEMONIC_PICOMV_W,
+  AVR32_MNEMONIC_PICOST_D,
+  AVR32_MNEMONIC_PICOST_W,
+  AVR32_MNEMONIC_PICOSTM_D,
+  AVR32_MNEMONIC_PICOSTM_W,
+  AVR32_MNEMONIC_RSUBEQ,
+  AVR32_MNEMONIC_RSUBNE,
+  AVR32_MNEMONIC_RSUBCC,
+  AVR32_MNEMONIC_RSUBCS,
+  AVR32_MNEMONIC_RSUBGE,
+  AVR32_MNEMONIC_RSUBLT,
+  AVR32_MNEMONIC_RSUBMI,
+  AVR32_MNEMONIC_RSUBPL,
+  AVR32_MNEMONIC_RSUBLS,
+  AVR32_MNEMONIC_RSUBGT,
+  AVR32_MNEMONIC_RSUBLE,
+  AVR32_MNEMONIC_RSUBHI,
+  AVR32_MNEMONIC_RSUBVS,
+  AVR32_MNEMONIC_RSUBVC,
+  AVR32_MNEMONIC_RSUBQS,
+  AVR32_MNEMONIC_RSUBAL,
+  AVR32_MNEMONIC_RSUBHS,
+  AVR32_MNEMONIC_RSUBLO,
+  AVR32_MNEMONIC_ADDEQ,
+  AVR32_MNEMONIC_ADDNE,
+  AVR32_MNEMONIC_ADDCC,
+  AVR32_MNEMONIC_ADDCS,
+  AVR32_MNEMONIC_ADDGE,
+  AVR32_MNEMONIC_ADDLT,
+  AVR32_MNEMONIC_ADDMI,
+  AVR32_MNEMONIC_ADDPL,
+  AVR32_MNEMONIC_ADDLS,
+  AVR32_MNEMONIC_ADDGT,
+  AVR32_MNEMONIC_ADDLE,
+  AVR32_MNEMONIC_ADDHI,
+  AVR32_MNEMONIC_ADDVS,
+  AVR32_MNEMONIC_ADDVC,
+  AVR32_MNEMONIC_ADDQS,
+  AVR32_MNEMONIC_ADDAL,
+  AVR32_MNEMONIC_ADDHS,
+  AVR32_MNEMONIC_ADDLO,
+  AVR32_MNEMONIC_ANDEQ,
+  AVR32_MNEMONIC_ANDNE,
+  AVR32_MNEMONIC_ANDCC,
+  AVR32_MNEMONIC_ANDCS,
+  AVR32_MNEMONIC_ANDGE,
+  AVR32_MNEMONIC_ANDLT,
+  AVR32_MNEMONIC_ANDMI,
+  AVR32_MNEMONIC_ANDPL,
+  AVR32_MNEMONIC_ANDLS,
+  AVR32_MNEMONIC_ANDGT,
+  AVR32_MNEMONIC_ANDLE,
+  AVR32_MNEMONIC_ANDHI,
+  AVR32_MNEMONIC_ANDVS,
+  AVR32_MNEMONIC_ANDVC,
+  AVR32_MNEMONIC_ANDQS,
+  AVR32_MNEMONIC_ANDAL,
+  AVR32_MNEMONIC_ANDHS,
+  AVR32_MNEMONIC_ANDLO,
+  AVR32_MNEMONIC_OREQ,
+  AVR32_MNEMONIC_ORNE,
+  AVR32_MNEMONIC_ORCC,
+  AVR32_MNEMONIC_ORCS,
+  AVR32_MNEMONIC_ORGE,
+  AVR32_MNEMONIC_ORLT,
+  AVR32_MNEMONIC_ORMI,
+  AVR32_MNEMONIC_ORPL,
+  AVR32_MNEMONIC_ORLS,
+  AVR32_MNEMONIC_ORGT,
+  AVR32_MNEMONIC_ORLE,
+  AVR32_MNEMONIC_ORHI,
+  AVR32_MNEMONIC_ORVS,
+  AVR32_MNEMONIC_ORVC,
+  AVR32_MNEMONIC_ORQS,
+  AVR32_MNEMONIC_ORAL,
+  AVR32_MNEMONIC_ORHS,
+  AVR32_MNEMONIC_ORLO,
+  AVR32_MNEMONIC_EOREQ,
+  AVR32_MNEMONIC_EORNE,
+  AVR32_MNEMONIC_EORCC,
+  AVR32_MNEMONIC_EORCS,
+  AVR32_MNEMONIC_EORGE,
+  AVR32_MNEMONIC_EORLT,
+  AVR32_MNEMONIC_EORMI,
+  AVR32_MNEMONIC_EORPL,
+  AVR32_MNEMONIC_EORLS,
+  AVR32_MNEMONIC_EORGT,
+  AVR32_MNEMONIC_EORLE,
+  AVR32_MNEMONIC_EORHI,
+  AVR32_MNEMONIC_EORVS,
+  AVR32_MNEMONIC_EORVC,
+  AVR32_MNEMONIC_EORQS,
+  AVR32_MNEMONIC_EORAL,
+  AVR32_MNEMONIC_EORHS,
+  AVR32_MNEMONIC_EORLO,
+  AVR32_MNEMONIC_LD_WEQ,
+  AVR32_MNEMONIC_LD_WNE,
+  AVR32_MNEMONIC_LD_WCC,
+  AVR32_MNEMONIC_LD_WCS,
+  AVR32_MNEMONIC_LD_WGE,
+  AVR32_MNEMONIC_LD_WLT,
+  AVR32_MNEMONIC_LD_WMI,
+  AVR32_MNEMONIC_LD_WPL,
+  AVR32_MNEMONIC_LD_WLS,
+  AVR32_MNEMONIC_LD_WGT,
+  AVR32_MNEMONIC_LD_WLE,
+  AVR32_MNEMONIC_LD_WHI,
+  AVR32_MNEMONIC_LD_WVS,
+  AVR32_MNEMONIC_LD_WVC,
+  AVR32_MNEMONIC_LD_WQS,
+  AVR32_MNEMONIC_LD_WAL,
+  AVR32_MNEMONIC_LD_WHS,
+  AVR32_MNEMONIC_LD_WLO,
+  AVR32_MNEMONIC_LD_SHEQ,
+  AVR32_MNEMONIC_LD_SHNE,
+  AVR32_MNEMONIC_LD_SHCC,
+  AVR32_MNEMONIC_LD_SHCS,
+  AVR32_MNEMONIC_LD_SHGE,
+  AVR32_MNEMONIC_LD_SHLT,
+  AVR32_MNEMONIC_LD_SHMI,
+  AVR32_MNEMONIC_LD_SHPL,
+  AVR32_MNEMONIC_LD_SHLS,
+  AVR32_MNEMONIC_LD_SHGT,
+  AVR32_MNEMONIC_LD_SHLE,
+  AVR32_MNEMONIC_LD_SHHI,
+  AVR32_MNEMONIC_LD_SHVS,
+  AVR32_MNEMONIC_LD_SHVC,
+  AVR32_MNEMONIC_LD_SHQS,
+  AVR32_MNEMONIC_LD_SHAL,
+  AVR32_MNEMONIC_LD_SHHS,
+  AVR32_MNEMONIC_LD_SHLO,
+  AVR32_MNEMONIC_LD_UHEQ,
+  AVR32_MNEMONIC_LD_UHNE,
+  AVR32_MNEMONIC_LD_UHCC,
+  AVR32_MNEMONIC_LD_UHCS,
+  AVR32_MNEMONIC_LD_UHGE,
+  AVR32_MNEMONIC_LD_UHLT,
+  AVR32_MNEMONIC_LD_UHMI,
+  AVR32_MNEMONIC_LD_UHPL,
+  AVR32_MNEMONIC_LD_UHLS,
+  AVR32_MNEMONIC_LD_UHGT,
+  AVR32_MNEMONIC_LD_UHLE,
+  AVR32_MNEMONIC_LD_UHHI,
+  AVR32_MNEMONIC_LD_UHVS,
+  AVR32_MNEMONIC_LD_UHVC,
+  AVR32_MNEMONIC_LD_UHQS,
+  AVR32_MNEMONIC_LD_UHAL,
+  AVR32_MNEMONIC_LD_UHHS,
+  AVR32_MNEMONIC_LD_UHLO,
+  AVR32_MNEMONIC_LD_SBEQ,
+  AVR32_MNEMONIC_LD_SBNE,
+  AVR32_MNEMONIC_LD_SBCC,
+  AVR32_MNEMONIC_LD_SBCS,
+  AVR32_MNEMONIC_LD_SBGE,
+  AVR32_MNEMONIC_LD_SBLT,
+  AVR32_MNEMONIC_LD_SBMI,
+  AVR32_MNEMONIC_LD_SBPL,
+  AVR32_MNEMONIC_LD_SBLS,
+  AVR32_MNEMONIC_LD_SBGT,
+  AVR32_MNEMONIC_LD_SBLE,
+  AVR32_MNEMONIC_LD_SBHI,
+  AVR32_MNEMONIC_LD_SBVS,
+  AVR32_MNEMONIC_LD_SBVC,
+  AVR32_MNEMONIC_LD_SBQS,
+  AVR32_MNEMONIC_LD_SBAL,
+  AVR32_MNEMONIC_LD_SBHS,
+  AVR32_MNEMONIC_LD_SBLO,
+  AVR32_MNEMONIC_LD_UBEQ,
+  AVR32_MNEMONIC_LD_UBNE,
+  AVR32_MNEMONIC_LD_UBCC,
+  AVR32_MNEMONIC_LD_UBCS,
+  AVR32_MNEMONIC_LD_UBGE,
+  AVR32_MNEMONIC_LD_UBLT,
+  AVR32_MNEMONIC_LD_UBMI,
+  AVR32_MNEMONIC_LD_UBPL,
+  AVR32_MNEMONIC_LD_UBLS,
+  AVR32_MNEMONIC_LD_UBGT,
+  AVR32_MNEMONIC_LD_UBLE,
+  AVR32_MNEMONIC_LD_UBHI,
+  AVR32_MNEMONIC_LD_UBVS,
+  AVR32_MNEMONIC_LD_UBVC,
+  AVR32_MNEMONIC_LD_UBQS,
+  AVR32_MNEMONIC_LD_UBAL,
+  AVR32_MNEMONIC_LD_UBHS,
+  AVR32_MNEMONIC_LD_UBLO,
+  AVR32_MNEMONIC_ST_WEQ,
+  AVR32_MNEMONIC_ST_WNE,
+  AVR32_MNEMONIC_ST_WCC,
+  AVR32_MNEMONIC_ST_WCS,
+  AVR32_MNEMONIC_ST_WGE,
+  AVR32_MNEMONIC_ST_WLT,
+  AVR32_MNEMONIC_ST_WMI,
+  AVR32_MNEMONIC_ST_WPL,
+  AVR32_MNEMONIC_ST_WLS,
+  AVR32_MNEMONIC_ST_WGT,
+  AVR32_MNEMONIC_ST_WLE,
+  AVR32_MNEMONIC_ST_WHI,
+  AVR32_MNEMONIC_ST_WVS,
+  AVR32_MNEMONIC_ST_WVC,
+  AVR32_MNEMONIC_ST_WQS,
+  AVR32_MNEMONIC_ST_WAL,
+  AVR32_MNEMONIC_ST_WHS,
+  AVR32_MNEMONIC_ST_WLO,
+  AVR32_MNEMONIC_ST_HEQ,
+  AVR32_MNEMONIC_ST_HNE,
+  AVR32_MNEMONIC_ST_HCC,
+  AVR32_MNEMONIC_ST_HCS,
+  AVR32_MNEMONIC_ST_HGE,
+  AVR32_MNEMONIC_ST_HLT,
+  AVR32_MNEMONIC_ST_HMI,
+  AVR32_MNEMONIC_ST_HPL,
+  AVR32_MNEMONIC_ST_HLS,
+  AVR32_MNEMONIC_ST_HGT,
+  AVR32_MNEMONIC_ST_HLE,
+  AVR32_MNEMONIC_ST_HHI,
+  AVR32_MNEMONIC_ST_HVS,
+  AVR32_MNEMONIC_ST_HVC,
+  AVR32_MNEMONIC_ST_HQS,
+  AVR32_MNEMONIC_ST_HAL,
+  AVR32_MNEMONIC_ST_HHS,
+  AVR32_MNEMONIC_ST_HLO,
+  AVR32_MNEMONIC_ST_BEQ,
+  AVR32_MNEMONIC_ST_BNE,
+  AVR32_MNEMONIC_ST_BCC,
+  AVR32_MNEMONIC_ST_BCS,
+  AVR32_MNEMONIC_ST_BGE,
+  AVR32_MNEMONIC_ST_BLT,
+  AVR32_MNEMONIC_ST_BMI,
+  AVR32_MNEMONIC_ST_BPL,
+  AVR32_MNEMONIC_ST_BLS,
+  AVR32_MNEMONIC_ST_BGT,
+  AVR32_MNEMONIC_ST_BLE,
+  AVR32_MNEMONIC_ST_BHI,
+  AVR32_MNEMONIC_ST_BVS,
+  AVR32_MNEMONIC_ST_BVC,
+  AVR32_MNEMONIC_ST_BQS,
+  AVR32_MNEMONIC_ST_BAL,
+  AVR32_MNEMONIC_ST_BHS,
+  AVR32_MNEMONIC_ST_BLO,
+  AVR32_MNEMONIC_MOVH,
+  AVR32_MNEMONIC__END_
+};
+#define AVR32_NR_MNEMONICS AVR32_MNEMONIC__END_
+
+enum avr32_syntax_parser
+  {
+    AVR32_PARSER_NORMAL,
+    AVR32_PARSER_ALIAS,
+    AVR32_PARSER_LDA,
+    AVR32_PARSER_CALL,
+    AVR32_PARSER__END_
+  };
+#define AVR32_NR_PARSERS AVR32_PARSER__END_
diff -Nrup gdb-6.7.1/opcodes/configure.in gdb-6.7.1-atmel/opcodes/configure.in
--- gdb-6.7.1/opcodes/configure.in	2007-08-31 16:55:10.000000000 +0200
+++ gdb-6.7.1-atmel/opcodes/configure.in	2008-04-03 15:00:36.000000000 +0200
@@ -159,6 +159,7 @@ if test x${all_targets} = xfalse ; then
 	bfd_arc_arch)		ta="$ta arc-dis.lo arc-opc.lo arc-ext.lo" ;;
 	bfd_arm_arch)		ta="$ta arm-dis.lo" ;;
 	bfd_avr_arch)		ta="$ta avr-dis.lo" ;;
+	bfd_avr32_arch)		ta="$ta avr32-asm.lo avr32-dis.lo avr32-opc.lo" ;;
 	bfd_bfin_arch)		ta="$ta bfin-dis.lo" ;;
 	bfd_cr16_arch)    	ta="$ta cr16-dis.lo cr16-opc.lo" ;;
 	bfd_cris_arch)		ta="$ta cris-dis.lo cris-opc.lo cgen-bitset.lo" ;;
@@ -217,7 +218,7 @@ if test x${all_targets} = xfalse ; then
 				ta="$ta sh64-dis.lo sh64-opc.lo"
 				archdefs="$archdefs -DINCLUDE_SHMEDIA"
 				break;;
-	    esac;
+	    esac
 	  done
 				ta="$ta sh-dis.lo cgen-bitset.lo" ;;
 	bfd_sparc_arch)		ta="$ta sparc-dis.lo sparc-opc.lo" ;;
diff -Nrup gdb-6.7.1/opcodes/disassemble.c gdb-6.7.1-atmel/opcodes/disassemble.c
--- gdb-6.7.1/opcodes/disassemble.c	2007-07-05 11:49:00.000000000 +0200
+++ gdb-6.7.1-atmel/opcodes/disassemble.c	2008-04-03 15:00:36.000000000 +0200
@@ -27,6 +27,7 @@
 #define ARCH_arc
 #define ARCH_arm
 #define ARCH_avr
+#define ARCH_avr32
 #define ARCH_bfin
 #define ARCH_cr16
 #define ARCH_cris
@@ -128,6 +129,11 @@ disassembler (abfd)
       disassemble = print_insn_avr;
       break;
 #endif
+#ifdef ARCH_avr32
+    case bfd_arch_avr32:
+      disassemble = print_insn_avr32;
+      break;
+#endif
 #ifdef ARCH_bfin
     case bfd_arch_bfin:
       disassemble = print_insn_bfin;
@@ -463,6 +469,9 @@ disassembler_usage (stream)
 #ifdef ARCH_powerpc
   print_ppc_disassembler_options (stream);
 #endif
+#ifdef ARCH_avr32
+  print_avr32_disassembler_options (stream);
+#endif
 #ifdef ARCH_i386
   print_i386_disassembler_options (stream);
 #endif
diff -Nrup gdb-6.7.1/opcodes/Makefile.am gdb-6.7.1-atmel/opcodes/Makefile.am
--- gdb-6.7.1/opcodes/Makefile.am	2007-09-06 23:31:55.000000000 +0200
+++ gdb-6.7.1-atmel/opcodes/Makefile.am	2008-04-03 15:00:35.000000000 +0200
@@ -29,6 +29,7 @@ LIBIBERTY = ../libiberty/libiberty.a
 
 # Header files.
 HFILES = \
+	avr32-asm.h avr32-opc.h \
 	cgen-ops.h cgen-types.h \
 	fr30-desc.h fr30-opc.h \
 	frv-desc.h frv-opc.h \
@@ -63,6 +64,9 @@ CFILES = \
 	arc-ext.c \
 	arm-dis.c \
 	avr-dis.c \
+	avr32-asm.c \
+	avr32-dis.c \
+	avr32-opc.c \
 	bfin-dis.c \
 	cgen-asm.c \
 	cgen-bitset.c \
@@ -217,6 +221,9 @@ ALL_MACHINES = \
 	arc-ext.lo \
 	arm-dis.lo \
 	avr-dis.lo \
+	avr32-asm.lo \
+	avr32-dis.lo \
+	avr32-opc.lo \
 	bfin-dis.lo \
 	cgen-asm.lo \
 	cgen-bitset.lo \
@@ -674,6 +681,15 @@ avr-dis.lo: avr-dis.c sysdep.h config.h 
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h \
   opintl.h $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/avr.h
+avr32-asm.lo: avr32-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h opintl.h \
+  $(INCDIR)/xregex.h $(INCDIR)/xregex2.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
+avr32-dis.lo: avr32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
+  avr32-opc.h opintl.h
+avr32-opc.lo: avr32-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h $(INCDIR)/libiberty.h
 bfin-dis.lo: bfin-dis.c $(INCDIR)/opcode/bfin.h $(INCDIR)/dis-asm.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h
 cgen-asm.lo: cgen-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
diff -Nrup gdb-6.7.1/opcodes/Makefile.in gdb-6.7.1-atmel/opcodes/Makefile.in
--- gdb-6.7.1/opcodes/Makefile.in	2007-09-06 23:31:55.000000000 +0200
+++ gdb-6.7.1-atmel/opcodes/Makefile.in	2008-04-03 15:01:44.000000000 +0200
@@ -1,8 +1,8 @@
-# Makefile.in generated by automake 1.9.6 from Makefile.am.
+# Makefile.in generated by automake 1.10.1 from Makefile.am.
 # @configure_input@
 
 # Copyright (C) 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
-# 2003, 2004, 2005  Free Software Foundation, Inc.
+# 2003, 2004, 2005, 2006, 2007, 2008  Free Software Foundation, Inc.
 # This Makefile.in is free software; the Free Software Foundation
 # gives unlimited permission to copy and/or distribute it,
 # with or without modifications, as long as this notice is preserved.
@@ -15,15 +15,11 @@
 @SET_MAKE@
 
 
-srcdir = @srcdir@
-top_srcdir = @top_srcdir@
 VPATH = @srcdir@
 pkgdatadir = $(datadir)/@PACKAGE@
 pkglibdir = $(libdir)/@PACKAGE@
 pkgincludedir = $(includedir)/@PACKAGE@
-top_builddir = .
 am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
-INSTALL = @INSTALL@
 install_sh_DATA = $(install_sh) -c -m 644
 install_sh_PROGRAM = $(install_sh) -c
 install_sh_SCRIPT = $(install_sh) -c
@@ -38,13 +34,11 @@ POST_UNINSTALL = :
 build_triplet = @build@
 host_triplet = @host@
 target_triplet = @target@
-DIST_COMMON = $(srcdir)/../config.guess $(srcdir)/../config.sub \
-	ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
+subdir = .
+DIST_COMMON = ChangeLog $(srcdir)/Makefile.in $(srcdir)/Makefile.am \
 	$(top_srcdir)/configure $(am__configure_deps) \
 	$(srcdir)/config.in $(srcdir)/../mkinstalldirs \
-	$(top_srcdir)/po/Make-in $(srcdir)/../ltmain.sh \
-	$(srcdir)/../config.guess $(srcdir)/../config.sub
-subdir = .
+	$(top_srcdir)/po/Make-in
 ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
 am__aclocal_m4_deps = $(top_srcdir)/../bfd/acinclude.m4 \
 	$(top_srcdir)/../bfd/warning.m4 $(top_srcdir)/../config/acx.m4 \
@@ -59,7 +53,7 @@ am__aclocal_m4_deps = $(top_srcdir)/../b
 am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
 	$(ACLOCAL_M4)
 am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
- configure.lineno configure.status.lineno
+ configure.lineno config.status.lineno
 mkinstalldirs = $(SHELL) $(top_srcdir)/../mkinstalldirs
 CONFIG_HEADER = config.h
 CONFIG_CLEAN_FILES = po/Makefile.in
@@ -81,30 +75,35 @@ LTLIBRARIES = $(bfdlib_LTLIBRARIES)
 am__DEPENDENCIES_1 =
 am_libopcodes_la_OBJECTS = dis-buf.lo disassemble.lo dis-init.lo
 libopcodes_la_OBJECTS = $(am_libopcodes_la_OBJECTS)
-DEFAULT_INCLUDES = -I. -I$(srcdir) -I.
+libopcodes_la_LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libopcodes_la_LDFLAGS) $(LDFLAGS) -o $@
+DEFAULT_INCLUDES = -I.@am__isrc@
 depcomp =
 am__depfiles_maybe =
 COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
 	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
-LTCOMPILE = $(LIBTOOL) --tag=CC --mode=compile $(CC) $(DEFS) \
-	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
-	$(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
 CCLD = $(CC)
-LINK = $(LIBTOOL) --tag=CC --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
-	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \
+	--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \
+	$(LDFLAGS) -o $@
 SOURCES = libopcodes.c $(libopcodes_la_SOURCES)
 RECURSIVE_TARGETS = all-recursive check-recursive dvi-recursive \
 	html-recursive info-recursive install-data-recursive \
-	install-exec-recursive install-info-recursive \
-	install-recursive installcheck-recursive installdirs-recursive \
-	pdf-recursive ps-recursive uninstall-info-recursive \
-	uninstall-recursive
+	install-dvi-recursive install-exec-recursive \
+	install-html-recursive install-info-recursive \
+	install-pdf-recursive install-ps-recursive install-recursive \
+	installcheck-recursive installdirs-recursive pdf-recursive \
+	ps-recursive uninstall-recursive
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
 ETAGS = etags
 CTAGS = ctags
 DIST_SUBDIRS = $(SUBDIRS)
 ACLOCAL = @ACLOCAL@
-AMDEP_FALSE = @AMDEP_FALSE@
-AMDEP_TRUE = @AMDEP_TRUE@
 AMTAR = @AMTAR@
 AR = @AR@
 AUTOCONF = @AUTOCONF@
@@ -118,8 +117,6 @@ CC = @CC@
 CCDEPMODE = @CCDEPMODE@
 CC_FOR_BUILD = @CC_FOR_BUILD@
 CFLAGS = @CFLAGS@
-CGEN_MAINT_FALSE = @CGEN_MAINT_FALSE@
-CGEN_MAINT_TRUE = @CGEN_MAINT_TRUE@
 CPP = @CPP@
 CPPFLAGS = @CPPFLAGS@
 CYGPATH_W = @CYGPATH_W@
@@ -139,9 +136,8 @@ GMSGFMT = @GMSGFMT@
 GREP = @GREP@
 HDEFINES = @HDEFINES@
 INCINTL = @INCINTL@
+INSTALL = @INSTALL@
 INSTALL_DATA = @INSTALL_DATA@
-INSTALL_LIBBFD_FALSE = @INSTALL_LIBBFD_FALSE@
-INSTALL_LIBBFD_TRUE = @INSTALL_LIBBFD_TRUE@
 INSTALL_PROGRAM = @INSTALL_PROGRAM@
 INSTALL_SCRIPT = @INSTALL_SCRIPT@
 INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
@@ -156,9 +152,8 @@ LIBTOOL = @LIBTOOL@
 LN_S = @LN_S@
 LTLIBOBJS = @LTLIBOBJS@
 MAINT = @MAINT@
-MAINTAINER_MODE_FALSE = @MAINTAINER_MODE_FALSE@
-MAINTAINER_MODE_TRUE = @MAINTAINER_MODE_TRUE@
 MAKEINFO = @MAKEINFO@
+MKDIR_P = @MKDIR_P@
 MKINSTALLDIRS = @MKINSTALLDIRS@
 MSGFMT = @MSGFMT@
 MSGMERGE = @MSGMERGE@
@@ -184,10 +179,12 @@ WARN_CFLAGS = @WARN_CFLAGS@
 WIN32LDFLAGS = @WIN32LDFLAGS@
 WIN32LIBADD = @WIN32LIBADD@
 XGETTEXT = @XGETTEXT@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
 ac_ct_CC = @ac_ct_CC@
 ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
-am__fastdepCC_FALSE = @am__fastdepCC_FALSE@
-am__fastdepCC_TRUE = @am__fastdepCC_TRUE@
 am__include = @am__include@
 am__leading_dot = @am__leading_dot@
 am__quote = @am__quote@
@@ -202,6 +199,7 @@ build_alias = @build_alias@
 build_cpu = @build_cpu@
 build_os = @build_os@
 build_vendor = @build_vendor@
+builddir = @builddir@
 cgendir = @cgendir@
 datadir = @datadir@
 datarootdir = @datarootdir@
@@ -232,6 +230,7 @@ program_transform_name = @program_transf
 psdir = @psdir@
 sbindir = @sbindir@
 sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
 sysconfdir = @sysconfdir@
 target = @target@
 target_alias = @target_alias@
@@ -239,6 +238,8 @@ target_cpu = @target_cpu@
 target_noncanonical = @target_noncanonical@
 target_os = @target_os@
 target_vendor = @target_vendor@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
 AUTOMAKE_OPTIONS = 1.9 cygnus
 ACLOCAL_AMFLAGS = -I .. -I ../config -I ../bfd
 SUBDIRS = po
@@ -256,6 +257,7 @@ LIBIBERTY = ../libiberty/libiberty.a
 
 # Header files.
 HFILES = \
+	avr32-asm.h avr32-opc.h \
 	cgen-ops.h cgen-types.h \
 	fr30-desc.h fr30-opc.h \
 	frv-desc.h frv-opc.h \
@@ -291,6 +293,9 @@ CFILES = \
 	arc-ext.c \
 	arm-dis.c \
 	avr-dis.c \
+	avr32-asm.c \
+	avr32-dis.c \
+	avr32-opc.c \
 	bfin-dis.c \
 	cgen-asm.c \
 	cgen-bitset.c \
@@ -445,6 +450,9 @@ ALL_MACHINES = \
 	arc-ext.lo \
 	arm-dis.lo \
 	avr-dis.lo \
+	avr32-asm.lo \
+	avr32-dis.lo \
+	avr32-opc.lo \
 	bfin-dis.lo \
 	cgen-asm.lo \
 	cgen-bitset.lo \
@@ -651,15 +659,15 @@ $(srcdir)/Makefile.in: @MAINTAINER_MODE_
 	@for dep in $?; do \
 	  case '$(am__configure_deps)' in \
 	    *$$dep*) \
-	      echo ' cd $(srcdir) && $(AUTOMAKE) --cygnus '; \
-	      cd $(srcdir) && $(AUTOMAKE) --cygnus  \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign '; \
+	      cd $(srcdir) && $(AUTOMAKE) --foreign  \
 		&& exit 0; \
 	      exit 1;; \
 	  esac; \
 	done; \
-	echo ' cd $(top_srcdir) && $(AUTOMAKE) --cygnus  Makefile'; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign  Makefile'; \
 	cd $(top_srcdir) && \
-	  $(AUTOMAKE) --cygnus  Makefile
+	  $(AUTOMAKE) --foreign  Makefile
 .PRECIOUS: Makefile
 Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
 	@case '$?' in \
@@ -682,7 +690,7 @@ $(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(
 config.h: stamp-h1
 	@if test ! -f $@; then \
 	  rm -f stamp-h1; \
-	  $(MAKE) stamp-h1; \
+	  $(MAKE) $(AM_MAKEFLAGS) stamp-h1; \
 	else :; fi
 
 stamp-h1: $(srcdir)/config.in $(top_builddir)/config.status
@@ -710,7 +718,7 @@ clean-bfdlibLTLIBRARIES:
 	  rm -f "$${dir}/so_locations"; \
 	done
 libopcodes.la: $(libopcodes_la_OBJECTS) $(libopcodes_la_DEPENDENCIES) 
-	$(LINK) -rpath $(bfdlibdir) $(libopcodes_la_LDFLAGS) $(libopcodes_la_OBJECTS) $(libopcodes_la_LIBADD) $(LIBS)
+	$(libopcodes_la_LINK) -rpath $(bfdlibdir) $(libopcodes_la_OBJECTS) $(libopcodes_la_LIBADD) $(LIBS)
 
 mostlyclean-compile:
 	-rm -f *.$(OBJEXT)
@@ -735,7 +743,6 @@ clean-libtool:
 
 distclean-libtool:
 	-rm -f libtool
-uninstall-info-am:
 
 # This directory's subdirectories are mostly independent; you can cd
 # into them and run `make' without going through this Makefile.
@@ -768,8 +775,7 @@ $(RECURSIVE_TARGETS):
 	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
 	fi; test -z "$$fail"
 
-mostlyclean-recursive clean-recursive distclean-recursive \
-maintainer-clean-recursive:
+$(RECURSIVE_CLEAN_TARGETS):
 	@failcom='exit 1'; \
 	for f in x $$MAKEFLAGS; do \
 	  case $$f in \
@@ -813,8 +819,8 @@ ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonemtpy = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	mkid -fID $$unique
 tags: TAGS
 
@@ -839,8 +845,8 @@ TAGS: tags-recursive $(HEADERS) $(SOURCE
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	if test -z "$(ETAGS_ARGS)$$tags$$unique"; then :; else \
 	  test -n "$$unique" || unique=$$empty_fix; \
 	  $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
@@ -850,13 +856,12 @@ ctags: CTAGS
 CTAGS: ctags-recursive $(HEADERS) $(SOURCES) config.in $(TAGS_DEPENDENCIES) \
 		$(TAGS_FILES) $(LISP)
 	tags=; \
-	here=`pwd`; \
 	list='$(SOURCES) $(HEADERS) config.in $(LISP) $(TAGS_FILES)'; \
 	unique=`for i in $$list; do \
 	    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
 	  done | \
-	  $(AWK) '    { files[$$0] = 1; } \
-	       END { for (i in files) print i; }'`; \
+	  $(AWK) '{ files[$$0] = 1; nonempty = 1; } \
+	      END { if (nonempty) { for (i in files) print i; }; }'`; \
 	test -z "$(CTAGS_ARGS)$$tags$$unique" \
 	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
 	     $$tags $$unique
@@ -874,7 +879,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRAR
 installdirs: installdirs-recursive
 installdirs-am:
 	for dir in "$(DESTDIR)$(bfdlibdir)"; do \
-	  test -z "$$dir" || $(mkdir_p) "$$dir"; \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
 	done
 install: install-recursive
 install-exec: install-exec-recursive
@@ -924,12 +929,18 @@ info-am:
 
 install-data-am: install-bfdlibLTLIBRARIES
 
+install-dvi: install-dvi-recursive
+
 install-exec-am:
 
 install-info: install-info-recursive
 
 install-man:
 
+install-pdf: install-pdf-recursive
+
+install-ps: install-ps-recursive
+
 installcheck-am:
 
 maintainer-clean: maintainer-clean-recursive
@@ -953,23 +964,25 @@ ps-am:
 
 uninstall-am: uninstall-bfdlibLTLIBRARIES
 
-uninstall-info: uninstall-info-recursive
+.MAKE: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) install-am \
+	install-strip
 
-.PHONY: $(RECURSIVE_TARGETS) CTAGS GTAGS all all-am am--refresh check \
-	check-am clean clean-bfdlibLTLIBRARIES clean-generic \
-	clean-libtool clean-noinstLIBRARIES clean-recursive ctags \
-	ctags-recursive distclean distclean-compile distclean-generic \
-	distclean-hdr distclean-libtool distclean-recursive \
-	distclean-tags dvi dvi-am html html-am info info-am install \
-	install-am install-bfdlibLTLIBRARIES install-data \
-	install-data-am install-exec install-exec-am install-info \
-	install-info-am install-man install-strip installcheck \
-	installcheck-am installdirs installdirs-am maintainer-clean \
-	maintainer-clean-generic maintainer-clean-recursive \
-	mostlyclean mostlyclean-compile mostlyclean-generic \
-	mostlyclean-libtool mostlyclean-recursive pdf pdf-am ps ps-am \
-	tags tags-recursive uninstall uninstall-am \
-	uninstall-bfdlibLTLIBRARIES uninstall-info-am
+.PHONY: $(RECURSIVE_CLEAN_TARGETS) $(RECURSIVE_TARGETS) CTAGS GTAGS \
+	all all-am am--refresh check check-am clean \
+	clean-bfdlibLTLIBRARIES clean-generic clean-libtool \
+	clean-noinstLIBRARIES ctags ctags-recursive distclean \
+	distclean-compile distclean-generic distclean-hdr \
+	distclean-libtool distclean-tags dvi dvi-am html html-am info \
+	info-am install install-am install-bfdlibLTLIBRARIES \
+	install-data install-data-am install-dvi install-dvi-am \
+	install-exec install-exec-am install-html install-html-am \
+	install-info install-info-am install-man install-pdf \
+	install-pdf-am install-ps install-ps-am install-strip \
+	installcheck installcheck-am installdirs installdirs-am \
+	maintainer-clean maintainer-clean-generic mostlyclean \
+	mostlyclean-compile mostlyclean-generic mostlyclean-libtool \
+	pdf pdf-am ps ps-am tags tags-recursive uninstall uninstall-am \
+	uninstall-bfdlibLTLIBRARIES
 
 
 .PHONY: install-html
@@ -1225,6 +1238,15 @@ avr-dis.lo: avr-dis.c sysdep.h config.h 
   $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h \
   opintl.h $(INCDIR)/libiberty.h $(INCDIR)/ansidecl.h \
   $(INCDIR)/opcode/avr.h
+avr32-asm.lo: avr32-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h opintl.h \
+  $(INCDIR)/xregex.h $(INCDIR)/xregex2.h \
+  $(INCDIR)/libiberty.h $(INCDIR)/safe-ctype.h
+avr32-dis.lo: avr32-dis.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(INCDIR)/dis-asm.h $(BFD_H) $(INCDIR)/symcat.h $(INCDIR)/libiberty.h \
+  avr32-opc.h opintl.h
+avr32-opc.lo: avr32-opc.c sysdep.h config.h $(INCDIR)/ansidecl.h \
+  $(BFD_H) $(INCDIR)/symcat.h avr32-opc.h $(INCDIR)/libiberty.h
 bfin-dis.lo: bfin-dis.c $(INCDIR)/opcode/bfin.h $(INCDIR)/dis-asm.h \
   $(BFD_H) $(INCDIR)/ansidecl.h $(INCDIR)/symcat.h
 cgen-asm.lo: cgen-asm.c sysdep.h config.h $(INCDIR)/ansidecl.h \
diff -Nrup gdb-6.7.1/serdep.tmp gdb-6.7.1-atmel/serdep.tmp
--- gdb-6.7.1/serdep.tmp	1970-01-01 01:00:00.000000000 +0100
+++ gdb-6.7.1-atmel/serdep.tmp	2008-04-03 15:01:55.000000000 +0200
@@ -0,0 +1 @@
+# serdep.tmp
