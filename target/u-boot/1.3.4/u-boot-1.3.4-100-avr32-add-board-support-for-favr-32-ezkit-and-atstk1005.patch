 CREDITS                                           |    4 +
 MAINTAINERS                                       |   16 +-
 MAKEALL                                           |    4 +
 Makefile                                          |   14 +-
 board/atmel/at91cap9adk/at91cap9adk.c             |   29 ++
 board/atmel/at91sam9261ek/at91sam9261ek.c         |   29 ++
 board/atmel/at91sam9263ek/at91sam9263ek.c         |   29 ++
 board/atmel/at91sam9rlek/at91sam9rlek.c           |   29 ++
 board/atmel/atngw100/Makefile                     |    2 +-
 board/atmel/atngw100/atngw100.c                   |   29 ++-
 board/atmel/atngw100/eth.c                        |   36 ---
 board/atmel/atstk1000/Makefile                    |   10 +-
 board/atmel/atstk1000/atstk1000.c                 |  156 ++++++++++-
 board/atmel/atstk1000/eth.c                       |   38 ---
 board/atmel/atstk1000/ltv350qv.c                  |  157 +++++++++++
 board/atmel/atstk1000/ltv350qv.h                  |   95 +++++++
 board/earthlcd/favr-32-ezkit/Makefile             |   42 +++
 board/earthlcd/favr-32-ezkit/config.mk            |    4 +
 board/earthlcd/favr-32-ezkit/favr-32-ezkit.c      |   97 +++++++
 board/earthlcd/favr-32-ezkit/flash.c              |  230 ++++++++++++++++
 board/earthlcd/favr-32-ezkit/u-boot.lds           |   71 +++++
 board/lwmon/lwmon.c                               |   29 ++
 board/mimc/mimc200/Makefile                       |   40 +++
 board/mimc/mimc200/config.mk                      |    3 +
 board/mimc/mimc200/mimc200.c                      |  162 +++++++++++
 board/mimc/mimc200/u-boot.lds                     |   73 +++++
 board/miromico/hammerhead/Makefile                |   40 +++
 board/miromico/hammerhead/config.mk               |    3 +
 board/miromico/hammerhead/hammerhead.c            |  110 ++++++++
 board/miromico/hammerhead/u-boot.lds              |   73 +++++
 board/tqc/tqm8xx/tqm8xx.c                         |   26 ++
 common/lcd.c                                      |  100 ++------
 cpu/at32ap/Makefile                               |    3 +-
 cpu/at32ap/at32ap700x/Makefile                    |    2 +-
 cpu/at32ap/at32ap700x/clk.c                       |   25 ++
 cpu/at32ap/at32ap700x/gpio.c                      |  199 --------------
 cpu/at32ap/at32ap700x/portmux.c                   |  218 +++++++++++++++
 cpu/at32ap/at32ap700x/sm.h                        |    2 +-
 cpu/at32ap/at32ap720x/Makefile                    |   44 +++
 cpu/at32ap/at32ap720x/clk.c                       |  118 ++++++++
 cpu/at32ap/at32ap720x/pm.h                        |  301 +++++++++++++++++++++
 cpu/at32ap/at32ap720x/portmux.c                   |  197 ++++++++++++++
 cpu/at32ap/at32ap720x/start.S                     |  151 +++++++++++
 cpu/at32ap/cpu.c                                  |    8 +-
 cpu/at32ap/pio.c                                  |  116 --------
 cpu/at32ap/portmux-gpio.c                         |  107 ++++++++
 cpu/at32ap/portmux-pio.c                          |   92 +++++++
 cpu/at32ap/start.S                                |    7 +-
 doc/README.AVR32                                  |   24 +--
 doc/README.AVR32-port-muxing                      |  208 ++++++++++++++
 drivers/mmc/atmel_mci.c                           |    2 +-
 drivers/serial/atmel_usart.c                      |   20 ++-
 drivers/serial/atmel_usart.h                      |    2 +
 drivers/video/atmel_lcdfb.c                       |    6 +-
 examples/stubs.c                                  |    7 +-
 include/asm-arm/arch-at91sam9/gpio.h              |    1 +
 include/asm-avr32/arch-at32ap700x/chip-features.h |    5 +
 include/asm-avr32/arch-at32ap700x/clk.h           |  109 ++++++++-
 include/asm-avr32/arch-at32ap700x/gpio.h          |  184 +------------
 include/asm-avr32/arch-at32ap700x/portmux.h       |   92 +++++++
 include/asm-avr32/arch-at32ap720x/clk.h           |  232 ++++++++++++++++
 include/asm-avr32/arch-at32ap720x/gpio.h          |   44 +++
 include/asm-avr32/arch-at32ap720x/hmatrix.h       |   69 +++++
 include/asm-avr32/arch-at32ap720x/memory-map.h    |  101 +++++++
 include/asm-avr32/arch-at32ap720x/mmc.h           |   77 ++++++
 include/asm-avr32/arch-at32ap720x/portmux.h       |  100 +++++++
 include/asm-avr32/arch-common/portmux-gpio.h      |  193 +++++++++++++
 include/asm-avr32/arch-common/portmux-pio.h       |  138 ++++++++++
 include/asm-avr32/global_data.h                   |    1 +
 include/asm-avr32/initcalls.h                     |    1 -
 include/asm-avr32/sdram.h                         |    4 +-
 include/common.h                                  |    4 +-
 include/configs/atngw100.h                        |    2 +-
 include/configs/atstk1002.h                       |   27 ++-
 include/configs/atstk1003.h                       |    2 +-
 include/configs/atstk1004.h                       |    2 +-
 include/configs/atstk1005.h                       |  207 ++++++++++++++
 include/configs/atstk1006.h                       |   28 ++-
 include/configs/favr-32-ezkit.h                   |  201 ++++++++++++++
 include/configs/hammerhead.h                      |  172 ++++++++++++
 include/configs/mimc200.h                         |  177 ++++++++++++
 include/lcd.h                                     |    2 +
 include/spi.h                                     |   15 +-
 lib_arm/board.c                                   |   13 -
 lib_avr32/board.c                                 |   29 ++-
 lib_generic/Makefile                              |    1 +
 lib_generic/strmhz.c                              |   36 +++
 lib_i386/board.c                                  |   13 -
 lib_m68k/board.c                                  |   17 --
 lib_ppc/board.c                                   |   13 -
 net/eth.c                                         |    8 -
 91 files changed, 5178 insertions(+), 781 deletions(-)
 delete mode 100644 board/atmel/atngw100/eth.c
 delete mode 100644 board/atmel/atstk1000/eth.c
 create mode 100644 board/atmel/atstk1000/ltv350qv.c
 create mode 100644 board/atmel/atstk1000/ltv350qv.h
 create mode 100644 board/earthlcd/favr-32-ezkit/Makefile
 create mode 100644 board/earthlcd/favr-32-ezkit/config.mk
 create mode 100644 board/earthlcd/favr-32-ezkit/favr-32-ezkit.c
 create mode 100644 board/earthlcd/favr-32-ezkit/flash.c
 create mode 100644 board/earthlcd/favr-32-ezkit/u-boot.lds
 create mode 100644 board/mimc/mimc200/Makefile
 create mode 100644 board/mimc/mimc200/config.mk
 create mode 100644 board/mimc/mimc200/mimc200.c
 create mode 100644 board/mimc/mimc200/u-boot.lds
 create mode 100644 board/miromico/hammerhead/Makefile
 create mode 100644 board/miromico/hammerhead/config.mk
 create mode 100644 board/miromico/hammerhead/hammerhead.c
 create mode 100644 board/miromico/hammerhead/u-boot.lds
 delete mode 100644 cpu/at32ap/at32ap700x/gpio.c
 create mode 100644 cpu/at32ap/at32ap700x/portmux.c
 create mode 100644 cpu/at32ap/at32ap720x/Makefile
 create mode 100644 cpu/at32ap/at32ap720x/clk.c
 create mode 100644 cpu/at32ap/at32ap720x/pm.h
 create mode 100644 cpu/at32ap/at32ap720x/portmux.c
 create mode 100644 cpu/at32ap/at32ap720x/start.S
 delete mode 100644 cpu/at32ap/pio.c
 create mode 100644 cpu/at32ap/portmux-gpio.c
 create mode 100644 cpu/at32ap/portmux-pio.c
 create mode 100644 doc/README.AVR32-port-muxing
 create mode 100644 include/asm-avr32/arch-at32ap700x/portmux.h
 create mode 100644 include/asm-avr32/arch-at32ap720x/clk.h
 create mode 100644 include/asm-avr32/arch-at32ap720x/gpio.h
 create mode 100644 include/asm-avr32/arch-at32ap720x/hmatrix.h
 create mode 100644 include/asm-avr32/arch-at32ap720x/memory-map.h
 create mode 100644 include/asm-avr32/arch-at32ap720x/mmc.h
 create mode 100644 include/asm-avr32/arch-at32ap720x/portmux.h
 create mode 100644 include/asm-avr32/arch-common/portmux-gpio.h
 create mode 100644 include/asm-avr32/arch-common/portmux-pio.h
 create mode 100644 include/configs/atstk1005.h
 create mode 100644 include/configs/favr-32-ezkit.h
 create mode 100644 include/configs/hammerhead.h
 create mode 100644 include/configs/mimc200.h
 create mode 100644 lib_generic/strmhz.c

diff --git a/CREDITS b/CREDITS
index 2b0dab7..5010c78 100644
--- a/CREDITS
+++ b/CREDITS
@@ -217,6 +217,10 @@ H: Rich Ireland
 E: r.ireland@computer.org
 D: FPGA device configuration driver
 
+H: Mark Jackson
+E: mpfj@mimc.co.uk
+D: Port to MIMC200 board
+
 N: Gary Jennejohn
 E: garyj@jennejohn.org, gj@denx.de
 D: Support for Samsung ARM920T S3C2400X, ARM920T "TRAB"
diff --git a/MAINTAINERS b/MAINTAINERS
index 777d141..19e9cc3 100644
--- a/MAINTAINERS
+++ b/MAINTAINERS
@@ -704,12 +704,26 @@ TsiChung Liew <Tsi-Chung.Liew@freescale.com>
 #	Board		CPU						#
 #########################################################################
 
-Haavard Skinnemoen <hskinnemoen@atmel.com>
+Hans-Christian Egtvedt <hans-christian.egtvedt@atmel.com>
+
+	FAVR-32-EZKIT		AT32AP7000
+
+Mark Jackson <mpfj@mimc.co.uk>
+
+	MIMC200			AT32AP7000
+
+Alex Raimondi <alex.raimondi@miromico.ch>
+Julien May <julien.may@miromico.ch>
+
+	HAMMERHEAD		AT32AP7000
+
+Haavard Skinnemoen <haavard.skinnemoen@atmel.com>
 
 	ATSTK1000	AT32AP7xxx
 	ATSTK1002	AT32AP7000
 	ATSTK1003	AT32AP7001
 	ATSTK1004	AT32AP7002
+	ATSTK1005		AT32AP7200
 	ATSTK1006	AT32AP7000
 	ATNGW100	AT32AP7000
 
diff --git a/MAKEALL b/MAKEALL
index ee83cca..fb10afa 100755
--- a/MAKEALL
+++ b/MAKEALL
@@ -712,8 +712,12 @@ LIST_avr32="		\
 	atstk1002	\
 	atstk1003	\
 	atstk1004	\
+	atstk1005	\
 	atstk1006	\
 	atngw100	\
+	favr-32-ezkit	\
+	hammerhead	\
+	mimc200		\
 "
 
 #########################################################################
diff --git a/Makefile b/Makefile
index 082b08e..6aeabe4 100644
--- a/Makefile
+++ b/Makefile
@@ -24,7 +24,7 @@
 VERSION = 1
 PATCHLEVEL = 3
 SUBLEVEL = 4
-EXTRAVERSION =
+EXTRAVERSION = -atmel.buildroot.1
 U_BOOT_VERSION = $(VERSION).$(PATCHLEVEL).$(SUBLEVEL)$(EXTRAVERSION)
 VERSION_FILE = $(obj)include/version_autogenerated.h
 
@@ -2908,9 +2908,21 @@ atstk1003_config	:	unconfig
 atstk1004_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap700x
 
+atstk1005_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap720x
+
 atstk1006_config	:	unconfig
 	@$(MKCONFIG) $(@:_config=) avr32 at32ap atstk1000 atmel at32ap700x
 
+favr-32-ezkit_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap favr-32-ezkit earthlcd at32ap700x
+
+hammerhead_config	:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap hammerhead miromico at32ap700x
+
+mimc200_config		:	unconfig
+	@$(MKCONFIG) $(@:_config=) avr32 at32ap mimc200 mimc at32ap700x
+
 #========================================================================
 # SH3 (SuperH)
 #========================================================================
diff --git a/board/atmel/at91cap9adk/at91cap9adk.c b/board/atmel/at91cap9adk/at91cap9adk.c
index c5082a0..31f468a 100644
--- a/board/atmel/at91cap9adk/at91cap9adk.c
+++ b/board/atmel/at91cap9adk/at91cap9adk.c
@@ -324,6 +324,35 @@ static void at91cap9_lcd_hw_init(void)
 
 	gd->fb_base = 0;
 }
+
+#ifdef CONFIG_LCD_INFO
+#include <nand.h>
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	ulong dram_size, nand_size;
+	int i;
+	char temp[32];
+
+	lcd_printf ("%s\n", U_BOOT_VERSION);
+	lcd_printf ("(C) 2008 ATMEL Corp\n");
+	lcd_printf ("at91support@atmel.com\n");
+	lcd_printf ("%s CPU at %s MHz\n",
+		AT91_CPU_NAME,
+		strmhz(temp, AT91_MAIN_CLOCK));
+
+	dram_size = 0;
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	nand_size = 0;
+	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
+		nand_size += nand_info[i].size;
+	lcd_printf ("  %ld MB SDRAM, %ld MB NAND\n",
+		dram_size >> 20,
+		nand_size >> 20 );
+}
+#endif /* CONFIG_LCD_INFO */
 #endif
 
 int board_init(void)
diff --git a/board/atmel/at91sam9261ek/at91sam9261ek.c b/board/atmel/at91sam9261ek/at91sam9261ek.c
index 647aab5..5a48ee4 100644
--- a/board/atmel/at91sam9261ek/at91sam9261ek.c
+++ b/board/atmel/at91sam9261ek/at91sam9261ek.c
@@ -209,6 +209,35 @@ static void at91sam9261ek_lcd_hw_init(void)
 
 	gd->fb_base = AT91SAM9261_SRAM_BASE;
 }
+
+#ifdef CONFIG_LCD_INFO
+#include <nand.h>
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	ulong dram_size, nand_size;
+	int i;
+	char temp[32];
+
+	lcd_printf ("%s\n", U_BOOT_VERSION);
+	lcd_printf ("(C) 2008 ATMEL Corp\n");
+	lcd_printf ("at91support@atmel.com\n");
+	lcd_printf ("%s CPU at %s MHz\n",
+		AT91_CPU_NAME,
+		strmhz(temp, AT91_MAIN_CLOCK));
+
+	dram_size = 0;
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	nand_size = 0;
+	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
+		nand_size += nand_info[i].size;
+	lcd_printf ("  %ld MB SDRAM, %ld MB NAND\n",
+		dram_size >> 20,
+		nand_size >> 20 );
+}
+#endif /* CONFIG_LCD_INFO */
 #endif
 
 int board_init(void)
diff --git a/board/atmel/at91sam9263ek/at91sam9263ek.c b/board/atmel/at91sam9263ek/at91sam9263ek.c
index 927fc91..84db2c5 100644
--- a/board/atmel/at91sam9263ek/at91sam9263ek.c
+++ b/board/atmel/at91sam9263ek/at91sam9263ek.c
@@ -258,6 +258,35 @@ static void at91sam9263ek_lcd_hw_init(void)
 
 	gd->fb_base = AT91SAM9263_SRAM0_BASE;
 }
+
+#ifdef CONFIG_LCD_INFO
+#include <nand.h>
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	ulong dram_size, nand_size;
+	int i;
+	char temp[32];
+
+	lcd_printf ("%s\n", U_BOOT_VERSION);
+	lcd_printf ("(C) 2008 ATMEL Corp\n");
+	lcd_printf ("at91support@atmel.com\n");
+	lcd_printf ("%s CPU at %s MHz\n",
+		AT91_CPU_NAME,
+		strmhz(temp, AT91_MAIN_CLOCK));
+
+	dram_size = 0;
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	nand_size = 0;
+	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
+		nand_size += nand_info[i].size;
+	lcd_printf ("  %ld MB SDRAM, %ld MB NAND\n",
+		dram_size >> 20,
+		nand_size >> 20 );
+}
+#endif /* CONFIG_LCD_INFO */
 #endif
 
 int board_init(void)
diff --git a/board/atmel/at91sam9rlek/at91sam9rlek.c b/board/atmel/at91sam9rlek/at91sam9rlek.c
index 509e7c3..22115e5 100644
--- a/board/atmel/at91sam9rlek/at91sam9rlek.c
+++ b/board/atmel/at91sam9rlek/at91sam9rlek.c
@@ -181,6 +181,35 @@ static void at91sam9rlek_lcd_hw_init(void)
 
 	gd->fb_base = 0;
 }
+
+#ifdef CONFIG_LCD_INFO
+#include <nand.h>
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	ulong dram_size, nand_size;
+	int i;
+	char temp[32];
+
+	lcd_printf ("%s\n", U_BOOT_VERSION);
+	lcd_printf ("(C) 2008 ATMEL Corp\n");
+	lcd_printf ("at91support@atmel.com\n");
+	lcd_printf ("%s CPU at %s MHz\n",
+		AT91_CPU_NAME,
+		strmhz(temp, AT91_MAIN_CLOCK));
+
+	dram_size = 0;
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	nand_size = 0;
+	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
+		nand_size += nand_info[i].size;
+	lcd_printf ("  %ld MB SDRAM, %ld MB NAND\n",
+		dram_size >> 20,
+		nand_size >> 20 );
+}
+#endif /* CONFIG_LCD_INFO */
 #endif
 
 
diff --git a/board/atmel/atngw100/Makefile b/board/atmel/atngw100/Makefile
index 1b5c635..9f3849f 100644
--- a/board/atmel/atngw100/Makefile
+++ b/board/atmel/atngw100/Makefile
@@ -22,7 +22,7 @@ include $(TOPDIR)/config.mk
 
 LIB	:= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o eth.o
+COBJS	:= $(BOARD).o
 
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
diff --git a/board/atmel/atngw100/atngw100.c b/board/atmel/atngw100/atngw100.c
index 4ead533..480d525 100644
--- a/board/atmel/atngw100/atngw100.c
+++ b/board/atmel/atngw100/atngw100.c
@@ -26,6 +26,7 @@
 #include <asm/arch/clk.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/hmatrix.h>
+#include <asm/arch/portmux.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
@@ -50,18 +51,18 @@ int board_early_init_f(void)
 	/* Enable SDRAM in the EBI mux */
 	hmatrix_slave_write(EBI, SFR, HMATRIX_BIT(EBI_SDRAM_ENABLE));
 
-	gpio_enable_ebi();
-	gpio_enable_usart1();
+	portmux_enable_ebi(16, 23, 0, PORTMUX_DRIVE_HIGH);
+	portmux_enable_usart1(PORTMUX_DRIVE_MIN);
 
 #if defined(CONFIG_MACB)
-	gpio_enable_macb0();
-	gpio_enable_macb1();
+	portmux_enable_macb0(PORTMUX_MACB_MII, PORTMUX_DRIVE_HIGH);
+	portmux_enable_macb1(PORTMUX_MACB_MII, PORTMUX_DRIVE_HIGH);
 #endif
 #if defined(CONFIG_MMC)
-	gpio_enable_mmci();
+	portmux_enable_mmci(0, PORTMUX_MMCI_4BIT, PORTMUX_DRIVE_LOW);
 #endif
 #if defined(CONFIG_ATMEL_SPI)
-	gpio_enable_spi0(1 << 0);
+	portmux_enable_spi0(1 << 0, PORTMUX_DRIVE_LOW);
 #endif
 
 	return 0;
@@ -87,17 +88,29 @@ phys_size_t initdram(int board_type)
 	return actual_size;
 }
 
-void board_init_info(void)
+int board_early_init_r(void)
 {
 	gd->bd->bi_phy_id[0] = 0x01;
 	gd->bd->bi_phy_id[1] = 0x03;
+	return 0;
 }
 
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bi)
+{
+	macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
+	macb_eth_initialize(1, (void *)MACB1_BASE, bi->bi_phy_id[1]);
+	return 0;
+}
+#endif
+
 /* SPI chip select control */
 #ifdef CONFIG_ATMEL_SPI
 #include <spi.h>
 
-#define ATNGW100_DATAFLASH_CS_PIN	GPIO_PIN_PA3
+#define ATNGW100_DATAFLASH_CS_PIN	GPIO_PIN_PA(3)
 
 int spi_cs_is_valid(unsigned int bus, unsigned int cs)
 {
diff --git a/board/atmel/atngw100/eth.c b/board/atmel/atngw100/eth.c
deleted file mode 100644
index d1d57bb..0000000
--- a/board/atmel/atngw100/eth.c
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (C) 2006 Atmel Corporation
- *
- * Ethernet initialization for the AVR32 Network Gateway
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-
-#include <asm/arch/memory-map.h>
-
-extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
-
-#ifdef CONFIG_CMD_NET
-void atngw100_eth_initialize(bd_t *bi)
-{
-	macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
-	macb_eth_initialize(1, (void *)MACB1_BASE, bi->bi_phy_id[1]);
-}
-#endif
diff --git a/board/atmel/atstk1000/Makefile b/board/atmel/atstk1000/Makefile
index 8a15713..8d4f32c 100644
--- a/board/atmel/atstk1000/Makefile
+++ b/board/atmel/atstk1000/Makefile
@@ -24,12 +24,14 @@
 
 include $(TOPDIR)/config.mk
 
-LIB	:= $(obj)lib$(BOARD).a
+LIB			:= $(obj)lib$(BOARD).a
 
-COBJS	:= $(BOARD).o flash.o eth.o
+COBJS-y			+= $(BOARD).o
+COBJS-y			+= flash.o
+COBJS-$(CONFIG_LCD)	+= ltv350qv.o
 
-SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
-OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+SRCS			:= $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
+OBJS			:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
 
 $(LIB): $(obj).depend $(OBJS)
 	$(AR) $(ARFLAGS) $@ $(OBJS)
diff --git a/board/atmel/atstk1000/atstk1000.c b/board/atmel/atstk1000/atstk1000.c
index d284fc1..ddc01d4 100644
--- a/board/atmel/atstk1000/atstk1000.c
+++ b/board/atmel/atstk1000/atstk1000.c
@@ -26,12 +26,13 @@
 #include <asm/arch/clk.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/hmatrix.h>
+#include <asm/arch/portmux.h>
 
 DECLARE_GLOBAL_DATA_PTR;
 
 static const struct sdram_config sdram_config = {
-#if defined(CONFIG_ATSTK1006)
-	/* Dual MT48LC16M16A2-7E (64 MB) on daughterboard */
+#if defined(CONFIG_ATSTK1005) || defined(CONFIG_ATSTK1006)
+	/* Dual MT48LC16M16A2-75 (64 MB) on daughterboard */
 	.data_bits	= SDRAM_DATA_32BIT,
 	.row_bits	= 13,
 	.col_bits	= 9,
@@ -41,7 +42,7 @@ static const struct sdram_config sdram_config = {
 	.trc		= 7,
 	.trp		= 2,
 	.trcd		= 2,
-	.tras		= 4,
+	.tras		= 5,
 	.txsr		= 7,
 	/* 7.81 us */
 	.refresh_period	= (781 * (SDRAMC_BUS_HZ / 1000)) / 100000,
@@ -72,19 +73,89 @@ static const struct sdram_config sdram_config = {
 #endif
 };
 
+#ifdef CONFIG_LCD
+#include <lcd.h>
+#include <atmel_lcdc.h>
+
+vidinfo_t panel_info = {
+	.vl_col			= 320,
+	.vl_row			= 240,
+	.vl_clk			= 6891000,
+	.vl_sync		= ATMEL_LCDC_INVCLK_INVERTED
+					| ATMEL_LCDC_INVFRAME_INVERTED
+					| ATMEL_LCDC_INVLINE_INVERTED,
+	.vl_bpix		= LCD_BPP,
+	.vl_tft			= 1,
+	.vl_hsync_len		= 16,
+	.vl_left_margin		= 17,
+	.vl_right_margin	= 33,
+	.vl_vsync_len		= 1,
+	.vl_upper_margin	= 10,
+	.vl_lower_margin	= 10,
+	.mmio			= LCDC_BASE,
+};
+
+#ifdef CONFIG_LCD_INFO
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	unsigned int i;
+	unsigned long dram_size = 0;
+	char mhz[32];
+
+	lcd_printf("%s\n", U_BOOT_VERSION);
+	lcd_printf("%s (C) 2008 Atmel Corporation\n", CFG_BOARD_NAME);
+	lcd_printf("%s CPU at %s MHz\n", CFG_CPU_NAME, strmhz(mhz, gd->cpu_hz));
+	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
+		dram_size += gd->bd->bi_dram[i].size;
+	lcd_printf("  %ld MiB SDRAM, %ld MiB Flash\n",
+			dram_size >> 20, gd->bd->bi_flashsize >> 20);
+}
+#endif
+
+int board_postclk_init(void)
+{
+	gclk_set_rate(GCLK_LCDC_PIXCLK, GCLK_PARENT_PLL0,
+			CONFIG_LCDC_PIXCLK_RATE);
+	return 0;
+}
+#endif
+
 int board_early_init_f(void)
 {
+	unsigned int spi_cs_mask = 0;
+
 	/* Enable SDRAM in the EBI mux */
 	hmatrix_slave_write(EBI, SFR, HMATRIX_BIT(EBI_SDRAM_ENABLE));
 
-	gpio_enable_ebi();
-	gpio_enable_usart1();
-#if defined(CONFIG_MACB)
-	gpio_enable_macb0();
-	gpio_enable_macb1();
+	portmux_enable_ebi(sdram_config.data_bits, 23, 0, PORTMUX_DRIVE_HIGH);
+#if defined(CONFIG_ATSTK1005)
+	portmux_enable_usart4(PORTMUX_DRIVE_MIN);
+#else
+	portmux_enable_usart1(PORTMUX_DRIVE_MIN);
+#endif
+#if defined(CONFIG_ATSTK1000_MACB0)
+	portmux_enable_macb0(PORTMUX_MACB_MII, PORTMUX_DRIVE_LOW);
+#endif
+#if defined(CONFIG_ATSTK1000_MACB1)
+	portmux_enable_macb1(PORTMUX_MACB_MII, PORTMUX_DRIVE_LOW);
 #endif
 #if defined(CONFIG_MMC)
-	gpio_enable_mmci();
+	portmux_enable_mmci(0, PORTMUX_MMCI_4BIT, PORTMUX_DRIVE_LOW);
+#endif
+#if defined(CONFIG_ATMEL_SPI)
+#if defined(CONFIG_SPI_FLASH)
+	spi_cs_mask |= 1 << CFG_SPI_FLASH_NPCS;
+#endif
+#if defined(CONFIG_LCD)
+	spi_cs_mask |= 1 << CFG_LCD_NPCS;
+#endif
+#endif
+	if (spi_cs_mask)
+		portmux_enable_spi0(spi_cs_mask, PORTMUX_DRIVE_LOW);
+#if defined(CONFIG_LCD)
+	portmux_enable_lcdc();
 #endif
 
 	return 0;
@@ -110,8 +181,73 @@ phys_size_t initdram(int board_type)
 	return actual_size;
 }
 
-void board_init_info(void)
+int board_early_init_r(void)
 {
 	gd->bd->bi_phy_id[0] = 0x10;
 	gd->bd->bi_phy_id[1] = 0x11;
+	return 0;
+}
+
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bi)
+{
+#ifdef CONFIG_ATSTK1000_MACB0
+	macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
+#endif
+#ifdef CONFIG_ATSTK1000_MACB1
+	macb_eth_initialize(1, (void *)MACB1_BASE, bi->bi_phy_id[1]);
+#endif
+	return 0;
+}
+#endif
+
+#ifdef CONFIG_ATMEL_SPI
+#include <spi.h>
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+#if defined(CONFIG_LCD)
+	if (bus == 0 && cs == CFG_LCD_NPCS)
+		return 1;
+#endif
+#if defined(CONFIG_SPI_FLASH)
+	if (bus == 0 && cs == CFG_SPI_FLASH_NPCS)
+		return 1;
+#endif
+	return 0;
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+#ifdef CONFIG_SPI_FLASH
+	case CFG_SPI_FLASH_NPCS:
+		gpio_set_value(CFG_SPI_FLASH_NPCS_PIN, 0);
+		break;
+#endif
+#ifdef CONFIG_LCD
+	case CFG_LCD_NPCS:
+		gpio_set_value(CFG_LCD_NPCS_PIN, 0);
+		break;
+#endif
+	}
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+	switch (slave->cs) {
+#ifdef CONFIG_SPI_FLASH
+	case CFG_SPI_FLASH_NPCS:
+		gpio_set_value(CFG_SPI_FLASH_NPCS_PIN, 1);
+		break;
+#endif
+#ifdef CONFIG_LCD
+	case CFG_LCD_NPCS:
+		gpio_set_value(CFG_LCD_NPCS_PIN, 1);
+		break;
+#endif
+	}
 }
+#endif /* CONFIG_ATMEL_SPI */
diff --git a/board/atmel/atstk1000/eth.c b/board/atmel/atstk1000/eth.c
deleted file mode 100644
index b2b1a12..0000000
--- a/board/atmel/atstk1000/eth.c
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (C) 2005-2006 Atmel Corporation
- *
- * Ethernet initialization for the ATSTK1000 starterkit
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-
-#include <asm/arch/memory-map.h>
-
-extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
-
-#if defined(CONFIG_MACB) && defined(CONFIG_CMD_NET)
-void atstk1000_eth_initialize(bd_t *bi)
-{
-	int id = 0;
-
-	macb_eth_initialize(id++, (void *)MACB0_BASE, bi->bi_phy_id[0]);
-	macb_eth_initialize(id++, (void *)MACB1_BASE, bi->bi_phy_id[1]);
-}
-#endif
diff --git a/board/atmel/atstk1000/ltv350qv.c b/board/atmel/atstk1000/ltv350qv.c
new file mode 100644
index 0000000..5ea6793
--- /dev/null
+++ b/board/atmel/atstk1000/ltv350qv.c
@@ -0,0 +1,157 @@
+/*
+ * Power control for Samsung LTV350QV Quarter VGA LCD Panel
+ *
+ * Copyright (C) 2006, 2007 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <common.h>
+#include <lcd.h>
+#include <spi.h>
+
+#include "ltv350qv.h"
+
+/*
+ * The power-on and power-off sequences are taken from the
+ * LTV350QV-F04 data sheet from Samsung. The register definitions are
+ * taken from the S6F2002 command list also from Samsung. Both
+ * documents are distributed with the AVR32 Linux BSP CD from Atmel.
+ *
+ * There's still some voodoo going on here, but it's a lot better than
+ * in the first incarnation of the driver where all we had was the raw
+ * numbers from the initialization sequence.
+ */
+static int ltv350qv_write_reg(struct spi_slave *spi, u8 reg, u16 val)
+{
+	int	ret;
+	u8	buffer[3];
+
+	/* register index */
+	buffer[0] = LTV_OPC_INDEX;
+	buffer[1] = 0x00;
+	buffer[2] = reg & 0x7f;
+
+	ret = spi_xfer_single(spi, 8 * 3, buffer, NULL);
+	if (ret)
+		return ret;
+
+	/* register value */
+	buffer[0] = LTV_OPC_DATA;
+	buffer[1] = val >> 8;
+	buffer[2] = val;
+
+	return spi_xfer_single(spi, 8 * 3, buffer, NULL);
+}
+
+/* The comments are taken straight from the data sheet */
+static int ltv350qv_power_on(struct spi_slave *spi)
+{
+	int ret;
+
+	spi_claim_bus(spi);
+
+	/* Power On Reset Display off State */
+	if (ltv350qv_write_reg(spi, LTV_PWRCTL1, 0x0000))
+		goto err;
+	udelay(15000);
+
+	/* Power Setting Function 1 */
+	if (ltv350qv_write_reg(spi, LTV_PWRCTL1, LTV_VCOM_DISABLE))
+		goto err;
+	if (ltv350qv_write_reg(spi, LTV_PWRCTL2, LTV_VCOML_ENABLE))
+		goto err_power1;
+
+	/* Power Setting Function 2 */
+	if (ltv350qv_write_reg(spi, LTV_PWRCTL1,
+			       LTV_VCOM_DISABLE | LTV_DRIVE_CURRENT(5)
+			       | LTV_SUPPLY_CURRENT(5)))
+		goto err_power2;
+
+	udelay(55000);
+
+	/* Instruction Setting */
+	ret = ltv350qv_write_reg(spi, LTV_IFCTL,
+				 LTV_NMD | LTV_REV | LTV_NL(0x1d));
+	ret |= ltv350qv_write_reg(spi, LTV_DATACTL,
+				  LTV_DS_SAME | LTV_CHS_480
+				  | LTV_DF_RGB | LTV_RGB_BGR);
+	ret |= ltv350qv_write_reg(spi, LTV_ENTRY_MODE,
+				  LTV_VSPL_ACTIVE_LOW
+				  | LTV_HSPL_ACTIVE_LOW
+				  | LTV_DPL_SAMPLE_RISING
+				  | LTV_EPL_ACTIVE_LOW
+				  | LTV_SS_RIGHT_TO_LEFT);
+	ret |= ltv350qv_write_reg(spi, LTV_GATECTL1, LTV_CLW(3));
+	ret |= ltv350qv_write_reg(spi, LTV_GATECTL2,
+				  LTV_NW_INV_1LINE | LTV_FWI(3));
+	ret |= ltv350qv_write_reg(spi, LTV_VBP, 0x000a);
+	ret |= ltv350qv_write_reg(spi, LTV_HBP, 0x0021);
+	ret |= ltv350qv_write_reg(spi, LTV_SOTCTL, LTV_SDT(3) | LTV_EQ(0));
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(0), 0x0103);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(1), 0x0301);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(2), 0x1f0f);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(3), 0x1f0f);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(4), 0x0707);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(5), 0x0307);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(6), 0x0707);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(7), 0x0000);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(8), 0x0004);
+	ret |= ltv350qv_write_reg(spi, LTV_GAMMA(9), 0x0000);
+	if (ret)
+		goto err_settings;
+
+	/* Wait more than 2 frames */
+	udelay(20000);
+
+	/* Display On Sequence */
+	ret = ltv350qv_write_reg(spi, LTV_PWRCTL1,
+				 LTV_VCOM_DISABLE | LTV_VCOMOUT_ENABLE
+				 | LTV_POWER_ON | LTV_DRIVE_CURRENT(5)
+				 | LTV_SUPPLY_CURRENT(5));
+	ret |= ltv350qv_write_reg(spi, LTV_GATECTL2,
+				  LTV_NW_INV_1LINE | LTV_DSC | LTV_FWI(3));
+	if (ret)
+		goto err_disp_on;
+
+	/* Display should now be ON. Phew. */
+	spi_release_bus(spi);
+	return 0;
+
+err_disp_on:
+	/*
+	 * Try to recover. Error handling probably isn't very useful
+	 * at this point, just make a best effort to switch the panel
+	 * off.
+	 */
+	ltv350qv_write_reg(spi, LTV_PWRCTL1,
+			   LTV_VCOM_DISABLE | LTV_DRIVE_CURRENT(5)
+			   | LTV_SUPPLY_CURRENT(5));
+	ltv350qv_write_reg(spi, LTV_GATECTL2,
+			   LTV_NW_INV_1LINE | LTV_FWI(3));
+err_settings:
+err_power2:
+err_power1:
+	ltv350qv_write_reg(spi, LTV_PWRCTL2, 0x0000);
+	udelay(1000);
+err:
+	ltv350qv_write_reg(spi, LTV_PWRCTL1, LTV_VCOM_DISABLE);
+	spi_release_bus(spi);
+	return -1;
+}
+
+void lcd_enable(void)
+{
+	struct spi_slave *spi;
+	int ret = -1;
+
+	spi = spi_setup_slave(0, CFG_LCD_NPCS, 800000, SPI_MODE_3);
+	if (spi) {
+		ret = ltv350qv_power_on(spi);
+		spi_free_slave(spi);
+	}
+
+	if (ret)
+		puts("ATSTK1000: Failed to power on LCD panel\n");
+}
diff --git a/board/atmel/atstk1000/ltv350qv.h b/board/atmel/atstk1000/ltv350qv.h
new file mode 100644
index 0000000..189112e
--- /dev/null
+++ b/board/atmel/atstk1000/ltv350qv.h
@@ -0,0 +1,95 @@
+/*
+ * Register definitions for Samsung LTV350QV Quarter VGA LCD Panel
+ *
+ * Copyright (C) 2006, 2007 Atmel Corporation
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef __LTV350QV_H
+#define __LTV350QV_H
+
+#define LTV_OPC_INDEX	0x74
+#define LTV_OPC_DATA	0x76
+
+#define LTV_ID		0x00		/* ID Read */
+#define LTV_IFCTL	0x01		/* Display Interface Control */
+#define LTV_DATACTL	0x02		/* Display Data Control */
+#define LTV_ENTRY_MODE	0x03		/* Entry Mode */
+#define LTV_GATECTL1	0x04		/* Gate Control 1 */
+#define LTV_GATECTL2	0x05		/* Gate Control 2 */
+#define LTV_VBP		0x06		/* Vertical Back Porch */
+#define LTV_HBP		0x07		/* Horizontal Back Porch */
+#define LTV_SOTCTL	0x08		/* Source Output Timing Control */
+#define LTV_PWRCTL1	0x09		/* Power Control 1 */
+#define LTV_PWRCTL2	0x0a		/* Power Control 2 */
+#define LTV_GAMMA(x)	(0x10 + (x))	/* Gamma control */
+
+/* Bit definitions for LTV_IFCTL */
+#define LTV_IM			(1 << 15)
+#define LTV_NMD			(1 << 14)
+#define LTV_SSMD		(1 << 13)
+#define LTV_REV			(1 <<  7)
+#define LTV_NL(x)		(((x) & 0x001f) << 0)
+
+/* Bit definitions for LTV_DATACTL */
+#define LTV_DS_SAME		(0 << 12)
+#define LTV_DS_D_TO_S		(1 << 12)
+#define LTV_DS_S_TO_D		(2 << 12)
+#define LTV_CHS_384		(0 <<  9)
+#define LTV_CHS_480		(1 <<  9)
+#define LTV_CHS_492		(2 <<  9)
+#define LTV_DF_RGB		(0 <<  6)
+#define LTV_DF_RGBX		(1 <<  6)
+#define LTV_DF_XRGB		(2 <<  6)
+#define LTV_RGB_RGB		(0 <<  2)
+#define LTV_RGB_BGR		(1 <<  2)
+#define LTV_RGB_GRB		(2 <<  2)
+#define LTV_RGB_RBG		(3 <<  2)
+
+/* Bit definitions for LTV_ENTRY_MODE */
+#define LTV_VSPL_ACTIVE_LOW	(0 << 15)
+#define LTV_VSPL_ACTIVE_HIGH	(1 << 15)
+#define LTV_HSPL_ACTIVE_LOW	(0 << 14)
+#define LTV_HSPL_ACTIVE_HIGH	(1 << 14)
+#define LTV_DPL_SAMPLE_RISING	(0 << 13)
+#define LTV_DPL_SAMPLE_FALLING	(1 << 13)
+#define LTV_EPL_ACTIVE_LOW	(0 << 12)
+#define LTV_EPL_ACTIVE_HIGH	(1 << 12)
+#define LTV_SS_LEFT_TO_RIGHT	(0 <<  8)
+#define LTV_SS_RIGHT_TO_LEFT	(1 <<  8)
+#define LTV_STB			(1 <<  1)
+
+/* Bit definitions for LTV_GATECTL1 */
+#define LTV_CLW(x)		(((x) & 0x0007) << 12)
+#define LTV_GAON		(1 <<  5)
+#define LTV_SDR			(1 <<  3)
+
+/* Bit definitions for LTV_GATECTL2 */
+#define LTV_NW_INV_FRAME	(0 << 14)
+#define LTV_NW_INV_1LINE	(1 << 14)
+#define LTV_NW_INV_2LINE	(2 << 14)
+#define LTV_DSC			(1 << 12)
+#define LTV_GIF			(1 <<  8)
+#define LTV_FHN			(1 <<  7)
+#define LTV_FTI(x)		(((x) & 0x0003) << 4)
+#define LTV_FWI(x)		(((x) & 0x0003) << 0)
+
+/* Bit definitions for LTV_SOTCTL */
+#define LTV_SDT(x)		(((x) & 0x0007) << 10)
+#define LTV_EQ(x)		(((x) & 0x0007) <<  2)
+
+/* Bit definitions for LTV_PWRCTL1 */
+#define LTV_VCOM_DISABLE	(1 << 14)
+#define LTV_VCOMOUT_ENABLE	(1 << 11)
+#define LTV_POWER_ON		(1 <<  9)
+#define LTV_DRIVE_CURRENT(x)	(((x) & 0x0007) << 4)	/* 0=off, 5=max */
+#define LTV_SUPPLY_CURRENT(x)	(((x) & 0x0007) << 0)	/* 0=off, 5=max */
+
+/* Bit definitions for LTV_PWRCTL2 */
+#define LTV_VCOML_ENABLE	(1 << 13)
+#define LTV_VCOML_VOLTAGE(x)	(((x) & 0x001f) << 8)	/* 0=1V, 31=-1V */
+#define LTV_VCOMH_VOLTAGE(x)	(((x) & 0x001f) << 0)	/* 0=3V, 31=4.5V */
+
+#endif /* __LTV350QV_H */
diff --git a/board/earthlcd/favr-32-ezkit/Makefile b/board/earthlcd/favr-32-ezkit/Makefile
new file mode 100644
index 0000000..3e67a65
--- /dev/null
+++ b/board/earthlcd/favr-32-ezkit/Makefile
@@ -0,0 +1,42 @@
+#
+# (C) Copyright 2001-2006
+# Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+#
+# Copyright (C) 2008 Atmel Corporation
+#
+# See file CREDITS for list of people who contributed to this project.
+#
+# This program is free software; you can redistribute it and/or modify it under
+# the terms of the GNU General Public License as published by the Free Software
+# Foundation; either version 2 of the License, or (at your option) any later
+# version.
+#
+# This program is distributed in the hope that it will be useful, but WITHOUT
+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
+# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
+# details.
+#
+# You should have received a copy of the GNU General Public License along with
+# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+# Place, Suite 330, Boston, MA 02111-1307 USA
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o flash.o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB): $(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/earthlcd/favr-32-ezkit/config.mk b/board/earthlcd/favr-32-ezkit/config.mk
new file mode 100644
index 0000000..2337d62
--- /dev/null
+++ b/board/earthlcd/favr-32-ezkit/config.mk
@@ -0,0 +1,4 @@
+PLATFORM_RELFLAGS	+= -ffunction-sections -fdata-sections
+PLATFORM_LDFLAGS	+= --gc-sections
+TEXT_BASE		= 0x00000000
+LDSCRIPT		= $(obj)board/earthlcd/favr-32-ezkit/u-boot.lds
diff --git a/board/earthlcd/favr-32-ezkit/favr-32-ezkit.c b/board/earthlcd/favr-32-ezkit/favr-32-ezkit.c
new file mode 100644
index 0000000..d53ca4c
--- /dev/null
+++ b/board/earthlcd/favr-32-ezkit/favr-32-ezkit.c
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this project.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/sdram.h>
+#include <asm/arch/clk.h>
+#include <asm/arch/hmatrix.h>
+#include <asm/arch/portmux.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static const struct sdram_config sdram_config = {
+	/* MT48LC4M32B2P-6 (16 MB) */
+	.data_bits	= SDRAM_DATA_32BIT,
+	.row_bits	= 12,
+	.col_bits	= 8,
+	.bank_bits	= 2,
+	.cas		= 3,
+	.twr		= 2,
+	.trc		= 7,
+	.trp		= 2,
+	.trcd		= 2,
+	.tras		= 5,
+	.txsr		= 5,
+	/* 15.6 us */
+	.refresh_period	= (156 * (SDRAMC_BUS_HZ / 1000)) / 10000,
+};
+
+int board_early_init_f(void)
+{
+	/* Enable SDRAM in the EBI mux */
+	hmatrix_slave_write(EBI, SFR, HMATRIX_BIT(EBI_SDRAM_ENABLE));
+
+	portmux_enable_ebi(32, 23, 0, PORTMUX_DRIVE_HIGH);
+	portmux_enable_usart3(PORTMUX_DRIVE_MIN);
+#if defined(CONFIG_MACB)
+	portmux_enable_macb0(PORTMUX_MACB_MII, PORTMUX_DRIVE_HIGH);
+#endif
+#if defined(CONFIG_MMC)
+	portmux_enable_mmci(0, PORTMUX_MMCI_4BIT, PORTMUX_DRIVE_LOW);
+#endif
+
+	return 0;
+}
+
+phys_size_t initdram(int board_type)
+{
+	unsigned long expected_size;
+	unsigned long actual_size;
+	void *sdram_base;
+
+	sdram_base = map_physmem(EBI_SDRAM_BASE, EBI_SDRAM_SIZE, MAP_NOCACHE);
+
+	expected_size = sdram_init(sdram_base, &sdram_config);
+	actual_size = get_ram_size(sdram_base, expected_size);
+
+	unmap_physmem(sdram_base, EBI_SDRAM_SIZE);
+
+	if (expected_size != actual_size)
+		printf("Warning: Only %lu of %lu MiB SDRAM is working\n",
+				actual_size >> 20, expected_size >> 20);
+
+	return actual_size;
+}
+
+int board_early_init_r(void)
+{
+	gd->bd->bi_phy_id[0] = 0x01;
+	return 0;
+}
+
+#if defined(CONFIG_MACB) && defined(CONFIG_CMD_NET)
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+int board_eth_init(bd_t *bi)
+{
+	return macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
+}
+#endif
diff --git a/board/earthlcd/favr-32-ezkit/flash.c b/board/earthlcd/favr-32-ezkit/flash.c
new file mode 100644
index 0000000..2aa9415
--- /dev/null
+++ b/board/earthlcd/favr-32-ezkit/flash.c
@@ -0,0 +1,230 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this project.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#include <common.h>
+
+#ifdef CONFIG_FAVR32_EZKIT_EXT_FLASH
+#include <asm/cacheflush.h>
+#include <asm/io.h>
+#include <asm/sections.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+flash_info_t flash_info[1];
+
+static void flash_identify(uint16_t *flash, flash_info_t *info)
+{
+	unsigned long flags;
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+
+	writew(0xaa, flash + 0x555);
+	writew(0x55, flash + 0xaaa);
+	writew(0x90, flash + 0x555);
+	info->flash_id = readl(flash);
+	writew(0xff, flash);
+
+	readw(flash);
+
+	if (flags)
+		enable_interrupts();
+}
+
+unsigned long flash_init(void)
+{
+	unsigned long addr;
+	unsigned int i;
+
+	flash_info[0].size = CFG_FLASH_SIZE;
+	flash_info[0].sector_count = 135;
+
+	flash_identify(uncached((void *)CFG_FLASH_BASE), &flash_info[0]);
+
+	for (i = 0, addr = 0; i < 8; i++, addr += 0x2000)
+		flash_info[0].start[i] = addr;
+	for (; i < flash_info[0].sector_count; i++, addr += 0x10000)
+		flash_info[0].start[i] = addr;
+
+	return CFG_FLASH_SIZE;
+}
+
+void flash_print_info(flash_info_t *info)
+{
+	printf("Flash: Vendor ID: 0x%02lx, Product ID: 0x%02lx\n",
+	       info->flash_id >> 16, info->flash_id & 0xffff);
+	printf("Size: %ld MB in %d sectors\n",
+	       info->size >> 10, info->sector_count);
+}
+
+int flash_erase(flash_info_t *info, int s_first, int s_last)
+{
+	unsigned long flags;
+	unsigned long start_time;
+	uint16_t *fb, *sb;
+	unsigned int i;
+	int ret;
+	uint16_t status;
+
+	if ((s_first < 0) || (s_first > s_last)
+	    || (s_last >= info->sector_count)) {
+		puts("Error: first and/or last sector out of range\n");
+		return ERR_INVAL;
+	}
+
+	for (i = s_first; i < s_last; i++)
+		if (info->protect[i]) {
+			printf("Error: sector %d is protected\n", i);
+			return ERR_PROTECTED;
+		}
+
+	fb = (uint16_t *)uncached(info->start[0]);
+
+	dcache_flush_unlocked();
+
+	for (i = s_first; (i <= s_last) && !ctrlc(); i++) {
+		printf("Erasing sector %3d...", i);
+
+		sb = (uint16_t *)uncached(info->start[i]);
+
+		flags = disable_interrupts();
+
+		start_time = get_timer(0);
+
+		/* Unlock sector */
+		writew(0xaa, fb + 0x555);
+		writew(0x70, sb);
+
+		/* Erase sector */
+		writew(0xaa, fb + 0x555);
+		writew(0x55, fb + 0xaaa);
+		writew(0x80, fb + 0x555);
+		writew(0xaa, fb + 0x555);
+		writew(0x55, fb + 0xaaa);
+		writew(0x30, sb);
+
+		/* Wait for completion */
+		ret = ERR_OK;
+		do {
+			/* TODO: Timeout */
+			status = readw(sb);
+		} while ((status != 0xffff) && !(status & 0x28));
+
+		writew(0xf0, fb);
+
+		/*
+		 * Make sure the command actually makes it to the bus
+		 * before we re-enable interrupts.
+		 */
+		readw(fb);
+
+		if (flags)
+			enable_interrupts();
+
+		if (status != 0xffff) {
+			printf("Flash erase error at address 0x%p: 0x%02x\n",
+			       sb, status);
+			ret = ERR_PROG_ERROR;
+			break;
+		}
+	}
+
+	if (ctrlc())
+		printf("User interrupt!\n");
+
+	return ERR_OK;
+}
+
+int write_buff(flash_info_t *info, uchar *src,
+			   ulong addr, ulong count)
+{
+	unsigned long flags;
+	uint16_t *base, *p, *s, *end;
+	uint16_t word, status, status1;
+	int ret = ERR_OK;
+
+	if (addr < info->start[0]
+	    || (addr + count) > (info->start[0] + info->size)
+	    || (addr + count) < addr) {
+		puts("Error: invalid address range\n");
+		return ERR_INVAL;
+	}
+
+	if (addr & 1 || count & 1 || (unsigned int)src & 1) {
+		puts("Error: misaligned source, destination or count\n");
+		return ERR_ALIGN;
+	}
+
+	base = (uint16_t *)uncached(info->start[0]);
+	end = (uint16_t *)uncached(addr + count);
+
+	flags = disable_interrupts();
+
+	dcache_flush_unlocked();
+	sync_write_buffer();
+
+	for (p = (uint16_t *)uncached(addr), s = (uint16_t *)src;
+	     p < end && !ctrlc(); p++, s++) {
+		word = *s;
+
+		writew(0xaa, base + 0x555);
+		writew(0x55, base + 0xaaa);
+		writew(0xa0, base + 0x555);
+		writew(word, p);
+
+		sync_write_buffer();
+
+		/* Wait for completion */
+		status1 = readw(p);
+		do {
+			/* TODO: Timeout */
+			status = status1;
+			status1 = readw(p);
+		} while (((status ^ status1) & 0x40)	/* toggled */
+			 && !(status1 & 0x28));		/* error bits */
+
+		/*
+		 * We'll need to check once again for toggle bit
+		 * because the toggle bit may stop toggling as I/O5
+		 * changes to "1" (ref at49bv642.pdf p9)
+		 */
+		status1 = readw(p);
+		status = readw(p);
+		if ((status ^ status1) & 0x40) {
+			printf("Flash write error at address 0x%p: "
+			       "0x%02x != 0x%02x\n",
+			       p, status,word);
+			ret = ERR_PROG_ERROR;
+			writew(0xf0, base);
+			readw(base);
+			break;
+		}
+
+		writew(0xf0, base);
+		readw(base);
+	}
+
+	if (flags)
+		enable_interrupts();
+
+	return ret;
+}
+
+#endif /* CONFIG_FAVR32_EZKIT_EXT_FLASH */
diff --git a/board/earthlcd/favr-32-ezkit/u-boot.lds b/board/earthlcd/favr-32-ezkit/u-boot.lds
new file mode 100644
index 0000000..ad056b3
--- /dev/null
+++ b/board/earthlcd/favr-32-ezkit/u-boot.lds
@@ -0,0 +1,71 @@
+/* -*- Fundamental -*-
+ *
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this project.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+OUTPUT_FORMAT("elf32-avr32", "elf32-avr32", "elf32-avr32")
+OUTPUT_ARCH(avr32)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = 0;
+	_text = .;
+	.text : {
+		*(.exception.text)
+		*(.text)
+		*(.text.*)
+	}
+	_etext = .;
+
+	.rodata : {
+		*(.rodata)
+		*(.rodata.*)
+	}
+
+	. = ALIGN(8);
+	_data = .;
+	.data : {
+		*(.data)
+		*(.data.*)
+	}
+
+	. = ALIGN(4);
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : {
+		KEEP(*(.u_boot_cmd))
+	}
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	_got = .;
+	.got : {
+		*(.got)
+	}
+	_egot = .;
+
+	. = ALIGN(8);
+	_edata = .;
+
+	.bss (NOLOAD) : {
+		*(.bss)
+		*(.bss.*)
+	}
+	. = ALIGN(8);
+	_end = .;
+}
diff --git a/board/lwmon/lwmon.c b/board/lwmon/lwmon.c
index 4a2d8e4..695eddd 100644
--- a/board/lwmon/lwmon.c
+++ b/board/lwmon/lwmon.c
@@ -759,6 +759,35 @@ static uchar *key_match (uchar *kbd_data)
 }
 #endif /* CONFIG_PREBOOT */
 
+#ifdef CONFIG_LCD_INFO
+#include <lcd.h>
+#include <version.h>
+
+void lcd_show_board_info(void)
+{
+	char temp[32];
+
+	lcd_printf ("%s (%s - %s)\n", U_BOOT_VERSION, __DATE__, __TIME__);
+	lcd_printf ("(C) 2008 DENX Software Engineering GmbH\n");
+	lcd_printf ("    Wolfgang DENK, wd@denx.de\n");
+#ifdef CONFIG_LCD_INFO_BELOW_LOGO
+	lcd_printf ("MPC823 CPU at %s MHz\n",
+		strmhz(temp, gd->cpu_clk));
+	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 3,
+					info, strlen(info));
+	lcd_printf ("  %ld MB RAM, %ld MB Flash\n",
+		gd->ram_size >> 20,
+		gd->bd->bi_flashsize >> 20 );
+#else
+	/* leave one blank line */
+	lcd_printf ("\nMPC823 CPU at %s MHz, %ld MB RAM, %ld MB Flash\n",
+		strmhz(temp, gd->cpu_clk),
+		gd->ram_size >> 20,
+		gd->bd->bi_flashsize >> 20 );
+#endif /* CONFIG_LCD_INFO_BELOW_LOGO */
+}
+#endif /* CONFIG_LCD_INFO */
+
 /*---------------Board Special Commands: PIC read/write ---------------*/
 
 #if defined(CONFIG_CMD_BSP)
diff --git a/board/mimc/mimc200/Makefile b/board/mimc/mimc200/Makefile
new file mode 100644
index 0000000..9f3849f
--- /dev/null
+++ b/board/mimc/mimc200/Makefile
@@ -0,0 +1,40 @@
+#
+# Copyright (C) 2005-2006 Atmel Corporation
+#
+# See file CREDITS for list of people who contributed to this project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB): $(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/mimc/mimc200/config.mk b/board/mimc/mimc200/config.mk
new file mode 100644
index 0000000..9a794e5
--- /dev/null
+++ b/board/mimc/mimc200/config.mk
@@ -0,0 +1,3 @@
+TEXT_BASE		= 0x00000000
+PLATFORM_RELFLAGS	+= -ffunction-sections -fdata-sections
+PLATFORM_LDFLAGS	+= --gc-sections
diff --git a/board/mimc/mimc200/mimc200.c b/board/mimc/mimc200/mimc200.c
new file mode 100644
index 0000000..c30bcb6
--- /dev/null
+++ b/board/mimc/mimc200/mimc200.c
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/sdram.h>
+#include <asm/arch/clk.h>
+#include <asm/arch/gpio.h>
+#include <asm/arch/hmatrix.h>
+#include <asm/arch/portmux.h>
+#include <lcd.h>
+
+#define SM_PM_GCCTRL				0x0060
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static const struct sdram_config sdram_config = {
+	.data_bits	= SDRAM_DATA_16BIT,
+	.row_bits	= 13,
+	.col_bits	= 9,
+	.bank_bits	= 2,
+	.cas		= 3,
+	.twr		= 2,
+	.trc		= 6,
+	.trp		= 2,
+	.trcd		= 2,
+	.tras		= 6,
+	.txsr		= 6,
+	/* 15.6 us */
+	.refresh_period	= (156 * (SDRAMC_BUS_HZ / 1000)) / 10000,
+};
+
+int board_early_init_f(void)
+{
+	/* Enable SDRAM in the EBI mux */
+	hmatrix_slave_write(EBI, SFR, HMATRIX_BIT(EBI_SDRAM_ENABLE));
+
+	/* Enable 26 address bits and NCS2 */
+	portmux_enable_ebi(16, 26, PORTMUX_EBI_CS(2), PORTMUX_DRIVE_HIGH);
+	portmux_enable_usart1(PORTMUX_DRIVE_MIN);
+
+	/* de-assert "force sys reset" pin */
+	portmux_select_gpio(PORTMUX_PORT_D, 1 << 15,
+			PORTMUX_DIR_OUTPUT | PORTMUX_INIT_HIGH);
+
+	/* init custom i/o */
+	/* cpu type inputs */
+	portmux_select_gpio(PORTMUX_PORT_E, (1 << 19) | (1 << 20) | (1 << 23),
+			PORTMUX_DIR_INPUT);
+	/* main board type inputs */
+	portmux_select_gpio(PORTMUX_PORT_B, (1 << 19) | (1 << 29),
+			PORTMUX_DIR_INPUT);
+	/* DEBUG input (use weak pullup) */
+	portmux_select_gpio(PORTMUX_PORT_E, 1 << 21,
+			PORTMUX_DIR_INPUT | PORTMUX_PULL_UP);
+
+	/* are we suppressing the console ? */
+	if (gpio_get_value(GPIO_PIN_PE(21)) == 1)
+		gd->flags |= GD_FLG_SILENT;
+
+	/* reset phys */
+	portmux_select_gpio(PORTMUX_PORT_E, 1 << 24, PORTMUX_DIR_INPUT);
+	portmux_select_gpio(PORTMUX_PORT_C, 1 << 18,
+			PORTMUX_DIR_OUTPUT | PORTMUX_INIT_HIGH);
+
+	/* GCLK0 - 10MHz clock */
+	writel(0x00000004, (void *)SM_BASE + SM_PM_GCCTRL);
+	portmux_select_peripheral(PORTMUX_PORT_A, 1 << 30, PORTMUX_FUNC_A, 0);
+
+	udelay(5000);
+
+	/* release phys reset */
+	gpio_set_value(GPIO_PIN_PC(18), 0);	/* PHY RESET (Release)	*/
+
+#if defined(CONFIG_MACB)
+	/* init macb0 pins */
+	portmux_enable_macb0(PORTMUX_MACB_MII, PORTMUX_DRIVE_HIGH);
+	portmux_enable_macb1(PORTMUX_MACB_MII, PORTMUX_DRIVE_HIGH);
+#endif
+
+#if defined(CONFIG_MMC)
+	portmux_enable_mmci(0, PORTMUX_MMCI_4BIT, PORTMUX_DRIVE_LOW);
+#endif
+
+	return 0;
+}
+
+phys_size_t initdram(int board_type)
+{
+	unsigned long expected_size;
+	unsigned long actual_size;
+	void *sdram_base;
+
+	sdram_base = map_physmem(EBI_SDRAM_BASE, EBI_SDRAM_SIZE, MAP_NOCACHE);
+
+	expected_size = sdram_init(sdram_base, &sdram_config);
+	actual_size = get_ram_size(sdram_base, expected_size);
+
+	unmap_physmem(sdram_base, EBI_SDRAM_SIZE);
+
+	if (expected_size != actual_size)
+		printf("Warning: Only %lu of %lu MiB SDRAM is working\n",
+				actual_size >> 20, expected_size >> 20);
+
+	return actual_size;
+}
+
+int board_early_init_r(void)
+{
+	gd->bd->bi_phy_id[0] = 0x01;
+	gd->bd->bi_phy_id[1] = 0x03;
+	return 0;
+}
+
+/* SPI chip select control */
+#ifdef CONFIG_ATMEL_SPI
+#include <spi.h>
+
+int spi_cs_is_valid(unsigned int bus, unsigned int cs)
+{
+	return (bus == 0) && (cs == 0);
+}
+
+void spi_cs_activate(struct spi_slave *slave)
+{
+}
+
+void spi_cs_deactivate(struct spi_slave *slave)
+{
+}
+#endif /* CONFIG_ATMEL_SPI */
+
+#ifdef CONFIG_CMD_NET
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+int board_eth_init(bd_t *bi)
+{
+	macb_eth_initialize(0, (void *)MACB0_BASE, bi->bi_phy_id[0]);
+	macb_eth_initialize(1, (void *)MACB1_BASE, bi->bi_phy_id[1]);
+
+	return 0;
+}
+#endif
diff --git a/board/mimc/mimc200/u-boot.lds b/board/mimc/mimc200/u-boot.lds
new file mode 100644
index 0000000..e736adf
--- /dev/null
+++ b/board/mimc/mimc200/u-boot.lds
@@ -0,0 +1,73 @@
+/* -*- Fundamental -*-
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+OUTPUT_FORMAT("elf32-avr32", "elf32-avr32", "elf32-avr32")
+OUTPUT_ARCH(avr32)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = 0;
+	_text = .;
+	.text : {
+		*(.exception.text)
+		*(.text)
+		*(.text.*)
+	}
+	_etext = .;
+
+	.rodata : {
+		*(.rodata)
+		*(.rodata.*)
+	}
+
+	. = ALIGN(8);
+	_data = .;
+	.data : {
+		*(.data)
+		*(.data.*)
+	}
+
+	. = ALIGN(4);
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : {
+		KEEP(*(.u_boot_cmd))
+	}
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	_got = .;
+	.got : {
+		*(.got)
+	}
+	_egot = .;
+
+	. = ALIGN(8);
+	_edata = .;
+
+	.bss : {
+		*(.bss)
+		*(.bss.*)
+	}
+	. = ALIGN(8);
+	_end = .;
+}
diff --git a/board/miromico/hammerhead/Makefile b/board/miromico/hammerhead/Makefile
new file mode 100644
index 0000000..4b74d16
--- /dev/null
+++ b/board/miromico/hammerhead/Makefile
@@ -0,0 +1,40 @@
+#
+# Copyright (C) 2008 Miromico AG
+#
+# See file CREDITS for list of people who contributed to this project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)lib$(BOARD).a
+
+COBJS	:= $(BOARD).o
+
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+$(LIB): $(obj).depend $(OBJS)
+	$(AR) $(ARFLAGS) $@ $(OBJS)
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/board/miromico/hammerhead/config.mk b/board/miromico/hammerhead/config.mk
new file mode 100644
index 0000000..9a794e5
--- /dev/null
+++ b/board/miromico/hammerhead/config.mk
@@ -0,0 +1,3 @@
+TEXT_BASE		= 0x00000000
+PLATFORM_RELFLAGS	+= -ffunction-sections -fdata-sections
+PLATFORM_LDFLAGS	+= --gc-sections
diff --git a/board/miromico/hammerhead/hammerhead.c b/board/miromico/hammerhead/hammerhead.c
new file mode 100644
index 0000000..7fd0781
--- /dev/null
+++ b/board/miromico/hammerhead/hammerhead.c
@@ -0,0 +1,110 @@
+/*
+ * Copyright (C) 2008 Miromico AG
+ *
+ * Mostly copied form atmel ATNGW100 sources
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/sdram.h>
+#include <asm/arch/clk.h>
+#include <asm/arch/hmatrix.h>
+#include <asm/arch/memory-map.h>
+#include <asm/arch/portmux.h>
+
+DECLARE_GLOBAL_DATA_PTR;
+
+static const struct sdram_config sdram_config = {
+	.data_bits	= SDRAM_DATA_32BIT,
+	.row_bits	= 13,
+	.col_bits	= 9,
+	.bank_bits	= 2,
+	.cas		= 3,
+	.twr		= 2,
+	.trc		= 7,
+	.trp		= 2,
+	.trcd		= 2,
+	.tras		= 5,
+	.txsr		= 5,
+	/* 7.81 us */
+	.refresh_period	= (781 * (SDRAMC_BUS_HZ / 1000)) / 100000,
+};
+
+extern int macb_eth_initialize(int id, void *regs, unsigned int phy_addr);
+
+#ifdef CONFIG_CMD_NET
+int board_eth_init(bd_t *bis)
+{
+	return macb_eth_initialize(0, (void *)MACB0_BASE, bis->bi_phy_id[0]);
+}
+#endif
+
+int board_early_init_f(void)
+{
+	/* Enable SDRAM in the EBI mux */
+	hmatrix_slave_write(EBI, SFR, HMATRIX_BIT(EBI_SDRAM_ENABLE));
+
+	portmux_enable_ebi(32, 23, 0, PORTMUX_DRIVE_HIGH);
+	portmux_enable_usart1(PORTMUX_DRIVE_MIN);
+
+#if defined(CONFIG_MACB)
+	portmux_enable_macb0(PORTMUX_MACB_MII, PORTMUX_DRIVE_HIGH);
+#endif
+#if defined(CONFIG_MMC)
+	portmux_enable_mmci(0, PORTMUX_MMCI_4BIT, PORTMUX_DRIVE_LOW);
+#endif
+	return 0;
+}
+
+phys_size_t initdram(int board_type)
+{
+	unsigned long expected_size;
+	unsigned long actual_size;
+	void *sdram_base;
+
+	sdram_base = map_physmem(EBI_SDRAM_BASE, EBI_SDRAM_SIZE, MAP_NOCACHE);
+
+	expected_size = sdram_init(sdram_base, &sdram_config);
+	actual_size = get_ram_size(sdram_base, expected_size);
+
+	unmap_physmem(sdram_base, EBI_SDRAM_SIZE);
+
+	if (expected_size != actual_size)
+		printf("Warning: Only %lu of %lu MiB SDRAM is working\n",
+		       actual_size >> 20, expected_size >> 20);
+
+	return actual_size;
+}
+
+int board_early_init_r(void)
+{
+	gd->bd->bi_phy_id[0] = 0x01;
+	return 0;
+}
+
+int board_postclk_init(void)
+{
+	/* Hammerhead boards uses GCLK3 as 25MHz output to ethernet PHY */
+	gclk_enable_output(3, PORTMUX_DRIVE_LOW);
+	gclk_set_rate(3, GCLK_PARENT_OSC0, 25000000);
+	return 0;
+}
diff --git a/board/miromico/hammerhead/u-boot.lds b/board/miromico/hammerhead/u-boot.lds
new file mode 100644
index 0000000..e736adf
--- /dev/null
+++ b/board/miromico/hammerhead/u-boot.lds
@@ -0,0 +1,73 @@
+/* -*- Fundamental -*-
+ *
+ * Copyright (C) 2005-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+OUTPUT_FORMAT("elf32-avr32", "elf32-avr32", "elf32-avr32")
+OUTPUT_ARCH(avr32)
+ENTRY(_start)
+
+SECTIONS
+{
+	. = 0;
+	_text = .;
+	.text : {
+		*(.exception.text)
+		*(.text)
+		*(.text.*)
+	}
+	_etext = .;
+
+	.rodata : {
+		*(.rodata)
+		*(.rodata.*)
+	}
+
+	. = ALIGN(8);
+	_data = .;
+	.data : {
+		*(.data)
+		*(.data.*)
+	}
+
+	. = ALIGN(4);
+	__u_boot_cmd_start = .;
+	.u_boot_cmd : {
+		KEEP(*(.u_boot_cmd))
+	}
+	__u_boot_cmd_end = .;
+
+	. = ALIGN(4);
+	_got = .;
+	.got : {
+		*(.got)
+	}
+	_egot = .;
+
+	. = ALIGN(8);
+	_edata = .;
+
+	.bss : {
+		*(.bss)
+		*(.bss.*)
+	}
+	. = ALIGN(8);
+	_end = .;
+}
diff --git a/board/tqc/tqm8xx/tqm8xx.c b/board/tqc/tqm8xx/tqm8xx.c
index 96b6103..ea89d5a 100644
--- a/board/tqc/tqm8xx/tqm8xx.c
+++ b/board/tqc/tqm8xx/tqm8xx.c
@@ -504,6 +504,32 @@ int misc_init_r (void)
 }
 #endif	/* CONFIG_NSCU */
 
+#ifdef CONFIG_LCD_INFO
+#include <lcd.h>
+
+void lcd_show_board_info(void)
+{
+	lcd_printf ("%s (%s - %s)\n", U_BOOT_VERSION, __DATE__, __TIME__);
+	lcd_printf ("(C) 2008 DENX Software Engineering GmbH\n");
+	lcd_printf ("    Wolfgang DENK, wd@denx.de\n");
+#ifdef CONFIG_LCD_INFO_BELOW_LOGO
+	lcd_printf ("MPC823 CPU at %s MHz\n",
+		strmhz(temp, gd->cpu_clk));
+	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 3,
+					info, strlen(info));
+	lcd_printf ("  %ld MB RAM, %ld MB Flash\n",
+		gd->ram_size >> 20,
+		gd->bd->bi_flashsize >> 20 );
+#else
+	/* leave one blank line */
+	lcd_printf ("\nMPC823 CPU at %s MHz, %ld MB RAM, %ld MB Flash\n",
+		strmhz(temp, gd->cpu_clk),
+		gd->ram_size >> 20,
+		gd->bd->bi_flashsize >> 20 );
+#endif /* CONFIG_LCD_INFO_BELOW_LOGO */
+}
+#endif /* CONFIG_LCD_INFO */
+
 /* ---------------------------------------------------------------------------- */
 /* TK885D specific initializaion						*/
 /* ---------------------------------------------------------------------------- */
diff --git a/common/lcd.c b/common/lcd.c
index 8d770f3..e07db19 100644
--- a/common/lcd.c
+++ b/common/lcd.c
@@ -52,7 +52,6 @@
 
 #if defined(CONFIG_ATMEL_LCD)
 #include <atmel_lcdc.h>
-#include <nand.h>
 #endif
 
 #ifdef CONFIG_LCD
@@ -227,6 +226,20 @@ void lcd_puts (const char *s)
 	}
 }
 
+/*----------------------------------------------------------------------*/
+
+void lcd_printf(const char *fmt, ...)
+{
+	va_list args;
+	char buf[CFG_PBSIZE];
+
+	va_start(args, fmt);
+	vsprintf(buf, fmt, args);
+	va_end(args);
+
+	lcd_puts(buf);
+}
+
 /************************************************************************/
 /* ** Low-Level Graphics Routines					*/
 /************************************************************************/
@@ -428,6 +441,7 @@ static int lcd_init (void *lcdbase)
 	debug ("[LCD] Initializing LCD frambuffer at %p\n", lcdbase);
 
 	lcd_ctrl_init (lcdbase);
+	lcd_is_enabled = 1;
 	lcd_clear (NULL, 1, 1, NULL);	/* dummy args */
 	lcd_enable ();
 
@@ -438,7 +452,6 @@ static int lcd_init (void *lcdbase)
 #else
 	console_row = 1;	/* leave 1 blank line below logo */
 #endif
-	lcd_is_enabled = 1;
 
 	return 0;
 }
@@ -750,15 +763,6 @@ extern bmp_image_t *gunzip_bmp(unsigned long addr, unsigned long *lenp);
 
 static void *lcd_logo (void)
 {
-#ifdef CONFIG_LCD_INFO
-	char info[80];
-	char temp[32];
-#ifdef CONFIG_ATMEL_LCD
-	int i;
-	ulong dram_size, nand_size;
-#endif
-#endif /* CONFIG_LCD_INFO */
-
 #ifdef CONFIG_SPLASH_SCREEN
 	char *s;
 	ulong addr;
@@ -788,75 +792,11 @@ static void *lcd_logo (void)
 	bitmap_plot (0, 0);
 #endif /* CONFIG_LCD_LOGO */
 
-#ifdef CONFIG_MPC823
-# ifdef CONFIG_LCD_INFO
-	sprintf (info, "%s (%s - %s) ", U_BOOT_VERSION, __DATE__, __TIME__);
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y, (uchar *)info, strlen(info));
-
-	sprintf (info, "(C) 2008 DENX Software Engineering GmbH");
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT,
-					(uchar *)info, strlen(info));
-
-	sprintf (info, "    Wolfgang DENK, wd@denx.de");
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 2,
-					(uchar *)info, strlen(info));
-#  ifdef CONFIG_LCD_INFO_BELOW_LOGO
-	sprintf (info, "MPC823 CPU at %s MHz",
-		strmhz(temp, gd->cpu_clk));
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 3,
-					info, strlen(info));
-	sprintf (info, "  %ld MB RAM, %ld MB Flash",
-		gd->ram_size >> 20,
-		gd->bd->bi_flashsize >> 20 );
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 4,
-					info, strlen(info));
-#  else
-	/* leave one blank line */
-
-	sprintf (info, "MPC823 CPU at %s MHz, %ld MB RAM, %ld MB Flash",
-		strmhz(temp, gd->cpu_clk),
-		gd->ram_size >> 20,
-		gd->bd->bi_flashsize >> 20 );
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 4,
-					(uchar *)info, strlen(info));
-
-#  endif /* CONFIG_LCD_INFO_BELOW_LOGO */
-# endif /* CONFIG_LCD_INFO */
-#endif /* CONFIG_MPC823 */
-
-#ifdef CONFIG_ATMEL_LCD
-# ifdef CONFIG_LCD_INFO
-	sprintf (info, "%s", U_BOOT_VERSION);
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y, (uchar *)info, strlen(info));
-
-	sprintf (info, "(C) 2008 ATMEL Corp");
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT,
-					(uchar *)info, strlen(info));
-
-	sprintf (info, "at91support@atmel.com");
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 2,
-					(uchar *)info, strlen(info));
-
-	sprintf (info, "%s CPU at %s MHz",
-		AT91_CPU_NAME,
-		strmhz(temp, AT91_MAIN_CLOCK));
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 3,
-					(uchar *)info, strlen(info));
-
-	dram_size = 0;
-	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
-		dram_size += gd->bd->bi_dram[i].size;
-	nand_size = 0;
-	for (i = 0; i < CFG_MAX_NAND_DEVICE; i++)
-		nand_size += nand_info[i].size;
-	sprintf (info, "  %ld MB SDRAM, %ld MB NAND",
-		dram_size >> 20,
-		nand_size >> 20 );
-	lcd_drawchars (LCD_INFO_X, LCD_INFO_Y + VIDEO_FONT_HEIGHT * 4,
-					(uchar *)info, strlen(info));
-# endif /* CONFIG_LCD_INFO */
-#endif /* CONFIG_ATMEL_LCD */
-
+#ifdef CONFIG_LCD_INFO
+	console_col = LCD_INFO_X / VIDEO_FONT_WIDTH;
+	console_row = LCD_INFO_Y / VIDEO_FONT_HEIGHT;
+	lcd_show_board_info();
+#endif /* CONFIG_LCD_INFO */
 
 #if defined(CONFIG_LCD_LOGO) && !defined(CONFIG_LCD_INFO_BELOW_LOGO)
 	return ((void *)((ulong)lcd_base + BMP_LOGO_HEIGHT * lcd_line_length));
diff --git a/cpu/at32ap/Makefile b/cpu/at32ap/Makefile
index 33dc427..e08f273 100644
--- a/cpu/at32ap/Makefile
+++ b/cpu/at32ap/Makefile
@@ -34,7 +34,8 @@ COBJS-y			+= hsdramc.o
 COBJS-y			+= exception.o
 COBJS-y			+= cache.o
 COBJS-y			+= interrupts.o
-COBJS-y			+= pio.o
+COBJS-$(CONFIG_PORTMUX_PIO) += portmux-pio.o
+COBJS-$(CONFIG_PORTMUX_GPIO) += portmux-gpio.o
 
 SRCS	:= $(START-y:.o=.S) $(SOBJS-y:.o=.S) $(COBJS-y:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS-y) $(COBJS-y))
diff --git a/cpu/at32ap/at32ap700x/Makefile b/cpu/at32ap/at32ap700x/Makefile
index 7404235..46e6ef6 100644
--- a/cpu/at32ap/at32ap700x/Makefile
+++ b/cpu/at32ap/at32ap700x/Makefile
@@ -24,7 +24,7 @@ include $(TOPDIR)/config.mk
 
 LIB	:= $(obj)lib$(SOC).a
 
-COBJS	:= gpio.o clk.o
+COBJS	:= portmux.o clk.o
 SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
 OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
 
diff --git a/cpu/at32ap/at32ap700x/clk.c b/cpu/at32ap/at32ap700x/clk.c
index b3aa034..a6a6c88 100644
--- a/cpu/at32ap/at32ap700x/clk.c
+++ b/cpu/at32ap/at32ap700x/clk.c
@@ -25,6 +25,7 @@
 
 #include <asm/arch/clk.h>
 #include <asm/arch/memory-map.h>
+#include <asm/arch/portmux.h>
 
 #include "sm.h"
 
@@ -66,3 +67,27 @@ void clk_init(void)
 	sm_writel(PM_MCCTRL, SM_BIT(PLLSEL));
 #endif
 }
+
+unsigned long __gclk_set_rate(unsigned int id, enum gclk_parent parent,
+		unsigned long rate, unsigned long parent_rate)
+{
+	unsigned long divider;
+
+	if (rate == 0 || parent_rate == 0) {
+		sm_writel(PM_GCCTRL(id), 0);
+		return 0;
+	}
+
+	divider = (parent_rate + rate / 2) / rate;
+	if (divider <= 1) {
+		sm_writel(PM_GCCTRL(id), parent | SM_BIT(CEN));
+		rate = parent_rate;
+	} else {
+		divider = min(255, divider / 2 - 1);
+		sm_writel(PM_GCCTRL(id), parent | SM_BIT(CEN) | SM_BIT(DIVEN)
+				| SM_BF(DIV, divider));
+		rate = parent_rate / (2 * (divider + 1));
+	}
+
+	return rate;
+}
diff --git a/cpu/at32ap/at32ap700x/gpio.c b/cpu/at32ap/at32ap700x/gpio.c
deleted file mode 100644
index 56ba2f9..0000000
--- a/cpu/at32ap/at32ap700x/gpio.c
+++ /dev/null
@@ -1,199 +0,0 @@
-/*
- * Copyright (C) 2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-
-#include <asm/io.h>
-
-#include <asm/arch/chip-features.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/memory-map.h>
-
-/*
- * Lots of small functions here. We depend on --gc-sections getting
- * rid of the ones we don't need.
- */
-void gpio_enable_ebi(void)
-{
-#ifdef CFG_HSDRAMC
-#ifndef CFG_SDRAM_16BIT
-	gpio_select_periph_A(GPIO_PIN_PE0, 0);
-	gpio_select_periph_A(GPIO_PIN_PE1, 0);
-	gpio_select_periph_A(GPIO_PIN_PE2, 0);
-	gpio_select_periph_A(GPIO_PIN_PE3, 0);
-	gpio_select_periph_A(GPIO_PIN_PE4, 0);
-	gpio_select_periph_A(GPIO_PIN_PE5, 0);
-	gpio_select_periph_A(GPIO_PIN_PE6, 0);
-	gpio_select_periph_A(GPIO_PIN_PE7, 0);
-	gpio_select_periph_A(GPIO_PIN_PE8, 0);
-	gpio_select_periph_A(GPIO_PIN_PE9, 0);
-	gpio_select_periph_A(GPIO_PIN_PE10, 0);
-	gpio_select_periph_A(GPIO_PIN_PE11, 0);
-	gpio_select_periph_A(GPIO_PIN_PE12, 0);
-	gpio_select_periph_A(GPIO_PIN_PE13, 0);
-	gpio_select_periph_A(GPIO_PIN_PE14, 0);
-	gpio_select_periph_A(GPIO_PIN_PE15, 0);
-#endif
-	gpio_select_periph_A(GPIO_PIN_PE26, 0);
-#endif
-}
-
-#ifdef AT32AP700x_CHIP_HAS_USART
-void gpio_enable_usart0(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PA8, 0);
-	gpio_select_periph_B(GPIO_PIN_PA9, 0);
-}
-
-void gpio_enable_usart1(void)
-{
-	gpio_select_periph_A(GPIO_PIN_PA17, 0);
-	gpio_select_periph_A(GPIO_PIN_PA18, 0);
-}
-
-void gpio_enable_usart2(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PB26, 0);
-	gpio_select_periph_B(GPIO_PIN_PB27, 0);
-}
-
-void gpio_enable_usart3(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PB17, 0);
-	gpio_select_periph_B(GPIO_PIN_PB18, 0);
-}
-#endif
-
-#ifdef AT32AP700x_CHIP_HAS_MACB
-void gpio_enable_macb0(void)
-{
-	gpio_select_periph_A(GPIO_PIN_PC3,  0);	/* TXD0	*/
-	gpio_select_periph_A(GPIO_PIN_PC4,  0);	/* TXD1	*/
-	gpio_select_periph_A(GPIO_PIN_PC7,  0);	/* TXEN	*/
-	gpio_select_periph_A(GPIO_PIN_PC8,  0);	/* TXCK */
-	gpio_select_periph_A(GPIO_PIN_PC9,  0);	/* RXD0	*/
-	gpio_select_periph_A(GPIO_PIN_PC10, 0);	/* RXD1	*/
-	gpio_select_periph_A(GPIO_PIN_PC13, 0);	/* RXER	*/
-	gpio_select_periph_A(GPIO_PIN_PC15, 0);	/* RXDV	*/
-	gpio_select_periph_A(GPIO_PIN_PC16, 0);	/* MDC	*/
-	gpio_select_periph_A(GPIO_PIN_PC17, 0);	/* MDIO	*/
-#if !defined(CONFIG_RMII)
-	gpio_select_periph_A(GPIO_PIN_PC0,  0);	/* COL	*/
-	gpio_select_periph_A(GPIO_PIN_PC1,  0);	/* CRS	*/
-	gpio_select_periph_A(GPIO_PIN_PC2,  0);	/* TXER	*/
-	gpio_select_periph_A(GPIO_PIN_PC5,  0);	/* TXD2	*/
-	gpio_select_periph_A(GPIO_PIN_PC6,  0);	/* TXD3 */
-	gpio_select_periph_A(GPIO_PIN_PC11, 0);	/* RXD2	*/
-	gpio_select_periph_A(GPIO_PIN_PC12, 0);	/* RXD3	*/
-	gpio_select_periph_A(GPIO_PIN_PC14, 0);	/* RXCK	*/
-	gpio_select_periph_A(GPIO_PIN_PC18, 0);	/* SPD	*/
-#endif
-}
-
-void gpio_enable_macb1(void)
-{
-	gpio_select_periph_B(GPIO_PIN_PD13, 0);	/* TXD0	*/
-	gpio_select_periph_B(GPIO_PIN_PD14, 0);	/* TXD1	*/
-	gpio_select_periph_B(GPIO_PIN_PD11, 0);	/* TXEN	*/
-	gpio_select_periph_B(GPIO_PIN_PD12, 0);	/* TXCK */
-	gpio_select_periph_B(GPIO_PIN_PD10, 0);	/* RXD0	*/
-	gpio_select_periph_B(GPIO_PIN_PD6,  0);	/* RXD1	*/
-	gpio_select_periph_B(GPIO_PIN_PD5,  0);	/* RXER	*/
-	gpio_select_periph_B(GPIO_PIN_PD4,  0);	/* RXDV	*/
-	gpio_select_periph_B(GPIO_PIN_PD3,  0);	/* MDC	*/
-	gpio_select_periph_B(GPIO_PIN_PD2,  0);	/* MDIO	*/
-#if !defined(CONFIG_RMII)
-	gpio_select_periph_B(GPIO_PIN_PC19, 0);	/* COL	*/
-	gpio_select_periph_B(GPIO_PIN_PC23, 0);	/* CRS	*/
-	gpio_select_periph_B(GPIO_PIN_PC26, 0);	/* TXER	*/
-	gpio_select_periph_B(GPIO_PIN_PC27, 0);	/* TXD2	*/
-	gpio_select_periph_B(GPIO_PIN_PC28, 0);	/* TXD3 */
-	gpio_select_periph_B(GPIO_PIN_PC29, 0);	/* RXD2	*/
-	gpio_select_periph_B(GPIO_PIN_PC30, 0);	/* RXD3	*/
-	gpio_select_periph_B(GPIO_PIN_PC24, 0);	/* RXCK	*/
-	gpio_select_periph_B(GPIO_PIN_PD15, 0);	/* SPD	*/
-#endif
-}
-#endif
-
-#ifdef AT32AP700x_CHIP_HAS_MMCI
-void gpio_enable_mmci(void)
-{
-	gpio_select_periph_A(GPIO_PIN_PA10, 0);	/* CLK	 */
-	gpio_select_periph_A(GPIO_PIN_PA11, 0);	/* CMD	 */
-	gpio_select_periph_A(GPIO_PIN_PA12, 0);	/* DATA0 */
-	gpio_select_periph_A(GPIO_PIN_PA13, 0);	/* DATA1 */
-	gpio_select_periph_A(GPIO_PIN_PA14, 0);	/* DATA2 */
-	gpio_select_periph_A(GPIO_PIN_PA15, 0);	/* DATA3 */
-}
-#endif
-
-#ifdef AT32AP700x_CHIP_HAS_SPI
-void gpio_enable_spi0(unsigned long cs_mask)
-{
-	gpio_select_periph_A(GPIO_PIN_PA0,  0);	/* MISO	*/
-	gpio_select_periph_A(GPIO_PIN_PA1,  0);	/* MOSI	*/
-	gpio_select_periph_A(GPIO_PIN_PA2,  0);	/* SCK	*/
-
-	/* Set up NPCSx as GPIO outputs, initially high */
-	if (cs_mask & (1 << 0)) {
-		gpio_set_value(GPIO_PIN_PA3, 1);
-		gpio_select_pio(GPIO_PIN_PA3, GPIOF_OUTPUT);
-	}
-	if (cs_mask & (1 << 1)) {
-		gpio_set_value(GPIO_PIN_PA4, 1);
-		gpio_select_pio(GPIO_PIN_PA4, GPIOF_OUTPUT);
-	}
-	if (cs_mask & (1 << 2)) {
-		gpio_set_value(GPIO_PIN_PA5, 1);
-		gpio_select_pio(GPIO_PIN_PA5, GPIOF_OUTPUT);
-	}
-	if (cs_mask & (1 << 3)) {
-		gpio_set_value(GPIO_PIN_PA20, 1);
-		gpio_select_pio(GPIO_PIN_PA20, GPIOF_OUTPUT);
-	}
-}
-
-void gpio_enable_spi1(unsigned long cs_mask)
-{
-	gpio_select_periph_B(GPIO_PIN_PA0,  0);	/* MISO	*/
-	gpio_select_periph_B(GPIO_PIN_PB1,  0);	/* MOSI	*/
-	gpio_select_periph_B(GPIO_PIN_PB5,  0);	/* SCK	*/
-
-	/* Set up NPCSx as GPIO outputs, initially high */
-	if (cs_mask & (1 << 0)) {
-		gpio_set_value(GPIO_PIN_PB2, 1);
-		gpio_select_pio(GPIO_PIN_PB2, GPIOF_OUTPUT);
-	}
-	if (cs_mask & (1 << 1)) {
-		gpio_set_value(GPIO_PIN_PB3, 1);
-		gpio_select_pio(GPIO_PIN_PB3, GPIOF_OUTPUT);
-	}
-	if (cs_mask & (1 << 2)) {
-		gpio_set_value(GPIO_PIN_PB4, 1);
-		gpio_select_pio(GPIO_PIN_PB4, GPIOF_OUTPUT);
-	}
-	if (cs_mask & (1 << 3)) {
-		gpio_set_value(GPIO_PIN_PA27, 1);
-		gpio_select_pio(GPIO_PIN_PA27, GPIOF_OUTPUT);
-	}
-}
-#endif
diff --git a/cpu/at32ap/at32ap700x/portmux.c b/cpu/at32ap/at32ap700x/portmux.c
new file mode 100644
index 0000000..da0c9c5
--- /dev/null
+++ b/cpu/at32ap/at32ap700x/portmux.c
@@ -0,0 +1,218 @@
+/*
+ * Copyright (C) 2006, 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+
+#include <asm/arch/chip-features.h>
+#include <asm/arch/memory-map.h>
+#include <asm/arch/portmux.h>
+
+/*
+ * Lots of small functions here. We depend on --gc-sections getting
+ * rid of the ones we don't need.
+ */
+void portmux_enable_ebi(unsigned int bus_width, unsigned int addr_width,
+		unsigned long flags, unsigned long drive_strength)
+{
+	unsigned long porte_mask = 0;
+
+	if (bus_width > 16)
+		portmux_select_peripheral(PORTMUX_PORT_E, 0xffff,
+				PORTMUX_FUNC_A, PORTMUX_BUSKEEPER);
+	if (addr_width > 23)
+		porte_mask |= (((1 << (addr_width - 23)) - 1) & 7) << 16;
+	if (flags & PORTMUX_EBI_CS(2))
+		porte_mask |= 1 << 25;
+	if (flags & PORTMUX_EBI_CS(4))
+		porte_mask |= 1 << 21;
+	if (flags & PORTMUX_EBI_CS(5))
+		porte_mask |= 1 << 22;
+	if (flags & (PORTMUX_EBI_CF(0) | PORTMUX_EBI_CF(1)))
+		porte_mask |= (1 << 19) | (1 << 20) | (1 << 23);
+
+	portmux_select_peripheral(PORTMUX_PORT_E, porte_mask,
+			PORTMUX_FUNC_A, 0);
+
+	if (flags & PORTMUX_EBI_NWAIT)
+		portmux_select_peripheral(PORTMUX_PORT_E, 1 << 24,
+				PORTMUX_FUNC_A, PORTMUX_PULL_UP);
+}
+
+#ifdef AT32AP700x_CHIP_HAS_MACB
+void portmux_enable_macb0(unsigned long flags, unsigned long drive_strength)
+{
+	unsigned long portc_mask;
+
+	portc_mask = (1 << 3)	/* TXD0	*/
+		| (1 << 4)	/* TXD1	*/
+		| (1 << 7)	/* TXEN	*/
+		| (1 << 8)	/* TXCK */
+		| (1 << 9)	/* RXD0	*/
+		| (1 << 10)	/* RXD1	*/
+		| (1 << 13)	/* RXER	*/
+		| (1 << 15)	/* RXDV	*/
+		| (1 << 16)	/* MDC	*/
+		| (1 << 17);	/* MDIO	*/
+
+	if (flags & PORTMUX_MACB_MII)
+		portc_mask |= (1 << 0)	/* COL	*/
+			| (1 << 1)	/* CRS	*/
+			| (1 << 2)	/* TXER	*/
+			| (1 << 5)	/* TXD2	*/
+			| (1 << 6)	/* TXD3 */
+			| (1 << 11)	/* RXD2	*/
+			| (1 << 12)	/* RXD3	*/
+			| (1 << 14);	/* RXCK	*/
+
+	if (flags & PORTMUX_MACB_SPEED)
+		portc_mask |= (1 << 18);/* SPD	*/
+
+	/* REVISIT: Some pins are probably pure outputs */
+	portmux_select_peripheral(PORTMUX_PORT_C, portc_mask,
+			PORTMUX_FUNC_A, PORTMUX_BUSKEEPER);
+}
+
+void portmux_enable_macb1(unsigned long flags, unsigned long drive_strength)
+{
+	unsigned long portc_mask = 0;
+	unsigned long portd_mask;
+
+	portd_mask = (1 << 13)	/* TXD0	*/
+		| (1 << 14)	/* TXD1	*/
+		| (1 << 11)	/* TXEN	*/
+		| (1 << 12)	/* TXCK */
+		| (1 << 10)	/* RXD0	*/
+		| (1 << 6)	/* RXD1	*/
+		| (1 << 5)	/* RXER	*/
+		| (1 << 4)	/* RXDV	*/
+		| (1 << 3)	/* MDC	*/
+		| (1 << 2);	/* MDIO	*/
+
+	if (flags & PORTMUX_MACB_MII)
+		portc_mask = (1 << 19)	/* COL	*/
+			| (1 << 23)	/* CRS	*/
+			| (1 << 26)	/* TXER	*/
+			| (1 << 27)	/* TXD2	*/
+			| (1 << 28)	/* TXD3 */
+			| (1 << 29)	/* RXD2	*/
+			| (1 << 30)	/* RXD3	*/
+			| (1 << 24);	/* RXCK	*/
+
+	if (flags & PORTMUX_MACB_SPEED)
+		portd_mask |= (1 << 15);/* SPD	*/
+
+	/* REVISIT: Some pins are probably pure outputs */
+	portmux_select_peripheral(PORTMUX_PORT_D, portc_mask,
+			PORTMUX_FUNC_B, PORTMUX_BUSKEEPER);
+	portmux_select_peripheral(PORTMUX_PORT_C, portc_mask,
+			PORTMUX_FUNC_B, PORTMUX_BUSKEEPER);
+}
+#endif
+
+#ifdef AT32AP700x_CHIP_HAS_MMCI
+void portmux_enable_mmci(unsigned int slot, unsigned long flags,
+		unsigned long drive_strength)
+{
+	unsigned long mask;
+	unsigned long portmux_flags = PORTMUX_PULL_UP;
+
+	/* First, the common CLK signal. It doesn't need a pull-up */
+	portmux_select_peripheral(PORTMUX_PORT_A, 1 << 10,
+			PORTMUX_FUNC_A, 0);
+
+	if (flags & PORTMUX_MMCI_EXT_PULLUP)
+		portmux_flags = 0;
+
+	/* Then, the per-slot signals */
+	switch (slot) {
+	case 0:
+		mask = (1 << 11) | (1 << 12);	/* CMD and DATA0 */
+		if (flags & PORTMUX_MMCI_4BIT)
+			/* DATA1..DATA3 */
+			mask |= (1 << 13) | (1 << 14) | (1 << 15);
+		portmux_select_peripheral(PORTMUX_PORT_A, mask,
+				PORTMUX_FUNC_A, portmux_flags);
+		break;
+	case 1:
+		mask = (1 << 6) | (1 << 7);	/* CMD and DATA0 */
+		if (flags & PORTMUX_MMCI_4BIT)
+			/* DATA1..DATA3 */
+			mask |= (1 << 8) | (1 << 9) | (1 << 10);
+		portmux_select_peripheral(PORTMUX_PORT_B, mask,
+				PORTMUX_FUNC_B, portmux_flags);
+		break;
+	}
+}
+#endif
+
+#ifdef AT32AP700x_CHIP_HAS_SPI
+void portmux_enable_spi0(unsigned long cs_mask, unsigned long drive_strength)
+{
+	unsigned long pin_mask;
+
+	/* MOSI and SCK */
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 1) | (1 << 2),
+			PORTMUX_FUNC_A, 0);
+	/* MISO may float */
+	portmux_select_peripheral(PORTMUX_PORT_A, 1 << 0,
+			PORTMUX_FUNC_A, PORTMUX_BUSKEEPER);
+
+	/* Set up NPCSx as GPIO outputs, initially high */
+	pin_mask = (cs_mask & 7) << 3;
+	if (cs_mask & (1 << 3))
+		pin_mask |= 1 << 20;
+
+	portmux_select_gpio(PORTMUX_PORT_A, pin_mask,
+			PORTMUX_DIR_OUTPUT | PORTMUX_INIT_HIGH);
+}
+
+void portmux_enable_spi1(unsigned long cs_mask, unsigned long drive_strength)
+{
+	/* MOSI and SCK */
+	portmux_select_peripheral(PORTMUX_PORT_B, (1 << 1) | (1 << 5),
+			PORTMUX_FUNC_B, 0);
+	/* MISO may float */
+	portmux_select_peripheral(PORTMUX_PORT_B, 1 << 0,
+			PORTMUX_FUNC_B, PORTMUX_BUSKEEPER);
+
+	/* Set up NPCSx as GPIO outputs, initially high */
+	portmux_select_gpio(PORTMUX_PORT_B, (cs_mask & 7) << 2,
+			PORTMUX_DIR_OUTPUT | PORTMUX_INIT_HIGH);
+	portmux_select_gpio(PORTMUX_PORT_A, (cs_mask & 8) << (27 - 3),
+			PORTMUX_DIR_OUTPUT | PORTMUX_INIT_HIGH);
+}
+#endif
+
+#ifdef AT32AP700x_CHIP_HAS_LCDC
+void portmux_enable_lcdc(void)
+{
+	/*
+	 * FIXME: We want to allow the board much more control over
+	 * which pins to enable
+	 */
+	portmux_select_peripheral(PORTMUX_PORT_C, 0xfff80000,
+			PORTMUX_FUNC_A, 0);
+	portmux_select_peripheral(PORTMUX_PORT_D, 0x0003ffff,
+			PORTMUX_FUNC_A, 0);
+}
+#endif
diff --git a/cpu/at32ap/at32ap700x/sm.h b/cpu/at32ap/at32ap700x/sm.h
index 6492c8e..b6e4409 100644
--- a/cpu/at32ap/at32ap700x/sm.h
+++ b/cpu/at32ap/at32ap700x/sm.h
@@ -21,7 +21,7 @@
 #define SM_PM_IMR				0x0048
 #define SM_PM_ISR				0x004c
 #define SM_PM_ICR				0x0050
-#define SM_PM_GCCTRL				0x0060
+#define SM_PM_GCCTRL(x)				(0x0060 + 4 * x)
 #define SM_RTC_CTRL				0x0080
 #define SM_RTC_VAL				0x0084
 #define SM_RTC_TOP				0x0088
diff --git a/cpu/at32ap/at32ap720x/Makefile b/cpu/at32ap/at32ap720x/Makefile
new file mode 100644
index 0000000..0a12d0e
--- /dev/null
+++ b/cpu/at32ap/at32ap720x/Makefile
@@ -0,0 +1,44 @@
+#
+# Copyright (C) 2008 Atmel Corporation
+#
+# See file CREDITS for list of people who contributed to this
+# project.
+#
+# This program is free software; you can redistribute it and/or
+# modify it under the terms of the GNU General Public License as
+# published by the Free Software Foundation; either version 2 of
+# the License, or (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, write to the Free Software
+# Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+# MA 02111-1307 USA
+#
+
+include $(TOPDIR)/config.mk
+
+LIB	:= $(obj)lib$(SOC).a
+
+SOBJS	:= start.o
+COBJS	:= portmux.o clk.o
+SRCS	:= $(SOBJS:.o=.S) $(COBJS:.o=.c)
+OBJS	:= $(addprefix $(obj),$(SOBJS) $(COBJS))
+
+all: $(obj).depend $(LIB)
+
+$(LIB): $(OBJS)
+	$(AR) $(ARFLAGS) $@ $^
+
+#########################################################################
+
+# defines $(obj).depend target
+include $(SRCTREE)/rules.mk
+
+sinclude $(obj).depend
+
+#########################################################################
diff --git a/cpu/at32ap/at32ap720x/clk.c b/cpu/at32ap/at32ap720x/clk.c
new file mode 100644
index 0000000..e3f3e55
--- /dev/null
+++ b/cpu/at32ap/at32ap720x/clk.c
@@ -0,0 +1,118 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+
+#include <asm/arch/clk.h>
+#include <asm/arch/memory-map.h>
+
+#include "pm.h"
+
+#if CFG_PLL0_MUL <= 1
+# error CFG_PLL0_MUL must be higher than 1
+#endif
+
+/* Undefined function. Will trigger link error when PLL rate is too high */
+extern void __pll_rate_too_high(void);
+
+void clk_init(void)
+{
+	uint32_t cksel;
+
+#ifdef CONFIG_PLL
+	uint32_t mcctrl;
+	unsigned int pllopt;
+
+	if (MAIN_CLK_RATE < 50000000)
+		pllopt = 0;
+	else if (MAIN_CLK_RATE < 100000000)
+		pllopt = 1;
+	else if (MAIN_CLK_RATE < 200000000)
+		pllopt = 2;
+	else if (MAIN_CLK_RATE < 400000000)
+		pllopt = 3;
+	else
+		__pll_rate_too_high();
+
+	/* Start the PLL */
+	pm_writel(PLL[0], PM_BF(PLLx_PLLCOUNT, CFG_PLL0_SUPPRESS_CYCLES)
+				| PM_BF(PLLx_PLLMUL, CFG_PLL0_MUL)
+				| PM_BF(PLLx_PLLDIV, CFG_PLL0_DIV)
+				| PM_BF(PLLx_PLLOPT, pllopt)
+				| PM_BF(PLLx_PLLOSC, 0)
+				| PM_BIT(PLLx_PLLEN));
+
+	/* Wait for lock */
+	while (!(pm_readl(POSCSR) & PM_BIT(POSCSR_LOCK0)))
+		continue;
+#endif
+
+	/* Set up clocks for the CPU and all peripheral buses */
+	cksel = 0;
+	if (CFG_CLKDIV_CPU)
+		cksel |= PM_BIT(CKSEL_CPUDIV)
+				| PM_BF(CKSEL_CPUSEL, CFG_CLKDIV_CPU - 1);
+	if (CFG_CLKDIV_HSB)
+		cksel |= PM_BIT(CKSEL_HSBDIV)
+				| PM_BF(CKSEL_HSBSEL, CFG_CLKDIV_HSB - 1);
+	if (CFG_CLKDIV_PBA)
+		cksel |= PM_BIT(CKSEL_PBADIV)
+				| PM_BF(CKSEL_PBASEL, CFG_CLKDIV_PBA - 1);
+	if (CFG_CLKDIV_PBB)
+		cksel |= PM_BIT(CKSEL_PBBDIV)
+				| PM_BF(CKSEL_PBBSEL, CFG_CLKDIV_PBB - 1);
+	pm_writel(CKSEL, cksel);
+
+#ifdef CONFIG_PLL
+	/* Use PLL0 as main clock */
+	mcctrl = pm_readl(MCCTRL);
+	mcctrl = PM_BFINS(MCCTRL_MCSEL, PM_MCSEL_PLL0, mcctrl);
+	pm_writel(MCCTRL, mcctrl);
+#endif
+}
+
+unsigned long __gclk_set_rate(unsigned int id, enum gclk_parent parent,
+		unsigned long rate, unsigned long parent_rate)
+{
+	unsigned long divider;
+
+	if (rate == 0 || parent_rate == 0) {
+		pm_writel(GCCTRL[id], 0);
+		return 0;
+	}
+
+	divider = (parent_rate + rate / 2) / rate;
+	if (divider <= 1) {
+		pm_writel(GCCTRL[id], PM_BF(GCCTRL_OSCSEL, parent)
+				| PM_BIT(GCCTRL_CEN));
+		rate = parent_rate;
+	} else {
+		divider = min(255, divider / 2 - 1);
+		pm_writel(GCCTRL[id], PM_BF(GCCTRL_OSCSEL, parent)
+				| PM_BIT(GCCTRL_CEN) | PM_BIT(GCCTRL_DIVEN)
+				| PM_BF(GCCTRL_DIV, divider));
+		rate = parent_rate / (2 * (divider + 1));
+	}
+
+	return rate;
+}
diff --git a/cpu/at32ap/at32ap720x/pm.h b/cpu/at32ap/at32ap720x/pm.h
new file mode 100644
index 0000000..c7ce09d
--- /dev/null
+++ b/cpu/at32ap/at32ap720x/pm.h
@@ -0,0 +1,301 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __AT32AP7200_PM_H__
+#define __AT32AP7200_PM_H__
+
+/* PM Register offsets */
+#ifndef __ASSEMBLY__
+struct pm_regs {
+	u32	MCCTRL;			/* Main Clock Control */
+	u32	CKSEL;			/* Clock Select */
+	u32	CPUMASK;		/* CPU Clock Mask */
+	u32	HSBMASK;		/* HSB Clock Mask */
+	u32	PBAMASK;		/* PBA Clock Mask */
+	u32	PBBMASK;		/* PBB Clock Mask */
+	u32	PBADIVMASK;		/* Divided PBA Clock Mask */
+	u32	PBBDIVMASK;		/* Divided PBB Clock Mask */
+	u32	__reserved1[8];
+	u32	PLL[3];			/* PLL Control */
+	u32	__reserved2[13];
+	u32	OSCCTRL[3];		/* Oscillator Control */
+	u32	__reserved3[5];
+	u32	OSCCTRL32;		/* 32 kHz Oscillator Control */
+	u32	__reserved4[7];
+	u32	IER;			/* Interrupt Enable */
+	u32	IDR;			/* Interrupt Disable */
+	u32	IMR;			/* Interrupt Mask */
+	u32	ISR;			/* Interrupt Status */
+	u32	ICR;			/* Interrupt Clear */
+	u32	POSCSR;			/* Power and Oscillator Status */
+	u32	__reserved5[10];
+	u32	GCCTRL[8];		/* Generic Clock Control */
+	u32	__reserved6[8];
+	u32	RCCR;			/* RC Oscillator Calibration */
+	u32	BGCR;			/* Bandgap Calibration */
+	u32	VREGCR;			/* Buck Regulator Calibration */
+	u32	BOD;			/* BOD Level */
+	u32	PPCR;			/* Peripheral Power Control */
+	u32	__reserved7[11];
+	u32	RC_RCAUSE;		/* Reset Cause */
+	u32	WCAUSE;			/* Wake Cause */
+	u32	AWEN;			/* Asynchronous Wake Enable */
+	u32	__reserved8[14];
+	u32	GPLP;			/* General Purpose Low-Power */
+};
+#endif
+
+/* Assembly-friendly register offsets; same as above */
+#define PM_MCCTRL			0x0000
+#define PM_CKSEL			0x0004
+#define PM_CPUMASK			0x0008
+#define PM_HSBMASK			0x000c
+#define PM_PBAMASK			0x0010
+#define PM_PBBMASK			0x0014
+#define PM_PBADIVMASK			0x0018
+#define PM_PBBDIVMASK			0x001c
+#define PM_PLL0				0x0040
+#define PM_PLL1				0x0044
+#define PM_PLL2				0x0048
+#define PM_OSCCTRL0			0x0080
+#define PM_OSCCTRL1			0x0084
+#define PM_OSCCTRL2			0x0088
+#define PM_OSCCTRL32			0x00a0
+#define PM_IER				0x00c0
+#define PM_IDR				0x00c4
+#define PM_IMR				0x00c8
+#define PM_ISR				0x00cc
+#define PM_ICR				0x00d0
+#define PM_POSCSR			0x00d4
+#define PM_GCCTRL			0x0100
+#define PM_RCCR				0x0140
+#define PM_BGCR				0x0144
+#define PM_VREGCR			0x0148
+#define PM_BOD				0x014c
+#define PM_PPCR				0x0150
+#define PM_RC_RCAUSE			0x0180
+#define PM_WCAUSE			0x0184
+#define PM_AWEN				0x0188
+#define PM_GPLP				0x01c0
+
+/* Bits in MCCTRL */
+#define PM_MCCTRL_MCSEL_START		0
+#define PM_MCCTRL_MCSEL_SIZE		2
+#define PM_MCCTRL_OSC0EN_BIT		2
+#define PM_MCCTRL_OSC1EN_BIT		3
+#define PM_MCCTRL_OSC2EN_BIT		4
+#define PM_MCCTRL_CRIPEL_BIT		24
+
+/* Bits in CKSEL */
+#define PM_CKSEL_CPUSEL_START		0
+#define PM_CKSEL_CPUSEL_SIZE		3
+#define PM_CKSEL_CPUDIV_BIT		7
+#define PM_CKSEL_HSBSEL_START		8
+#define PM_CKSEL_HSBSEL_SIZE		3
+#define PM_CKSEL_HSBDIV_BIT		15
+#define PM_CKSEL_PBASEL_START		16
+#define PM_CKSEL_PBASEL_SIZE		3
+#define PM_CKSEL_PBADIV_BIT		23
+#define PM_CKSEL_PBBSEL_START		24
+#define PM_CKSEL_PBBSEL_SIZE		3
+#define PM_CKSEL_PBBDIV_BIT		31
+
+/* Bits in CPUMASK */
+#define PM_CPUMASK_SYSTIMER_BIT		16
+
+/* Bits in PLLx */
+#define PM_PLLx_PLLEN_BIT		0
+#define PM_PLLx_PLLOSC_START		1
+#define PM_PLLx_PLLOSC_SIZE		2
+#define PM_PLLx_PLLOPT_START		3
+#define PM_PLLx_PLLOPT_SIZE		3
+#define PM_PLLx_PLLBPL_BIT		7
+#define PM_PLLx_PLLDIV_START		8
+#define PM_PLLx_PLLDIV_SIZE		6
+#define PM_PLLx_PLLMUL_START		16
+#define PM_PLLx_PLLMUL_SIZE		6
+#define PM_PLLx_PLLCOUNT_START		24
+#define PM_PLLx_PLLCOUNT_SIZE		6
+#define PM_PLLx_PLLIOTESTEN_BIT		30
+#define PM_PLLx_PLLTEST_BIT		31
+
+/* Bits in OSCCTRLx */
+#define PM_OSCCTRLx_MODE_START		0
+#define PM_OSCCTRLx_MODE_SIZE		4
+#define PM_OSCCTRLx_STARTUP_START	8
+#define PM_OSCCTRLx_STARTUP_SIZE	3
+
+/* Bits in OSCCTRL32 */
+#define PM_OSCCTRL32_OSC32EN_BIT	0
+#define PM_OSCCTRL32_MODE_START		8
+#define PM_OSCCTRL32_MODE_SIZE		3
+#define PM_OSCCTRL32_STARTUP_START	16
+#define PM_OSCCTRL32_STARTUP_SIZE	3
+
+/* Bits in IER/IDR/IMR/ISR/ICR */
+#define PM_ISR_OSC0RDY_BIT		0
+#define PM_ISR_OSC1RDY_BIT		1
+#define PM_ISR_OSC2RDY_BIT		2
+#define PM_ISR_OSC32RDY_BIT		7
+#define PM_ISR_LOCK0_BIT		8
+#define PM_ISR_LOCK1_BIT		9
+#define PM_ISR_LOCK2_BIT		10
+#define PM_ISR_LOCK0LOST_BIT		16
+#define PM_ISR_LOCK1LOST_BIT		17
+#define PM_ISR_LOCK2LOST_BIT		18
+#define PM_ISR_CKRDY_BIT		24
+#define PM_ISR_MSKRDY_BIT		25
+#define PM_ISR_WAKE_BIT			26
+#define PM_ISR_BODDET_BIT		27
+#define PM_ISR_PERRDY_BIT		28
+
+/* Bits in POSCSR */
+#define PM_POSCSR_OSC0RDY_BIT		0
+#define PM_POSCSR_OSC1RDY_BIT		1
+#define PM_POSCSR_OSC32RDY_BIT		7
+#define PM_POSCSR_LOCK0_BIT		8
+#define PM_POSCSR_LOCK1_BIT		9
+#define PM_POSCSR_LOCK0LOST_BIT		16
+#define PM_POSCSR_LOCK1LOST_BIT		17
+#define PM_POSCSR_CKRDY_BIT		24
+#define PM_POSCSR_MSKRDY_BIT		25
+#define PM_POSCSR_WAKE_BIT		26
+#define PM_POSCSR_BODDET_BIT		27
+#define PM_POSCSR_PERRDY_BIT		28
+
+/* Bits in GCCTRL */
+#define PM_GCCTRL_CEN_BIT		0
+#define PM_GCCTRL_DIVEN_BIT		1
+#define PM_GCCTRL_OSCSEL_START		8
+#define PM_GCCTRL_OSCSEL_SIZE		4
+#define PM_GCCTRL_DIV_START		16
+#define PM_GCCTRL_DIV_SIZE		8
+
+/* Bits in RCCR */
+#define PM_RCCR_CALIB_START		0
+#define PM_RCCR_CALIB_SIZE		10
+#define PM_RCCR_FCD_BIT			16
+#define PM_RCCR_KEY_START		24
+#define PM_RCCR_KEY_SIZE		8
+
+/* Bits in BGCR */
+#define PM_BGCR_CALIB_START		0
+#define PM_BGCR_CALIB_SIZE		3
+#define PM_BGCR_FCD_BIT			16
+#define PM_BGCR_KEY_START		24
+#define PM_BGCR_KEY_SIZE		8
+
+/* Bits in VREGCR */
+#define PM_VREGCR_CALIB_START		0
+#define PM_VREGCR_CALIB_SIZE		3
+#define PM_VREGCR_FCD_BIT		16
+#define PM_VREGCR_KEY_START		24
+#define PM_VREGCR_KEY_SIZE		8
+
+/* Bits in BOD */
+#define PM_BOD_LEVEL_START		0
+#define PM_BOD_LEVEL_SIZE		6
+#define PM_BOD_HYST_BIT			6
+#define PM_BOD_CTRL_START		8
+#define PM_BOD_CTRL_SIZE		2
+#define PM_BOD_FCD_BIT			16
+#define PM_BOD_KEY_START		24
+#define PM_BOD_KEY_SIZE			8
+
+/* Bits in PPCR */
+#define PM_PPCR_EBI_VOLT_BIT		0
+#define PM_PPCR_UTMI_CTRL_BIT		1
+#define PM_PPCR_KEY_START		24
+#define PM_PPCR_KEY_SIZE		8
+
+/* Bits in RC_RCAUSE */
+#define PM_RC_RCAUSE_POR_BIT		0
+#define PM_RC_RCAUSE_BOD_BIT		1
+#define PM_RC_RCAUSE_EXT_BIT		2
+#define PM_RC_RCAUSE_WDT_BIT		3
+#define PM_RC_RCAUSE_JTAG_BIT		4
+#define PM_RC_RCAUSE_NTAE_BIT		5
+#define PM_RC_RCAUSE_SLEEP_BIT		6
+#define PM_RC_RCAUSE_CPUERR_BIT		7
+#define PM_RC_RCAUSE_OCDRST_BIT		8
+#define PM_RC_RCAUSE_JTAGHARD_BIT	9
+
+/* Bits in WCAUSE */
+#define PM_WCAUSE_PERIPH0_BIT		0
+#define PM_WCAUSE_PERIPH1_BIT		1
+#define PM_WCAUSE_EIC_BIT		16
+#define PM_WCAUSE_RTC_BIT		17
+
+/* Constants for MCCTRL:MCSEL */
+#define PM_MCSEL_SLOW			0
+#define PM_MCSEL_OSC0			1
+#define PM_MCSEL_PLL0			2
+
+/* Constants for OSCCTRLx:MODE */
+#define PM_MODE_EXT_CLOCK		0
+#define PM_MODE_CRYSTAL_ACG		1
+#define PM_MODE_CRYSTAL_G0		4
+#define PM_MODE_CRYSTAL_G1		5
+#define PM_MODE_CRYSTAL_G2		6
+#define PM_MODE_CRYSTAL_G3		7
+
+/* Constants for GCCTRL:OSCSEL */
+#define PM_OSCSEL_SLOW			0
+#define PM_OSCSEL_CLK32			1
+#define PM_OSCSEL_OSC0			2
+#define PM_OSCSEL_OSC1			3
+#define PM_OSCSEL_PLL0			4
+#define PM_OSCSEL_PLL1			5
+
+/* Constants for BOD:CTRL */
+#define PM_CTRL_OFF1			0
+#define PM_CTRL_ENABLED			1
+#define PM_CTRL_ENABLED_NORESET		2
+#define PM_CTRL_OFF2			3
+
+/* Bit manipulation macros */
+#define PM_BIT(name)						\
+	(1 << PM_##name##_BIT)
+#define PM_BF(name,value)					\
+	(((value) & ((1 << PM_##name##_SIZE) - 1))		\
+	 << PM_##name##_START)
+#define PM_BFEXT(name,value)					\
+	(((value) >> PM_##name##_START)				\
+	 & ((1 << PM_##name##_SIZE) - 1))
+#define PM_BFINS(name,value,old)				\
+	(((old) & ~(((1 << PM_##name##_SIZE) - 1)		\
+		    << PM_##name##_START))			\
+	 | PM_BF(name,value))
+
+/* Register access macros */
+#if 1
+#define pm_readl(reg)						\
+	__raw_readl(&((struct pm_regs *)PM_BASE)->reg)
+#define pm_writel(reg, value)					\
+	__raw_writel(value, &((struct pm_regs *)PM_BASE)->reg)
+#else
+#define pm_readl(reg) \
+	__raw_readl((void *)(PM_BASE + PM_##reg))
+#define pm_writel(reg, value) \
+	__raw_writel(value, (void *)(PM_BASE + PM_##reg))
+#endif
+
+#endif /* __AT32AP7200_PM_H__ */
diff --git a/cpu/at32ap/at32ap720x/portmux.c b/cpu/at32ap/at32ap720x/portmux.c
new file mode 100644
index 0000000..9697948
--- /dev/null
+++ b/cpu/at32ap/at32ap720x/portmux.c
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/arch/portmux.h>
+
+void portmux_enable_ebi(unsigned int bus_width, unsigned int addr_width,
+		unsigned long flags, unsigned long drive_strength)
+{
+	unsigned long mask;
+
+	drive_strength &= PORTMUX_DRIVE_MAX;
+
+	/* Address 0..13 and standard control signals. No bus keeper
+	 * or pull-up needed */
+	portmux_select_peripheral(PORTMUX_PORT_X0, 0xc0003fff,
+			PORTMUX_FUNC_A, drive_strength);
+	portmux_select_peripheral(PORTMUX_PORT_X1, 0x000001ff,
+			PORTMUX_FUNC_A, drive_strength);
+
+	/* Data lines 0..15 are always enabled. Use bus keeper feature
+	 * to keep idle power consumption down. */
+	portmux_select_peripheral(PORTMUX_PORT_X0, 0x3fffc000, PORTMUX_FUNC_A,
+			drive_strength | PORTMUX_BUSKEEPER);
+
+	/* Optional address and control signals in port E */
+	mask = ((1 << (addr_width - 13)) - 1) & 0x00000fff;
+	if (bus_width > 16) {
+		/* Data lines 16..31 */
+		portmux_select_peripheral(PORTMUX_PORT_E, 0x0ffff000,
+				PORTMUX_FUNC_A,
+				drive_strength | PORTMUX_BUSKEEPER);
+
+		/* NWE3/DQM3 */
+		mask |= 1 << 28;
+	}
+
+	if (flags & PORTMUX_EBI_CS(2))
+		mask |= 1 << 29;
+	if (flags & PORTMUX_EBI_CS(4))
+		mask |= 1 << 30;
+	if (flags & PORTMUX_EBI_CS(5))
+		mask |= 1 << 31;
+
+	portmux_select_peripheral(PORTMUX_PORT_E, mask, PORTMUX_FUNC_A,
+			drive_strength | PORTMUX_BUSKEEPER);
+
+	mask = 0;
+	if (flags & PORTMUX_EBI_NAND)
+		/* NANDOE and NANDWE */
+		mask |= (1 << 0) | (1 << 1);
+	if (flags & PORTMUX_EBI_CS(3))
+		mask |= 1 << 2;
+
+	portmux_select_peripheral(PORTMUX_PORT_F, mask, PORTMUX_FUNC_A,
+			drive_strength);
+
+	if (flags & (PORTMUX_EBI_CF(0) | PORTMUX_EBI_CF(1)))
+		/* CFNRW, CFCE2 and CFCE1 */
+		portmux_select_peripheral(PORTMUX_PORT_C,
+				(1 << 7) | (1 << 8) | (1 << 9),
+				PORTMUX_FUNC_D, drive_strength);
+
+	if (flags & PORTMUX_EBI_NWAIT)
+		portmux_select_peripheral(PORTMUX_PORT_C, 1 << 6,
+				PORTMUX_FUNC_D,
+				drive_strength | PORTMUX_PULL_UP);
+}
+
+void portmux_enable_macb0(unsigned long flags, unsigned long drive_strength)
+{
+	unsigned long porta_mask;
+	unsigned long portc_mask;
+
+	porta_mask = (1 << 4);	/* RXDV	*/
+	portc_mask = (1 << 10)	/* MDC	*/
+		| (1 << 11)	/* MDIO	*/
+		| (1 << 12)	/* TXCK	*/
+		| (1 << 14)	/* RXD0	*/
+		| (1 << 15)	/* RXD1	*/
+		| (1 << 16)	/* RXER	*/
+		| (1 << 18)	/* TXEN	*/
+		| (1 << 19)	/* TXD0	*/
+		| (1 << 20);	/* TXD1	*/
+
+	if (flags & PORTMUX_MACB_MII) {
+		porta_mask |= (1 << 0)	/* COL	*/
+			| (1 << 1)	/* RXD2	*/
+			| (1 << 2)	/* RXD3	*/
+			| (1 << 3)	/* RXCK	*/
+			| (1 << 5)	/* TXER	*/
+			| (1 << 6)	/* TXD2	*/
+			| (1 << 7);	/* TXD3	*/
+		portc_mask |= (1 << 13);/* CRS	*/
+	}
+
+	if (flags & PORTMUX_MACB_SPEED)
+		portc_mask |= (1 << 17);/* SPD	*/
+
+	/* REVISIT: Some pins are probably pure outputs */
+	portmux_select_peripheral(PORTMUX_PORT_A, porta_mask,
+			PORTMUX_FUNC_B, drive_strength | PORTMUX_BUSKEEPER);
+	portmux_select_peripheral(PORTMUX_PORT_C, portc_mask,
+			PORTMUX_FUNC_C, drive_strength | PORTMUX_BUSKEEPER);
+}
+
+void portmux_enable_mmci(unsigned int slot, unsigned long flags,
+		unsigned long drive_strength)
+{
+	unsigned long mask;
+	unsigned long portmux_flags = drive_strength | PORTMUX_PULL_UP;
+
+	if (flags & PORTMUX_MMCI_EXT_PULLUP)
+		portmux_flags = drive_strength;
+
+	switch (slot) {
+	case 0:
+		/* First, the CLK signal. It doesn't need a pull-up */
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 16,
+				PORTMUX_FUNC_A, drive_strength);
+
+		mask = (1 << 17) | (1 << 18);	/* CMD and DATA0 */
+		if (flags & PORTMUX_MMCI_4BIT)
+			/* DATA1..DATA3 */
+			mask |= (1 << 19) | (1 << 20) | (1 << 21);
+
+		portmux_select_peripheral(PORTMUX_PORT_B, mask,
+				PORTMUX_FUNC_A, portmux_flags);
+
+		if (flags & PORTMUX_MMCI_8BIT)
+			/* DATA4..DATA7 */
+			portmux_select_peripheral(PORTMUX_PORT_A,
+					(1 << 20) | (1 << 21)
+					| (1 << 22) | (1 << 23),
+					PORTMUX_FUNC_D, portmux_flags);
+		break;
+
+	case 1:
+		/* First, the CLK signal. It doesn't need a pull-up */
+		portmux_select_peripheral(PORTMUX_PORT_C, 1 << 0,
+				PORTMUX_FUNC_A, drive_strength);
+
+		mask = (1 << 1) | (1 << 2);	/* CMD and DATA0 */
+		if (flags & PORTMUX_MMCI_4BIT)
+			/* DATA1..DATA3 */
+			mask |= (1 << 3) | (1 << 4) | (1 << 5);
+		if (flags & PORTMUX_MMCI_8BIT)
+			/* DATA4..DATA7 */
+			mask |= (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9);
+
+		portmux_select_peripheral(PORTMUX_PORT_C, mask,
+				PORTMUX_FUNC_A, portmux_flags);
+		break;
+	}
+}
+
+void portmux_enable_spi0(unsigned long cs_mask, unsigned long drive_strength)
+{
+	/* MOSI and SCK */
+	portmux_select_peripheral(PORTMUX_PORT_B, (1 << 0) | (1 << 2),
+			PORTMUX_FUNC_A, drive_strength);
+
+	/* MISO may float */
+	portmux_select_peripheral(PORTMUX_PORT_B, 1 << 1,
+			PORTMUX_FUNC_A, drive_strength | PORTMUX_BUSKEEPER);
+
+	/* Set up NPCSx as GPIO outputs, initially high */
+	portmux_select_gpio(PORTMUX_PORT_B, (cs_mask & 15) << 3,
+			drive_strength | PORTMUX_DIR_OUTPUT
+			| PORTMUX_INIT_HIGH);
+}
+
+/* FIXME: allow much more flexibility */
+void portmux_enable_lcdc(void)
+{
+	portmux_select_peripheral(PORTMUX_PORT_D, 0x7fffffff,
+			PORTMUX_FUNC_A, PORTMUX_DRIVE_LOW);
+}
diff --git a/cpu/at32ap/at32ap720x/start.S b/cpu/at32ap/at32ap720x/start.S
new file mode 100644
index 0000000..023310a
--- /dev/null
+++ b/cpu/at32ap/at32ap720x/start.S
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2005-2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <config.h>
+
+#include <asm/sysreg.h>
+
+#include <asm/arch/memory-map.h>
+
+#include "pm.h"
+
+#define CPUCR_INIT (SYSREG_BIT(BI) | SYSREG_BIT(BE)			\
+		    | SYSREG_BIT(FE) | SYSREG_BIT(RE)			\
+		    | SYSREG_BIT(IBE) | SYSREG_BIT(IEE))
+
+/*
+ * OSC0_STARTUP is the value written to the STARTUP bitfield in
+ * PM_OSCCTRL0.
+ *
+ * OSC0_STARTUP_TIMEOUT is the corresponding number of RC oscillator
+ * cycles + 25%
+ */
+#if CFG_OSC0_STARTUP_US == 0
+# define OSC0_STARTUP		0
+# define OSC0_STARTUP_TIMEOUT	8
+#elif CFG_OSC0_STARTUP_US <= 727
+# define OSC0_STARTUP		1
+# define OSC0_STARTUP_TIMEOUT	40
+#elif CFG_OSC0_STARTUP_US <= 1500
+# define OSC0_STARTUP		2
+# define OSC0_STARTUP		80
+#elif CFG_OSC0_STARTUP_US <= 12000
+# define OSC0_STARTUP		3
+# define OSC0_STARTUP_TIMEOUT	640
+#elif CFG_OSC0_STARTUP_US <= 23000
+# define OSC0_STARTUP		4
+# define OSC0_STARTUP_TIMEOUT	1280
+#elif CFG_OSC0_STARTUP_US <= 93000
+# define OSC0_STARTUP		5
+# define OSC0_STARTUP_TIMEOUT	5120
+#elif CFG_OSC0_STARTUP_US <= 186000
+# define OSC0_STARTUP		6
+# define OSC0_STARTUP_TIMEOUT	10240
+#elif CFG_OSC0_STARTUP_US <= 372000
+# define OSC0_STARTUP		7
+# define OSC0_STARTUP_TIMEOUT	20480
+#else
+# error CFG_OSC0_STARTUP_US is too high
+#endif
+
+#if CFG_OSC0_MODE & ~15
+# error CFG_OSC0_MODE is invalid
+#endif
+
+#define OSCCTRL0_VALUE	((OSC0_STARTUP << 8) | CFG_OSC0_MODE)
+
+/*
+ * After reset, we have to assume that the internal RC oscillator is
+ * the only one running. It has a nominal frequency of 32 kHz, but it
+ * may be running at anything between 20 kHz and 44 kHz. So in order
+ * to make our timeouts long enough to handle all cases, we assume
+ * it's running at 44 kHz.
+ *
+ * The 32 kHz crystal oscillator may already be running when we enter
+ * this code. We must make sure we don't disable it, or we'll mess up
+ * the RTC.
+ */
+#define RCOSC_MAX_RATE	44000
+
+/* These registers have a relatively long lifetime */
+#define zero	r0
+#define pm	r1
+#define mcctrl	r2
+
+	.section .text.at32ap_cpu_bootstrap, "ax", @progbits
+	.global	at32ap_cpu_bootstrap
+	.type	at32ap_cpu_bootstrap, @function
+	.align	2
+at32ap_cpu_bootstrap:
+	mov	pm, lo(PM_BASE)
+	orh	pm, hi(PM_BASE)
+
+	/* Initialize and enable OSC0 */
+	ld.w	mcctrl, pm[PM_MCCTRL]
+	mov	r9, OSCCTRL0_VALUE
+	st.w	pm[PM_OSCCTRL0], r9
+	sbr	mcctrl, PM_MCCTRL_OSC0EN_BIT
+	st.w	pm[PM_MCCTRL], mcctrl
+
+	/* OSC0 startup timeout begins here */
+	mov	zero, 0
+	mtsr	SYSREG_COMPARE, zero
+	mtsr	SYSREG_COUNT, zero
+
+	/* Invalidate both caches */
+	cache	zero[0], 8
+	cache	zero[0], 0
+	sync	0
+
+	/* Make sure SR and CPUCR are sane */
+	mov	r9, CPUCR_INIT
+	mtsr	SYSREG_CPUCR, r9
+
+	mov	r10, 0
+	orh	r10, hi(SYSREG_BIT(GM) | SYSREG_BIT(M0))
+	mtsr	SYSREG_SR, r10
+
+	/* Jump to cacheable area (P1 segment) */
+	lddpc	pc, .Lp1_addr
+
+	.align	2
+.Lp1_addr:
+	.long	.Lp1_start
+
+.Lp1_start:
+	/* Wait for OSC0 to become ready */
+1:	ld.w	r8, pm[PM_POSCSR]
+	bld	r8, PM_POSCSR_OSC0RDY_BIT
+	brcs	.Losc0_ready
+	mfsr	r9, SYSREG_COUNT
+	cp.w	r9, OSC0_STARTUP_TIMEOUT
+	brlt	1b
+
+.Losc0_ready:
+	/* Switch to OSC0 as the main clock source */
+	mov	r10, PM_MCSEL_OSC0
+	bfins	mcctrl, r8, PM_MCCTRL_MCSEL_START, PM_MCCTRL_MCSEL_SIZE
+	st.w	pm[PM_MCCTRL], mcctrl
+
+	/* Let the common platform code do the rest. */
+	rjmp	at32ap_low_level_init
+
+	.size	_start, . - _start
diff --git a/cpu/at32ap/cpu.c b/cpu/at32ap/cpu.c
index 0ba8361..28b9dbe 100644
--- a/cpu/at32ap/cpu.c
+++ b/cpu/at32ap/cpu.c
@@ -53,7 +53,7 @@ int cpu_init(void)
 	 * increase the clock frequency. */
 	hsmc3_writel(MODE0, 0x00031103);
 	hsmc3_writel(CYCLE0, 0x000c000d);
-	hsmc3_writel(PULSE0, 0x0b0a0906);
+	hsmc3_writel(PULSE0, 0x08070906);
 	hsmc3_writel(SETUP0, 0x00010002);
 
 	clk_init();
@@ -70,6 +70,12 @@ int cpu_init(void)
 
 void prepare_to_boot(void)
 {
+	/*
+	 * Disable the COUNT/COMPARE timer so that its interrupt
+	 * doesn't take any unsuspecting applications by surprise.
+	 */
+	sysreg_write(COMPARE, 0);
+
 	/* Flush both caches and the write buffer */
 	asm volatile("cache  %0[4], 010\n\t"
 		     "cache  %0[0], 000\n\t"
diff --git a/cpu/at32ap/pio.c b/cpu/at32ap/pio.c
deleted file mode 100644
index f64004b..0000000
--- a/cpu/at32ap/pio.c
+++ /dev/null
@@ -1,116 +0,0 @@
-/*
- * Copyright (C) 2006 Atmel Corporation
- *
- * See file CREDITS for list of people who contributed to this
- * project.
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License as
- * published by the Free Software Foundation; either version 2 of
- * the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
- * MA 02111-1307 USA
- */
-#include <common.h>
-
-#include <asm/io.h>
-#include <asm/arch/gpio.h>
-#include <asm/arch/memory-map.h>
-
-#include "pio2.h"
-
-void gpio_select_periph_A(unsigned int pin, int use_pullup)
-{
-	void *base = gpio_pin_to_addr(pin);
-	uint32_t mask = 1 << (pin & 0x1f);
-
-	if (!base)
-		panic("Invalid GPIO pin %u\n", pin);
-
-	pio2_writel(base, ASR, mask);
-	pio2_writel(base, PDR, mask);
-	if (use_pullup)
-		pio2_writel(base, PUER, mask);
-	else
-		pio2_writel(base, PUDR, mask);
-}
-
-void gpio_select_periph_B(unsigned int pin, int use_pullup)
-{
-	void *base = gpio_pin_to_addr(pin);
-	uint32_t mask = 1 << (pin & 0x1f);
-
-	if (!base)
-		panic("Invalid GPIO pin %u\n", pin);
-
-	pio2_writel(base, BSR, mask);
-	pio2_writel(base, PDR, mask);
-	if (use_pullup)
-		pio2_writel(base, PUER, mask);
-	else
-		pio2_writel(base, PUDR, mask);
-}
-
-void gpio_select_pio(unsigned int pin, unsigned long gpiof_flags)
-{
-	void *base = gpio_pin_to_addr(pin);
-	uint32_t mask = 1 << (pin & 0x1f);
-
-	if (!base)
-		panic("Invalid GPIO pin %u\n", pin);
-
-	if (gpiof_flags & GPIOF_OUTPUT) {
-		if (gpiof_flags & GPIOF_MULTIDRV)
-			pio2_writel(base, MDER, mask);
-		else
-			pio2_writel(base, MDDR, mask);
-		pio2_writel(base, PUDR, mask);
-		pio2_writel(base, OER, mask);
-	} else {
-		if (gpiof_flags & GPIOF_PULLUP)
-			pio2_writel(base, PUER, mask);
-		else
-			pio2_writel(base, PUDR, mask);
-		if (gpiof_flags & GPIOF_DEGLITCH)
-			pio2_writel(base, IFER, mask);
-		else
-			pio2_writel(base, IFDR, mask);
-		pio2_writel(base, ODR, mask);
-	}
-
-	pio2_writel(base, PER, mask);
-}
-
-void gpio_set_value(unsigned int pin, int value)
-{
-	void *base = gpio_pin_to_addr(pin);
-	uint32_t mask = 1 << (pin & 0x1f);
-
-	if (!base)
-		panic("Invalid GPIO pin %u\n", pin);
-
-	if (value)
-		pio2_writel(base, SODR, mask);
-	else
-		pio2_writel(base, CODR, mask);
-}
-
-int gpio_get_value(unsigned int pin)
-{
-	void *base = gpio_pin_to_addr(pin);
-	int value;
-
-	if (!base)
-		panic("Invalid GPIO pin %u\n", pin);
-
-	value = pio2_readl(base, PDSR);
-	return (value >> (pin & 0x1f)) & 1;
-}
diff --git a/cpu/at32ap/portmux-gpio.c b/cpu/at32ap/portmux-gpio.c
new file mode 100644
index 0000000..9acd040
--- /dev/null
+++ b/cpu/at32ap/portmux-gpio.c
@@ -0,0 +1,107 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/arch/memory-map.h>
+#include <asm/arch/gpio.h>
+
+void portmux_select_peripheral(void *port, unsigned long pin_mask,
+		enum portmux_function func, unsigned long flags)
+{
+	/* Both pull-up and pull-down set means buskeeper */
+	if (flags & PORTMUX_PULL_DOWN)
+		gpio_writel(port, PDERS, pin_mask);
+	else
+		gpio_writel(port, PDERC, pin_mask);
+	if (flags & PORTMUX_PULL_UP)
+		gpio_writel(port, PUERS, pin_mask);
+	else
+		gpio_writel(port, PUERC, pin_mask);
+
+	/* Select drive strength */
+	if (flags & PORTMUX_DRIVE_LOW)
+		gpio_writel(port, ODCR0S, pin_mask);
+	else
+		gpio_writel(port, ODCR0C, pin_mask);
+	if (flags & PORTMUX_DRIVE_HIGH)
+		gpio_writel(port, ODCR1S, pin_mask);
+	else
+		gpio_writel(port, ODCR1C, pin_mask);
+
+	/* Select function */
+	if (func & PORTMUX_FUNC_B)
+		gpio_writel(port, PMR0S, pin_mask);
+	else
+		gpio_writel(port, PMR0C, pin_mask);
+	if (func & PORTMUX_FUNC_C)
+		gpio_writel(port, PMR1S, pin_mask);
+	else
+		gpio_writel(port, PMR1C, pin_mask);
+
+	/* Disable GPIO (i.e. enable peripheral) */
+	gpio_writel(port, GPERC, pin_mask);
+}
+
+void portmux_select_gpio(void *port, unsigned long pin_mask,
+		unsigned long flags)
+{
+	/* Both pull-up and pull-down set means buskeeper */
+	if (flags & PORTMUX_PULL_DOWN)
+		gpio_writel(port, PDERS, pin_mask);
+	else
+		gpio_writel(port, PDERC, pin_mask);
+	if (flags & PORTMUX_PULL_UP)
+		gpio_writel(port, PUERS, pin_mask);
+	else
+		gpio_writel(port, PUERC, pin_mask);
+
+	/* Enable open-drain mode if requested */
+	if (flags & PORTMUX_OPEN_DRAIN)
+		gpio_writel(port, ODMERS, pin_mask);
+	else
+		gpio_writel(port, ODMERC, pin_mask);
+
+	/* Select drive strength */
+	if (flags & PORTMUX_DRIVE_LOW)
+		gpio_writel(port, ODCR0S, pin_mask);
+	else
+		gpio_writel(port, ODCR0C, pin_mask);
+	if (flags & PORTMUX_DRIVE_HIGH)
+		gpio_writel(port, ODCR1S, pin_mask);
+	else
+		gpio_writel(port, ODCR1C, pin_mask);
+
+	/* Select direction and initial pin state */
+	if (flags & PORTMUX_DIR_OUTPUT) {
+		if (flags & PORTMUX_INIT_HIGH)
+			gpio_writel(port, OVRS, pin_mask);
+		else
+			gpio_writel(port, OVRC, pin_mask);
+		gpio_writel(port, ODERS, pin_mask);
+	} else {
+		gpio_writel(port, ODERC, pin_mask);
+	}
+
+	/* Enable GPIO */
+	gpio_writel(port, GPERS, pin_mask);
+}
diff --git a/cpu/at32ap/portmux-pio.c b/cpu/at32ap/portmux-pio.c
new file mode 100644
index 0000000..a29f94e
--- /dev/null
+++ b/cpu/at32ap/portmux-pio.c
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2006, 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+#include <asm/io.h>
+#include <asm/arch/memory-map.h>
+#include <asm/arch/gpio.h>
+
+void portmux_select_peripheral(void *port, unsigned long pin_mask,
+		enum portmux_function func, unsigned long flags)
+{
+	if (flags & PORTMUX_PULL_UP)
+		pio_writel(port, PUER, pin_mask);
+	else
+		pio_writel(port, PUDR, pin_mask);
+
+	switch (func) {
+	case PORTMUX_FUNC_A:
+		pio_writel(port, ASR, pin_mask);
+		break;
+	case PORTMUX_FUNC_B:
+		pio_writel(port, BSR, pin_mask);
+		break;
+	}
+
+	pio_writel(port, PDR, pin_mask);
+}
+
+void portmux_select_gpio(void *port, unsigned long pin_mask,
+		unsigned long flags)
+{
+	if (flags & PORTMUX_PULL_UP)
+		pio_writel(port, PUER, pin_mask);
+	else
+		pio_writel(port, PUDR, pin_mask);
+
+	if (flags & PORTMUX_OPEN_DRAIN)
+		pio_writel(port, MDER, pin_mask);
+	else
+		pio_writel(port, MDDR, pin_mask);
+
+	if (flags & PORTMUX_DIR_OUTPUT) {
+		if (flags & PORTMUX_INIT_HIGH)
+			pio_writel(port, SODR, pin_mask);
+		else
+			pio_writel(port, CODR, pin_mask);
+		pio_writel(port, OER, pin_mask);
+	} else {
+		pio_writel(port, ODR, pin_mask);
+	}
+
+	pio_writel(port, PER, pin_mask);
+}
+
+void pio_set_output_value(unsigned int pin, int value)
+{
+	void *port = pio_pin_to_port(pin);
+
+	if (!port)
+		panic("Invalid GPIO pin %u\n", pin);
+
+	__pio_set_output_value(port, pin & 0x1f, value);
+}
+
+int pio_get_input_value(unsigned int pin)
+{
+	void *port = pio_pin_to_port(pin);
+
+	if (!port)
+		panic("Invalid GPIO pin %u\n", pin);
+
+	return __pio_get_input_value(port, pin & 0x1f);
+}
diff --git a/cpu/at32ap/start.S b/cpu/at32ap/start.S
index 907e9b1..45bc995 100644
--- a/cpu/at32ap/start.S
+++ b/cpu/at32ap/start.S
@@ -117,18 +117,18 @@ unknown_exception:
 timer_interrupt_handler:
 	/*
 	 * Increment timer_overflow and re-write COMPARE with 0xffffffff.
-	 *
-	 * We're running at interrupt level 3, so we don't need to save
-	 * r8-r12 or lr to the stack.
 	 */
+	pushm	r8-r10
 	lda.w	r8, timer_overflow
 	ld.w	r9, r8[0]
 	mov	r10, -1
 	mtsr	SYSREG_COMPARE, r10
 	sub	r9, -1
 	st.w	r8[0], r9
+	popm	r8-r10
 	rete
 
+#ifndef CONFIG_AT32AP7200
 	/*
 	 * CPU bootstrap after reset is handled here. SoC code may
 	 * override this in case they need to initialize oscillators,
@@ -169,6 +169,7 @@ at32ap_cpu_bootstrap:
 	.align	2
 1:	.long	at32ap_low_level_init
 	.size	_start, . - _start
+#endif
 
 	/* Common CPU bootstrap code after oscillator/cache/etc. init */
 	.section .text.avr32ap_low_level_init, "ax", @progbits
diff --git a/doc/README.AVR32 b/doc/README.AVR32
index abec872..632cc05 100644
--- a/doc/README.AVR32
+++ b/doc/README.AVR32
@@ -1,10 +1,3 @@
-From: Haavard Skinnemoen <hskinnemoen@atmel.com>
-Date: Wed, 30 Aug 2006 17:01:46 +0200
-Subject: [PATCH] AVR32 architecture support
-
-This patch adds common infrastructure code for the Atmel AVR32
-architecture.
-
 AVR32 is a new high-performance 32-bit RISC microprocessor core,
 designed for cost-sensitive embedded applications, with particular
 emphasis on low power consumption and high code density. The AVR32
@@ -16,18 +9,17 @@ by the AVR32 Architecture Manual, available from
 
 http://www.atmel.com/dyn/resources/prod_documents/doc32000.pdf
 
-A GNU toolchain with support for AVR32 is included with the ATSTK1000
-BSP, which can be downloaded as an ISO image from
+A GNU toolchain with support for AVR32, along with non-GNU programming
+and debugging support, can be downloaded from
 
-http://www.atmel.com/dyn/products/tools_card.asp?tool_id=3918
+http://www.atmel.com/dyn/products/tools_card.asp?tool_id=4118
 
-Alternatively, you can build it yourself by following the
-Getting Started guide at avr32linux.org, which also provides links
-to the necessary sources and patches you need to download:
+A full set of u-boot, kernel and filesystem images can be built using
+buildroot. This will also produce a working toolchain which can be
+used instead of the official GNU toolchain above. A customized version
+of buildroot for AVR32 can be downloaded here:
 
-http://avr32linux.org/twiki/bin/view/Main/GettingStarted
+http://www.atmel.no/buildroot/
 
 The AVR32 ports of u-boot, the Linux kernel, the GNU toolchain and
 other associated software are actively supported by Atmel Corporation.
-
-Signed-off-by: Haavard Skinnemoen <hskinnemoen@atmel.com>
diff --git a/doc/README.AVR32-port-muxing b/doc/README.AVR32-port-muxing
new file mode 100644
index 0000000..b53799d
--- /dev/null
+++ b/doc/README.AVR32-port-muxing
@@ -0,0 +1,208 @@
+AVR32 Port multiplexer configuration
+====================================
+
+On AVR32 chips, most external I/O pins are routed through a port
+multiplexer. There are currently two kinds of port multiplexer
+hardware around with different register interfaces:
+
+  * PIO (AT32AP700x; this is also used on ARM AT91 chips)
+  * GPIO (all other AVR32 chips)
+
+The "PIO" variant supports multiplexing up to two peripherals per pin
+in addition to GPIO (software control). Each pin has configurable
+pull-up, glitch filter, interrupt and multi-drive capabilities.
+
+The "GPIO" variant supports multiplexing up to four peripherals per
+pin in addition to GPIO. Each pin has configurable
+pull-up/pull-down/buskeeper, glitch filter, interrupt, open-drain and
+schmitt-trigger capabilities, as well as configurable drive strength
+and slew rate control.
+
+Both controllers are configured using the same API, but the functions
+may accept different values for some parameters depending on the
+actual portmux implementation, and some parameters may be ignored by
+one of the implementation (e.g. the "PIO" implementation will ignore
+the drive strength flags since the hardware doesn't support
+configurable drive strength.)
+
+Selecting the portmux implementation
+------------------------------------
+Since u-boot is lacking a Kconfig-style configuration engine, the
+portmux implementation must be selected manually by defining one of
+the following symbols:
+
+	CONFIG_PORTMUX_PIO
+	CONFIG_PORTMUX_GPIO
+
+depending on which implementation the chip in question uses.
+
+Identifying pins
+----------------
+The portmux configuration functions described below identify the pins
+to act on based on two parameters: A "port" (i.e. a block of pins
+that somehow belong together) and a pin mask. Both are defined in an
+implementation-specific manner.
+
+The available ports are defined on the form
+
+  #define PORTMUX_PORT_A	(something)
+
+where "A" matches the identifier given in the chip's data sheet, and
+"something" is whatever the portmux implementation needs to identify
+the port (usually a memory address).
+
+The pin mask is a bitmask where each '1' bit indicates a pin to apply
+the current operation to. The width of the bitmask may vary from port
+to port, but it is never wider than 32 bits (which is the width of
+'unsigned long' on avr32).
+
+Selecting functions
+-------------------
+Each pin can either be assigned to one of a predefined set of on-chip
+peripherals, or it can be set up to be controlled by software. For the
+former case, the portmux implementation defines an enum containing all
+the possible peripheral functions that can be selected. For example,
+the PIO implementation, which allows multiplexing two peripherals per
+pin, defines it like this:
+
+	enum portmux_function {
+		PORTMUX_FUNC_A,
+		PORTMUX_FUNC_B,
+	};
+
+To configure a set of pins to be connected to a given peripheral
+function, the following function is used.
+
+	void portmux_select_peripheral(void *port, unsigned long pin_mask,
+			enum portmux_function func, unsigned long flags);
+
+To configure a set of pins to be controlled by software (GPIO), the
+following function is used. In this case, no "function" argument is
+required since "GPIO" is a function in its own right.
+
+	void portmux_select_gpio(void *port, unsigned int pin_mask,
+			unsigned long flags);
+
+Both of these functions take a "flags" parameter which may be used to
+alter the default configuration of the pin. This is a bitmask of
+various flags defined in an implementation-specific way, but the names
+of the flags are the same on all implementations.
+
+	PORTMUX_DIR_OUTPUT
+	PORTMUX_DIR_INPUT
+
+These mutually-exlusive flags configure the initial direction of the
+pins. PORTMUX_DIR_OUTPUT means that the pins are driven by the CPU,
+while PORTMUX_DIR_INPUT means that the pins are tristated by the CPU.
+These flags are ignored by portmux_select_peripheral().
+
+	PORTMUX_INIT_HIGH
+	PORTMUX_INIT_LOW
+
+These mutually-exclusive flags configure the initial state of the
+pins: High (Vdd) or low (Vss). They are only effective when
+portmux_select_gpio() is called with the PORTMUX_DIR_OUTPUT flag set.
+
+	PORTMUX_PULL_UP
+	PORTMUX_PULL_DOWN
+	PORTMUX_BUSKEEPER
+
+These mutually-exclusive flags are used to enable any on-chip CMOS
+resistors connected to the pins. PORTMUX_PULL_UP causes the pins to be
+pulled up to Vdd, PORTMUX_PULL_DOWN causes the pins to be pulled down
+to Vss, and PORTMUX_BUSKEEPER will keep the pins in whatever state
+they were left in by whatever was driving them last. If none of the
+flags are specified, the pins are left floating if no one are driving
+them; this is only recommended for always-output pins (e.g. extern
+address and control lines driven by the CPU.)
+
+Note that the "PIO" implementation will silently ignore the
+PORTMUX_PULL_DOWN flag and interpret PORTMUX_BUSKEEPER as
+PORTMUX_PULL_UP.
+
+	PORTMUX_DRIVE_MIN
+	PORTMUX_DRIVE_LOW
+	PORTMUX_DRIVE_HIGH
+	PORTMUX_DRIVE_MAX
+
+These mutually-exlusive flags determine the drive strength of the
+pins. PORTMUX_DRIVE_MIN will give low power-consumption, but may cause
+corruption of high-speed signals. PORTMUX_DRIVE_MAX will give high
+power-consumption, but may be necessary on pins toggling at very high
+speeds. PORTMUX_DRIVE_LOW and PORTMUX_DRIVE_HIGH specify something in
+between the other two.
+
+Note that setting the drive strength too high may cause excessive
+overshoot and EMI problems, which may in turn cause signal corruption.
+Also note that the "PIO" implementation will silently ignore these
+flags.
+
+	PORTMUX_OPEN_DRAIN
+
+This flag will configure the pins as "open drain", i.e. setting the
+pin state to 0 will drive it low, while setting it to 1 will leave it
+floating (or, in most cases, let it be pulled high by an internal or
+external pull-up resistor.) In the data sheet for chips using the
+"PIO" variant, this mode is called "multi-driver".
+
+Enabling specific peripherals
+-----------------------------
+In addition to the above functions, each chip provides a set of
+functions for setting up the port multiplexer to use a given
+peripheral. The following are some of the functions available.
+
+All the functions below take a "drive_strength" parameter, which must
+be one of the PORTMUX_DRIVE_x flags specified above.  Any other
+portmux flags will be silently filtered out.
+
+To set up the External Bus Interface (EBI), call
+
+	void portmux_enable_ebi(unsigned int bus_width,
+			unsigned long flags, unsigned long drive_strength)
+
+where "bus_width" must be either 16 or 32. "flags" can be any
+combination of the following flags.
+
+	PORTMUX_EBI_CS(x)	/* Enable chip select x */
+	PORTMUX_EBI_NAND	/* Enable NAND flash interface */
+	PORTMUX_EBI_CF(x)	/* Enable CompactFlash interface x */
+	PORTMUX_EBI_NWAIT	/* Enable NWAIT signal */
+
+To set up a USART, call
+
+	void portmux_enable_usartX(unsigned long drive_strength);
+
+where X is replaced by the USART instance to be configured.
+
+To set up an ethernet MAC:
+
+	void portmux_enable_macbX(unsigned long flags,
+			unsigned long drive_strength);
+
+where X is replaced by the MACB instance to be configured. "flags" can
+be any combination of the following flags.
+
+	PORTMUX_MACB_RMII	/* Just set up the RMII interface */
+	PORTMUX_MACB_MII	/* Set up full MII interface */
+	PORTMUX_MACB_SPEED	/* Enable the SPEED pin */
+
+To set up the MMC controller:
+
+	void portmux_enable_mmci(unsigned long slot, unsigned long flags
+			unsigned long drive_strength);
+
+where "slot" identifies which of the alternative SD card slots to
+enable. "flags" can be any combination of the following flags:
+
+	PORTMUX_MMCI_4BIT	/* Enable 4-bit SD card interface */
+	PORTMUX_MMCI_8BIT	/* Enable 8-bit MMC+ interface */
+	PORTMUX_MMCI_EXT_PULLUP	/* Board has external pull-ups */
+
+To set up a SPI controller:
+
+	void portmux_enable_spiX(unsigned long cs_mask,
+			unsigned long drive_strength);
+
+where X is replaced by the SPI instance to be configured. "cs_mask" is
+a 4-bit bitmask specifying which of the four standard chip select
+lines to set up as GPIOs.
diff --git a/drivers/mmc/atmel_mci.c b/drivers/mmc/atmel_mci.c
index a151488..05a14ed 100644
--- a/drivers/mmc/atmel_mci.c
+++ b/drivers/mmc/atmel_mci.c
@@ -39,7 +39,7 @@
 #endif
 
 #ifndef CFG_MMC_CLK_OD
-#define CFG_MMC_CLK_OD		150000
+#define CFG_MMC_CLK_OD		200000
 #endif
 
 #ifndef CFG_MMC_CLK_PP
diff --git a/drivers/serial/atmel_usart.c b/drivers/serial/atmel_usart.c
index f3b146c..9773b94 100644
--- a/drivers/serial/atmel_usart.c
+++ b/drivers/serial/atmel_usart.c
@@ -33,6 +33,12 @@
 #elif defined(CONFIG_USART3)
 # define USART_ID	3
 # define USART_BASE	USART3_BASE
+#elif defined(CONFIG_USART4)
+# define USART_ID	4
+# define USART_BASE	USART4_BASE
+#elif defined(CONFIG_USART5)
+# define USART_ID	5
+# define USART_BASE	USART5_BASE
 #endif
 
 #include "atmel_usart.h"
@@ -43,6 +49,8 @@ void serial_setbrg(void)
 {
 	unsigned long divisor;
 	unsigned long usart_hz;
+	unsigned long cd;
+	unsigned long fp;
 
 	/*
 	 *              Master Clock
@@ -50,8 +58,16 @@ void serial_setbrg(void)
 	 *                16 * CD
 	 */
 	usart_hz = get_usart_clk_rate(USART_ID);
-	divisor = (usart_hz / 16 + gd->baudrate / 2) / gd->baudrate;
-	usart3_writel(BRGR, USART3_BF(CD, divisor));
+	divisor = ((usart_hz + 1) / 2 + gd->baudrate / 2) / gd->baudrate;
+#if defined(CONFIG_AT91RM9200) || defined(CONFIG_AT91SAM9261)
+	/* Some chips don't support fractional dividers */
+	cd = (divisor + 4) / 8;
+	fp = 0;
+#else
+	cd = divisor / 8;
+	fp = divisor % 8;
+#endif
+	usart3_writel(BRGR, USART3_BF(CD, cd) | USART3_BF(FP, fp));
 }
 
 int serial_init(void)
diff --git a/drivers/serial/atmel_usart.h b/drivers/serial/atmel_usart.h
index af3773a..82da20b 100644
--- a/drivers/serial/atmel_usart.h
+++ b/drivers/serial/atmel_usart.h
@@ -178,6 +178,8 @@
 /* Bitfields in BRGR */
 #define USART3_CD_OFFSET			0
 #define USART3_CD_SIZE				16
+#define USART3_FP_OFFSET			16
+#define USART3_FP_SIZE				3
 
 /* Bitfields in RTOR */
 #define USART3_TO_OFFSET			0
diff --git a/drivers/video/atmel_lcdfb.c b/drivers/video/atmel_lcdfb.c
index b332a82..3a51cc7 100644
--- a/drivers/video/atmel_lcdfb.c
+++ b/drivers/video/atmel_lcdfb.c
@@ -24,7 +24,6 @@
 
 #include <common.h>
 #include <asm/io.h>
-#include <asm/arch/hardware.h>
 #include <asm/arch/gpio.h>
 #include <asm/arch/clk.h>
 #include <lcd.h>
@@ -108,10 +107,7 @@ void lcd_ctrl_init(void *lcdbase)
 	if (panel_info.vl_tft)
 		value |= ATMEL_LCDC_DISTYPE_TFT;
 
-	if (!(panel_info.vl_sync & ATMEL_LCDC_INVLINE_INVERTED))
-		value |= ATMEL_LCDC_INVLINE_INVERTED;
-	if (!(panel_info.vl_sync & ATMEL_LCDC_INVFRAME_INVERTED))
-		value |= ATMEL_LCDC_INVFRAME_INVERTED;
+	value |= panel_info.vl_sync;
 	value |= (panel_info.vl_bpix << 5);
 	lcdc_writel(panel_info.mmio, ATMEL_LCDC_LCDCON2, value);
 
diff --git a/examples/stubs.c b/examples/stubs.c
index ec53532..fe890fd 100644
--- a/examples/stubs.c
+++ b/examples/stubs.c
@@ -140,16 +140,17 @@ gd_t *global_data;
 	: : "i"(offsetof(gd_t, jt)), "i"(XF_ ## x * sizeof(void *)) : "P0");
 #elif defined(CONFIG_AVR32)
 /*
- * r6 holds the pointer to the global_data. r8 is call clobbered.
+ * r5 holds the pointer to the global_data. r8 is call clobbered.
  */
 #define EXPORT_FUNC(x)					\
 	asm volatile(					\
 		"	.globl\t" #x "\n"		\
 		#x ":\n"				\
-		"	ld.w	r8, r6[%0]\n"		\
+		"	ld.w	r8, r5[%0]\n"		\
 		"	ld.w	pc, r8[%1]\n"		\
 		:					\
-		: "i"(offsetof(gd_t, jt)), "i"(XF_ ##x)	\
+		: "i"(offsetof(gd_t, jt)),		\
+			"i"(XF_ ##x * sizeof(void *))	\
 		: "r8");
 #elif defined(CONFIG_SH)
 /*
diff --git a/include/asm-arm/arch-at91sam9/gpio.h b/include/asm-arm/arch-at91sam9/gpio.h
index c4d7b97..e2d375b 100644
--- a/include/asm-arm/arch-at91sam9/gpio.h
+++ b/include/asm-arm/arch-at91sam9/gpio.h
@@ -16,6 +16,7 @@
 #include <asm/io.h>
 #include <asm/errno.h>
 #include <asm/arch/at91_pio.h>
+#include <asm/arch/hardware.h>
 
 #define PIN_BASE		32
 
diff --git a/include/asm-avr32/arch-at32ap700x/chip-features.h b/include/asm-avr32/arch-at32ap700x/chip-features.h
index c47107e..b6bd1cd 100644
--- a/include/asm-avr32/arch-at32ap700x/chip-features.h
+++ b/include/asm-avr32/arch-at32ap700x/chip-features.h
@@ -32,4 +32,9 @@
 #define AT32AP700x_CHIP_HAS_MACB
 #endif
 
+/* AP7001 doesn't have a LCD controller */
+#if defined(CONFIG_AT32AP7000) || defined(CONFIG_AT32AP7002)
+#define AT32AP700x_CHIP_HAS_LCDC
+#endif
+
 #endif /* __ASM_AVR32_ARCH_CHIP_FEATURES_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/clk.h b/include/asm-avr32/arch-at32ap700x/clk.h
index a9d8431..5d63c1c 100644
--- a/include/asm-avr32/arch-at32ap700x/clk.h
+++ b/include/asm-avr32/arch-at32ap700x/clk.h
@@ -23,11 +23,13 @@
 #define __ASM_AVR32_ARCH_CLK_H__
 
 #include <asm/arch/chip-features.h>
+#include <asm/arch/portmux.h>
 
 #ifdef CONFIG_PLL
-#define MAIN_CLK_RATE ((CFG_OSC0_HZ / CFG_PLL0_DIV) * CFG_PLL0_MUL)
+#define PLL0_RATE	((CFG_OSC0_HZ / CFG_PLL0_DIV) * CFG_PLL0_MUL)
+#define MAIN_CLK_RATE	PLL0_RATE
 #else
-#define MAIN_CLK_RATE (CFG_OSC0_HZ)
+#define MAIN_CLK_RATE	(CFG_OSC0_HZ)
 #endif
 
 static inline unsigned long get_cpu_clk_rate(void)
@@ -80,10 +82,113 @@ static inline unsigned long get_spi_clk_rate(unsigned int dev_id)
 	return get_pba_clk_rate();
 }
 #endif
+#ifdef AT32AP700x_CHIP_HAS_LCDC
+static inline unsigned long get_lcdc_clk_rate(unsigned int dev_id)
+{
+#ifdef CONFIG_LCD
+	return CONFIG_LCDC_PIXCLK_RATE;
+#else
+	return 0;
+#endif
+}
+#endif
 
 extern void clk_init(void);
 
 /* Board code may need the SDRAM base clock as a compile-time constant */
 #define SDRAMC_BUS_HZ	(MAIN_CLK_RATE >> CFG_CLKDIV_HSB)
 
+/* Generic clock control */
+enum gclk_parent {
+	GCLK_PARENT_OSC0 = 0,
+	GCLK_PARENT_OSC1 = 1,
+	GCLK_PARENT_PLL0 = 2,
+	GCLK_PARENT_PLL1 = 3,
+};
+
+/* Some generic clocks have specific roles */
+#define GCLK_DAC_SAMPLE_CLK	6
+#define GCLK_LCDC_PIXCLK	7
+
+extern unsigned long __gclk_set_rate(unsigned int id, enum gclk_parent parent,
+		unsigned long rate, unsigned long parent_rate);
+
+/**
+ * gclk_set_rate - configure and enable a generic clock
+ * @id: Which GCLK[id] to enable
+ * @parent: Parent clock feeding the GCLK
+ * @rate: Target rate of the GCLK in Hz
+ *
+ * Returns the actual GCLK rate in Hz, after rounding to the nearest
+ * supported rate.
+ *
+ * All three parameters are usually constant, hence the inline.
+ */
+static inline unsigned long gclk_set_rate(unsigned int id,
+		enum gclk_parent parent, unsigned long rate)
+{
+	unsigned long parent_rate;
+
+	if (id > 7)
+		return 0;
+
+	switch (parent) {
+	case GCLK_PARENT_OSC0:
+		parent_rate = CFG_OSC0_HZ;
+		break;
+#ifdef CFG_OSC1_HZ
+	case GCLK_PARENT_OSC1:
+		parent_rate = CFG_OSC1_HZ;
+		break;
+#endif
+#ifdef PLL0_RATE
+	case GCLK_PARENT_PLL0:
+		parent_rate = PLL0_RATE;
+		break;
+#endif
+#ifdef PLL1_RATE
+	case GCLK_PARENT_PLL1:
+		parent_rate = PLL1_RATE;
+		break;
+#endif
+	default:
+		parent_rate = 0;
+		break;
+	}
+
+	return __gclk_set_rate(id, parent, rate, parent_rate);
+}
+
+/**
+ * gclk_enable_output - enable output on a GCLK pin
+ * @id: Which GCLK[id] pin to enable
+ * @drive_strength: Drive strength of external GCLK pin, if applicable
+ */
+static inline void gclk_enable_output(unsigned int id,
+		unsigned long drive_strength)
+{
+	switch (id) {
+	case 0:
+		portmux_select_peripheral(PORTMUX_PORT_A, 1 << 30,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 1:
+		portmux_select_peripheral(PORTMUX_PORT_A, 1 << 31,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 2:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 19,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 3:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 29,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 4:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 30,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	}
+}
+
 #endif /* __ASM_AVR32_ARCH_CLK_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/gpio.h b/include/asm-avr32/arch-at32ap700x/gpio.h
index 8c922c7..303e353 100644
--- a/include/asm-avr32/arch-at32ap700x/gpio.h
+++ b/include/asm-avr32/arch-at32ap700x/gpio.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2006 Atmel Corporation
+ * Copyright (C) 2006, 2008 Atmel Corporation
  *
  * See file CREDITS for list of people who contributed to this
  * project.
@@ -31,161 +31,17 @@
  * Pin numbers identifying specific GPIO pins on the chip.
  */
 #define GPIO_PIOA_BASE	(0)
-#define GPIO_PIN_PA0	(GPIO_PIOA_BASE +  0)
-#define GPIO_PIN_PA1	(GPIO_PIOA_BASE +  1)
-#define GPIO_PIN_PA2	(GPIO_PIOA_BASE +  2)
-#define GPIO_PIN_PA3	(GPIO_PIOA_BASE +  3)
-#define GPIO_PIN_PA4	(GPIO_PIOA_BASE +  4)
-#define GPIO_PIN_PA5	(GPIO_PIOA_BASE +  5)
-#define GPIO_PIN_PA6	(GPIO_PIOA_BASE +  6)
-#define GPIO_PIN_PA7	(GPIO_PIOA_BASE +  7)
-#define GPIO_PIN_PA8	(GPIO_PIOA_BASE +  8)
-#define GPIO_PIN_PA9	(GPIO_PIOA_BASE +  9)
-#define GPIO_PIN_PA10	(GPIO_PIOA_BASE + 10)
-#define GPIO_PIN_PA11	(GPIO_PIOA_BASE + 11)
-#define GPIO_PIN_PA12	(GPIO_PIOA_BASE + 12)
-#define GPIO_PIN_PA13	(GPIO_PIOA_BASE + 13)
-#define GPIO_PIN_PA14	(GPIO_PIOA_BASE + 14)
-#define GPIO_PIN_PA15	(GPIO_PIOA_BASE + 15)
-#define GPIO_PIN_PA16	(GPIO_PIOA_BASE + 16)
-#define GPIO_PIN_PA17	(GPIO_PIOA_BASE + 17)
-#define GPIO_PIN_PA18	(GPIO_PIOA_BASE + 18)
-#define GPIO_PIN_PA19	(GPIO_PIOA_BASE + 19)
-#define GPIO_PIN_PA20	(GPIO_PIOA_BASE + 20)
-#define GPIO_PIN_PA21	(GPIO_PIOA_BASE + 21)
-#define GPIO_PIN_PA22	(GPIO_PIOA_BASE + 22)
-#define GPIO_PIN_PA23	(GPIO_PIOA_BASE + 23)
-#define GPIO_PIN_PA24	(GPIO_PIOA_BASE + 24)
-#define GPIO_PIN_PA25	(GPIO_PIOA_BASE + 25)
-#define GPIO_PIN_PA26	(GPIO_PIOA_BASE + 26)
-#define GPIO_PIN_PA27	(GPIO_PIOA_BASE + 27)
-#define GPIO_PIN_PA28	(GPIO_PIOA_BASE + 28)
-#define GPIO_PIN_PA29	(GPIO_PIOA_BASE + 29)
-#define GPIO_PIN_PA30	(GPIO_PIOA_BASE + 30)
-#define GPIO_PIN_PA31	(GPIO_PIOA_BASE + 31)
-
 #define GPIO_PIOB_BASE	(GPIO_PIOA_BASE + 32)
-#define GPIO_PIN_PB0	(GPIO_PIOB_BASE +  0)
-#define GPIO_PIN_PB1	(GPIO_PIOB_BASE +  1)
-#define GPIO_PIN_PB2	(GPIO_PIOB_BASE +  2)
-#define GPIO_PIN_PB3	(GPIO_PIOB_BASE +  3)
-#define GPIO_PIN_PB4	(GPIO_PIOB_BASE +  4)
-#define GPIO_PIN_PB5	(GPIO_PIOB_BASE +  5)
-#define GPIO_PIN_PB6	(GPIO_PIOB_BASE +  6)
-#define GPIO_PIN_PB7	(GPIO_PIOB_BASE +  7)
-#define GPIO_PIN_PB8	(GPIO_PIOB_BASE +  8)
-#define GPIO_PIN_PB9	(GPIO_PIOB_BASE +  9)
-#define GPIO_PIN_PB10	(GPIO_PIOB_BASE + 10)
-#define GPIO_PIN_PB11	(GPIO_PIOB_BASE + 11)
-#define GPIO_PIN_PB12	(GPIO_PIOB_BASE + 12)
-#define GPIO_PIN_PB13	(GPIO_PIOB_BASE + 13)
-#define GPIO_PIN_PB14	(GPIO_PIOB_BASE + 14)
-#define GPIO_PIN_PB15	(GPIO_PIOB_BASE + 15)
-#define GPIO_PIN_PB16	(GPIO_PIOB_BASE + 16)
-#define GPIO_PIN_PB17	(GPIO_PIOB_BASE + 17)
-#define GPIO_PIN_PB18	(GPIO_PIOB_BASE + 18)
-#define GPIO_PIN_PB19	(GPIO_PIOB_BASE + 19)
-#define GPIO_PIN_PB20	(GPIO_PIOB_BASE + 20)
-#define GPIO_PIN_PB21	(GPIO_PIOB_BASE + 21)
-#define GPIO_PIN_PB22	(GPIO_PIOB_BASE + 22)
-#define GPIO_PIN_PB23	(GPIO_PIOB_BASE + 23)
-#define GPIO_PIN_PB24	(GPIO_PIOB_BASE + 24)
-#define GPIO_PIN_PB25	(GPIO_PIOB_BASE + 25)
-#define GPIO_PIN_PB26	(GPIO_PIOB_BASE + 26)
-#define GPIO_PIN_PB27	(GPIO_PIOB_BASE + 27)
-#define GPIO_PIN_PB28	(GPIO_PIOB_BASE + 28)
-#define GPIO_PIN_PB29	(GPIO_PIOB_BASE + 29)
-#define GPIO_PIN_PB30	(GPIO_PIOB_BASE + 30)
-
 #define GPIO_PIOC_BASE	(GPIO_PIOB_BASE + 32)
-#define GPIO_PIN_PC0	(GPIO_PIOC_BASE +  0)
-#define GPIO_PIN_PC1	(GPIO_PIOC_BASE +  1)
-#define GPIO_PIN_PC2	(GPIO_PIOC_BASE +  2)
-#define GPIO_PIN_PC3	(GPIO_PIOC_BASE +  3)
-#define GPIO_PIN_PC4	(GPIO_PIOC_BASE +  4)
-#define GPIO_PIN_PC5	(GPIO_PIOC_BASE +  5)
-#define GPIO_PIN_PC6	(GPIO_PIOC_BASE +  6)
-#define GPIO_PIN_PC7	(GPIO_PIOC_BASE +  7)
-#define GPIO_PIN_PC8	(GPIO_PIOC_BASE +  8)
-#define GPIO_PIN_PC9	(GPIO_PIOC_BASE +  9)
-#define GPIO_PIN_PC10	(GPIO_PIOC_BASE + 10)
-#define GPIO_PIN_PC11	(GPIO_PIOC_BASE + 11)
-#define GPIO_PIN_PC12	(GPIO_PIOC_BASE + 12)
-#define GPIO_PIN_PC13	(GPIO_PIOC_BASE + 13)
-#define GPIO_PIN_PC14	(GPIO_PIOC_BASE + 14)
-#define GPIO_PIN_PC15	(GPIO_PIOC_BASE + 15)
-#define GPIO_PIN_PC16	(GPIO_PIOC_BASE + 16)
-#define GPIO_PIN_PC17	(GPIO_PIOC_BASE + 17)
-#define GPIO_PIN_PC18	(GPIO_PIOC_BASE + 18)
-#define GPIO_PIN_PC19	(GPIO_PIOC_BASE + 19)
-#define GPIO_PIN_PC20	(GPIO_PIOC_BASE + 20)
-#define GPIO_PIN_PC21	(GPIO_PIOC_BASE + 21)
-#define GPIO_PIN_PC22	(GPIO_PIOC_BASE + 22)
-#define GPIO_PIN_PC23	(GPIO_PIOC_BASE + 23)
-#define GPIO_PIN_PC24	(GPIO_PIOC_BASE + 24)
-#define GPIO_PIN_PC25	(GPIO_PIOC_BASE + 25)
-#define GPIO_PIN_PC26	(GPIO_PIOC_BASE + 26)
-#define GPIO_PIN_PC27	(GPIO_PIOC_BASE + 27)
-#define GPIO_PIN_PC28	(GPIO_PIOC_BASE + 28)
-#define GPIO_PIN_PC29	(GPIO_PIOC_BASE + 29)
-#define GPIO_PIN_PC30	(GPIO_PIOC_BASE + 30)
-#define GPIO_PIN_PC31	(GPIO_PIOC_BASE + 31)
-
 #define GPIO_PIOD_BASE	(GPIO_PIOC_BASE + 32)
-#define GPIO_PIN_PD0	(GPIO_PIOD_BASE +  0)
-#define GPIO_PIN_PD1	(GPIO_PIOD_BASE +  1)
-#define GPIO_PIN_PD2	(GPIO_PIOD_BASE +  2)
-#define GPIO_PIN_PD3	(GPIO_PIOD_BASE +  3)
-#define GPIO_PIN_PD4	(GPIO_PIOD_BASE +  4)
-#define GPIO_PIN_PD5	(GPIO_PIOD_BASE +  5)
-#define GPIO_PIN_PD6	(GPIO_PIOD_BASE +  6)
-#define GPIO_PIN_PD7	(GPIO_PIOD_BASE +  7)
-#define GPIO_PIN_PD8	(GPIO_PIOD_BASE +  8)
-#define GPIO_PIN_PD9	(GPIO_PIOD_BASE +  9)
-#define GPIO_PIN_PD10	(GPIO_PIOD_BASE + 10)
-#define GPIO_PIN_PD11	(GPIO_PIOD_BASE + 11)
-#define GPIO_PIN_PD12	(GPIO_PIOD_BASE + 12)
-#define GPIO_PIN_PD13	(GPIO_PIOD_BASE + 13)
-#define GPIO_PIN_PD14	(GPIO_PIOD_BASE + 14)
-#define GPIO_PIN_PD15	(GPIO_PIOD_BASE + 15)
-#define GPIO_PIN_PD16	(GPIO_PIOD_BASE + 16)
-#define GPIO_PIN_PD17	(GPIO_PIOD_BASE + 17)
-
 #define GPIO_PIOE_BASE	(GPIO_PIOD_BASE + 32)
-#define GPIO_PIN_PE0	(GPIO_PIOE_BASE +  0)
-#define GPIO_PIN_PE1	(GPIO_PIOE_BASE +  1)
-#define GPIO_PIN_PE2	(GPIO_PIOE_BASE +  2)
-#define GPIO_PIN_PE3	(GPIO_PIOE_BASE +  3)
-#define GPIO_PIN_PE4	(GPIO_PIOE_BASE +  4)
-#define GPIO_PIN_PE5	(GPIO_PIOE_BASE +  5)
-#define GPIO_PIN_PE6	(GPIO_PIOE_BASE +  6)
-#define GPIO_PIN_PE7	(GPIO_PIOE_BASE +  7)
-#define GPIO_PIN_PE8	(GPIO_PIOE_BASE +  8)
-#define GPIO_PIN_PE9	(GPIO_PIOE_BASE +  9)
-#define GPIO_PIN_PE10	(GPIO_PIOE_BASE + 10)
-#define GPIO_PIN_PE11	(GPIO_PIOE_BASE + 11)
-#define GPIO_PIN_PE12	(GPIO_PIOE_BASE + 12)
-#define GPIO_PIN_PE13	(GPIO_PIOE_BASE + 13)
-#define GPIO_PIN_PE14	(GPIO_PIOE_BASE + 14)
-#define GPIO_PIN_PE15	(GPIO_PIOE_BASE + 15)
-#define GPIO_PIN_PE16	(GPIO_PIOE_BASE + 16)
-#define GPIO_PIN_PE17	(GPIO_PIOE_BASE + 17)
-#define GPIO_PIN_PE18	(GPIO_PIOE_BASE + 18)
-#define GPIO_PIN_PE19	(GPIO_PIOE_BASE + 19)
-#define GPIO_PIN_PE20	(GPIO_PIOE_BASE + 20)
-#define GPIO_PIN_PE21	(GPIO_PIOE_BASE + 21)
-#define GPIO_PIN_PE22	(GPIO_PIOE_BASE + 22)
-#define GPIO_PIN_PE23	(GPIO_PIOE_BASE + 23)
-#define GPIO_PIN_PE24	(GPIO_PIOE_BASE + 24)
-#define GPIO_PIN_PE25	(GPIO_PIOE_BASE + 25)
-#define GPIO_PIN_PE26	(GPIO_PIOE_BASE + 26)
+#define GPIO_PIN_PA(x)	(GPIO_PIOA_BASE + (x))
+#define GPIO_PIN_PB(x)	(GPIO_PIOB_BASE + (x))
+#define GPIO_PIN_PC(x)	(GPIO_PIOC_BASE + (x))
+#define GPIO_PIN_PD(x)	(GPIO_PIOD_BASE + (x))
+#define GPIO_PIN_PE(x)	(GPIO_PIOE_BASE + (x))
 
-#define GPIOF_PULLUP	0x00000001	/* (not-OUT) Enable pull-up */
-#define GPIOF_OUTPUT	0x00000002	/* (OUT) Enable output driver */
-#define GPIOF_DEGLITCH	0x00000004	/* (IN) Filter glitches */
-#define GPIOF_MULTIDRV	0x00000008	/* Enable multidriver option */
-
-static inline void *gpio_pin_to_addr(unsigned int pin)
+static inline void *pio_pin_to_port(unsigned int pin)
 {
 	switch (pin >> 5) {
 	case 0:
@@ -203,30 +59,6 @@ static inline void *gpio_pin_to_addr(unsigned int pin)
 	}
 }
 
-void gpio_select_periph_A(unsigned int pin, int use_pullup);
-void gpio_select_periph_B(unsigned int pin, int use_pullup);
-void gpio_select_pio(unsigned int pin, unsigned long gpiof_flags);
-void gpio_set_value(unsigned int pin, int value);
-int gpio_get_value(unsigned int pin);
-
-void gpio_enable_ebi(void);
-
-#ifdef AT32AP700x_CHIP_HAS_USART
-void gpio_enable_usart0(void);
-void gpio_enable_usart1(void);
-void gpio_enable_usart2(void);
-void gpio_enable_usart3(void);
-#endif
-#ifdef AT32AP700x_CHIP_HAS_MACB
-void gpio_enable_macb0(void);
-void gpio_enable_macb1(void);
-#endif
-#ifdef AT32AP700x_CHIP_HAS_MMCI
-void gpio_enable_mmci(void);
-#endif
-#ifdef AT32AP700x_CHIP_HAS_SPI
-void gpio_enable_spi0(unsigned long cs_mask);
-void gpio_enable_spi1(unsigned long cs_mask);
-#endif
+#include <asm/arch-common/portmux-pio.h>
 
 #endif /* __ASM_AVR32_ARCH_GPIO_H__ */
diff --git a/include/asm-avr32/arch-at32ap700x/portmux.h b/include/asm-avr32/arch-at32ap700x/portmux.h
new file mode 100644
index 0000000..491d588
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap700x/portmux.h
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2006, 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_PORTMUX_H__
+#define __ASM_AVR32_ARCH_PORTMUX_H__
+
+#include <asm/arch/gpio.h>
+
+#define PORTMUX_PORT_A		((void *)PIOA_BASE)
+#define PORTMUX_PORT_B		((void *)PIOB_BASE)
+#define PORTMUX_PORT_C		((void *)PIOC_BASE)
+#define PORTMUX_PORT_D		((void *)PIOD_BASE)
+#define PORTMUX_PORT_E		((void *)PIOE_BASE)
+
+void portmux_enable_ebi(unsigned int bus_width, unsigned int addr_width,
+		unsigned long flags, unsigned long drive_strength);
+
+#define PORTMUX_EBI_CS(x)	(1 << (x))
+#define PORTMUX_EBI_NAND	(1 << 6)
+#define PORTMUX_EBI_CF(x)	(1 << ((x) + 7))
+#define PORTMUX_EBI_NWAIT	(1 << 9)
+
+#ifdef AT32AP700x_CHIP_HAS_USART
+static inline void portmux_enable_usart0(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 8) | (1 << 9),
+			PORTMUX_FUNC_B, 0);
+}
+
+static inline void portmux_enable_usart1(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 17) | (1 << 18),
+			PORTMUX_FUNC_A, 0);
+}
+
+static inline void portmux_enable_usart2(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_B, (1 << 26) | (1 << 27),
+			PORTMUX_FUNC_B, 0);
+}
+
+static inline void portmux_enable_usart3(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_B, (1 << 17) | (1 << 18),
+			PORTMUX_FUNC_B, 0);
+}
+#endif
+#ifdef AT32AP700x_CHIP_HAS_MACB
+void portmux_enable_macb0(unsigned long flags, unsigned long drive_strength);
+void portmux_enable_macb1(unsigned long flags, unsigned long drive_strength);
+
+#define PORTMUX_MACB_RMII	(0)
+#define PORTMUX_MACB_MII	(1 << 0)
+#define PORTMUX_MACB_SPEED	(1 << 1)
+
+#endif
+#ifdef AT32AP700x_CHIP_HAS_MMCI
+void portmux_enable_mmci(unsigned int slot, unsigned long flags,
+		unsigned long drive_strength);
+
+#define PORTMUX_MMCI_4BIT	(1 << 0)
+#define PORTMUX_MMCI_8BIT	(PORTMUX_MMCI_4BIT | (1 << 1))
+#define PORTMUX_MMCI_EXT_PULLUP	(1 << 2)
+
+#endif
+#ifdef AT32AP700x_CHIP_HAS_SPI
+void portmux_enable_spi0(unsigned long cs_mask, unsigned long drive_strength);
+void portmux_enable_spi1(unsigned long cs_mask, unsigned long drive_strength);
+#endif
+#ifdef AT32AP700x_CHIP_HAS_LCDC
+void portmux_enable_lcdc(void);
+#endif
+
+#endif /* __ASM_AVR32_ARCH_PORTMUX_H__ */
diff --git a/include/asm-avr32/arch-at32ap720x/clk.h b/include/asm-avr32/arch-at32ap720x/clk.h
new file mode 100644
index 0000000..f6b0433
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap720x/clk.h
@@ -0,0 +1,232 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_CLK_H__
+#define __ASM_AVR32_ARCH_CLK_H__
+
+#include <asm/arch/portmux.h>
+
+#ifdef CONFIG_PLL
+#define PLL0_RATE	((CFG_OSC0_HZ / CFG_PLL0_DIV) * CFG_PLL0_MUL)
+#define MAIN_CLK_RATE	PLL0_RATE
+#else
+#define MAIN_CLK_RATE (CFG_OSC0_HZ)
+#endif
+
+static inline unsigned long get_cpu_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_CPU;
+}
+static inline unsigned long get_hsb_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_HSB;
+}
+static inline unsigned long get_pba_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_PBA;
+}
+static inline unsigned long get_pbb_clk_rate(void)
+{
+	return MAIN_CLK_RATE >> CFG_CLKDIV_PBB;
+}
+
+/* Accessors for specific devices. More will be added as needed. */
+static inline unsigned long get_sdram_clk_rate(void)
+{
+	return get_hsb_clk_rate();
+}
+
+static inline unsigned long get_usart_clk_rate(unsigned int dev_id)
+{
+	return get_pba_clk_rate();
+}
+
+static inline unsigned long get_macb_pclk_rate(unsigned int dev_id)
+{
+	return get_pbb_clk_rate();
+}
+
+static inline unsigned long get_macb_hclk_rate(unsigned int dev_id)
+{
+	return get_hsb_clk_rate();
+}
+
+static inline unsigned long get_mci_clk_rate(void)
+{
+	return get_pbb_clk_rate();
+}
+
+static inline unsigned long get_spi_clk_rate(unsigned int dev_id)
+{
+	return get_pbb_clk_rate();
+}
+
+static inline unsigned long get_lcdc_clk_rate(unsigned int dev_id)
+{
+	/* Return the rate of the pixel clock, not the bus clock */
+	return MAIN_CLK_RATE;
+}
+
+extern void clk_init(void);
+
+/* Board code may need the SDRAM base clock as a compile-time constant */
+#define SDRAMC_BUS_HZ	(MAIN_CLK_RATE >> CFG_CLKDIV_HSB)
+
+/* Generic clock control */
+enum gclk_parent {
+	GCLK_PARENT_RCOSC	= 0,
+	GCLK_PARENT_OSC32	= 1,
+	GCLK_PARENT_OSC0	= 2,
+	GCLK_PARENT_OSC1	= 3,
+	GCLK_PARENT_OSC2	= 4,
+	GCLK_PARENT_PLL0	= 5,
+	GCLK_PARENT_PLL1	= 6,
+	GCLK_PARENT_PLL2	= 7,
+	GCLK_PARENT_CPU		= 8,
+	GCLK_PARENT_HSB		= 9,
+	GCLK_PARENT_PBA		= 10,
+	GCLK_PARENT_PBB		= 11,
+};
+
+/* Some generic clocks have specific roles */
+#define GCLK_USBH_OHCI		0
+#define GCLK_LCDC_PIXCLK	6
+#define GCLK_AST_GCLK		7
+
+extern unsigned long __gclk_set_rate(unsigned int id, enum gclk_parent parent,
+		unsigned long rate, unsigned long parent_rate);
+
+/**
+ * gclk_set_rate - configure and enable a generic clock
+ * @id: Which GCLK[id] to enable
+ * @parent: Parent clock feeding the GCLK
+ * @rate: Target rate of the GCLK in Hz
+ *
+ * Returns the actual GCLK rate in Hz, after rounding to the nearest
+ * supported rate.
+ *
+ * All three parameters are usually constant, hence the inline.
+ */
+static inline unsigned long gclk_set_rate(unsigned int id,
+		enum gclk_parent parent, unsigned long rate)
+{
+	unsigned long parent_rate;
+
+	if (id > 7)
+		return 0;
+
+	switch (parent) {
+	case GCLK_PARENT_RCOSC:
+	case GCLK_PARENT_OSC32:
+		parent_rate = 32768;
+		break;
+	case GCLK_PARENT_OSC0:
+		parent_rate = CFG_OSC0_HZ;
+		break;
+#ifdef CFG_OSC1_HZ
+	case GCLK_PARENT_OSC1:
+		parent_rate = CFG_OSC1_HZ;
+		break;
+#endif
+#ifdef CFG_OSC2_HZ
+	case GCLK_PARENT_OSC2:
+		parent_rate = CFG_OSC2_HZ;
+		break;
+#endif
+#ifdef PLL0_RATE
+	case GCLK_PARENT_PLL0:
+		parent_rate = PLL0_RATE;
+		break;
+#endif
+#ifdef PLL1_RATE
+	case GCLK_PARENT_PLL1:
+		parent_rate = PLL1_RATE;
+		break;
+#endif
+#ifdef PLL2_RATE
+	case GCLK_PARENT_PLL2:
+		parent_rate = PLL2_RATE;
+		break;
+#endif
+	case GCLK_PARENT_CPU:
+		parent_rate = get_cpu_clk_rate();
+		break;
+	case GCLK_PARENT_HSB:
+		parent_rate = get_hsb_clk_rate();
+		break;
+	case GCLK_PARENT_PBA:
+		parent_rate = get_pba_clk_rate();
+		break;
+	case GCLK_PARENT_PBB:
+		parent_rate = get_pbb_clk_rate();
+		break;
+	default:
+		parent_rate = 0;
+		break;
+	}
+
+	return __gclk_set_rate(id, parent, rate, parent_rate);
+}
+
+/**
+ * gclk_enable_output - enable output on a GCLK pin
+ * @id: Which GCLK[id] pin to enable
+ * @drive_strength: Drive strength of external GCLK pin, if applicable
+ */
+static inline void gclk_enable_output(unsigned int id,
+		unsigned long drive_strength)
+{
+	switch (id) {
+	case 0:
+		portmux_select_peripheral(PORTMUX_PORT_A, 1 << 18,
+				PORTMUX_FUNC_C, drive_strength);
+		break;
+	case 1:
+		portmux_select_peripheral(PORTMUX_PORT_A, 1 << 31,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 2:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 7,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 3:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 13,
+				PORTMUX_FUNC_D, drive_strength);
+		break;
+	case 4:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 24,
+				PORTMUX_FUNC_D, drive_strength);
+		break;
+	case 5:
+		portmux_select_peripheral(PORTMUX_PORT_B, 1 << 25,
+				PORTMUX_FUNC_D, drive_strength);
+		break;
+	case 6:
+		portmux_select_peripheral(PORTMUX_PORT_C, 1 << 18,
+				PORTMUX_FUNC_A, drive_strength);
+		break;
+	case 7:
+		portmux_select_peripheral(PORTMUX_PORT_C, 1 << 21,
+				PORTMUX_FUNC_B, drive_strength);
+		break;
+	}
+}
+#endif /* __ASM_AVR32_ARCH_CLK_H__ */
diff --git a/include/asm-avr32/arch-at32ap720x/gpio.h b/include/asm-avr32/arch-at32ap720x/gpio.h
new file mode 100644
index 0000000..c6a28ad
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap720x/gpio.h
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_GPIO_H__
+#define __ASM_AVR32_ARCH_GPIO_H__
+
+#include <asm/arch-common/portmux-gpio.h>
+#include <asm/arch/memory-map.h>
+
+/*
+ * Pin numbers identifying specific GPIO pins on the chip.
+ */
+#define GPIO_PORTA_BASE		(0)
+#define GPIO_PORTB_BASE		(GPIO_PORTA_BASE + 32)
+#define GPIO_PORTC_BASE		(GPIO_PORTB_BASE + 32)
+#define GPIO_PORTD_BASE		(GPIO_PORTC_BASE + 32)
+#define GPIO_PORTE_BASE		(GPIO_PORTD_BASE + 32)
+#define GPIO_PORTF_BASE		(GPIO_PORTE_BASE + 32)
+#define GPIO_PIN_PA(x)		(GPIO_PORTA_BASE + (x))
+#define GPIO_PIN_PB(x)		(GPIO_PORTB_BASE + (x))
+#define GPIO_PIN_PC(x)		(GPIO_PORTC_BASE + (x))
+#define GPIO_PIN_PD(x)		(GPIO_PORTD_BASE + (x))
+#define GPIO_PIN_PE(x)		(GPIO_PORTE_BASE + (x))
+#define GPIO_PIN_PF(x)		(GPIO_PORTF_BASE + (x))
+
+#endif /* __ASM_AVR32_ARCH_GPIO_H__ */
diff --git a/include/asm-avr32/arch-at32ap720x/hmatrix.h b/include/asm-avr32/arch-at32ap720x/hmatrix.h
new file mode 100644
index 0000000..0b1f1dd
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap720x/hmatrix.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_HMATRIX_H__
+#define __ASM_AVR32_ARCH_HMATRIX_H__
+
+#include <asm/hmatrix-common.h>
+
+/* Bitfields in EBI SFR */
+#define HMATRIX_EBI_SDRAM_ENABLE_OFFSET		1
+#define HMATRIX_EBI_SDRAM_ENABLE_SIZE		1
+#define HMATRIX_EBI_NAND_ENABLE_OFFSET		3
+#define HMATRIX_EBI_NAND_ENABLE_SIZE		1
+#define HMATRIX_EBI_CF0_ENABLE_OFFSET		4
+#define HMATRIX_EBI_CF0_ENABLE_SIZE		1
+#define HMATRIX_EBI_CF1_ENABLE_OFFSET		5
+#define HMATRIX_EBI_CF1_ENABLE_SIZE		1
+#define HMATRIX_EBI_PULLUP_DISABLE_OFFSET	8
+#define HMATRIX_EBI_PULLUP_DISABLE_SIZE		1
+
+/* HSB masters */
+#define HMATRIX_MASTER_CPU_ICACHE		 0
+#define HMATRIX_MASTER_CPU_DCACHE		 1
+#define HMATRIX_MASTER_PDCA			 2
+#define HMATRIX_MASTER_LCDC			 4
+#define HMATRIX_MASTER_MPOP_IBI			 5
+#define HMATRIX_MASTER_MPOP_OBI			 6
+#define HMATRIX_MASTER_MPOP_OM			 7
+#define HMATRIX_MASTER_DMACA_M0			 8
+#define HMATRIX_MASTER_DMACA_M1			 9
+#define HMATRIX_MASTER_USBB			10
+#define HMATRIX_MASTER_USBH_EHCI		11
+#define HMATRIX_MASTER_USBH_OHCI		12
+#define HMATRIX_MASTER_MACB			13
+
+/* HSB slaves */
+#define HMATRIX_SLAVE_BOOTROM			 0
+#define HMATRIX_SLAVE_PBA			 1
+#define HMATRIX_SLAVE_PBB			 2
+#define HMATRIX_SLAVE_PBC			 3
+#define HMATRIX_SLAVE_SRAM0			 4
+#define HMATRIX_SLAVE_SRAM1			 5
+#define HMATRIX_SLAVE_EBI			 6
+#define HMATRIX_SLAVE_LCDC			 7
+#define HMATRIX_SLAVE_MPOP			 8
+#define HMATRIX_SLAVE_DMACA			 9
+#define HMATRIX_SLAVE_USBB			10
+#define HMATRIX_SLAVE_EHCI			11
+#define HMATRIX_SLAVE_OHCI			12
+
+#endif /* AP7200_HMATRIX_H_INCLUDED */
diff --git a/include/asm-avr32/arch-at32ap720x/memory-map.h b/include/asm-avr32/arch-at32ap720x/memory-map.h
new file mode 100644
index 0000000..60bea9e
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap720x/memory-map.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __AT32AP7200_MEMORY_MAP_H__
+#define __AT32AP7200_MEMORY_MAP_H__
+
+/* Internal and external memories */
+#define EBI_SRAM_CS0_BASE			0x00000000
+#define EBI_SRAM_CS0_SIZE			0x04000000
+#define EBI_SRAM_CS4_BASE			0x0c000000
+#define EBI_SRAM_CS4_SIZE			0x04000000
+#define EBI_SRAM_CS1_BASE			0x10000000
+#define EBI_SRAM_CS1_SIZE			0x10000000
+#define EBI_SRAM_CS2_BASE			0x20000000
+#define EBI_SRAM_CS2_SIZE			0x04000000
+#define EBI_SRAM_CS3_BASE			0x24000000
+#define EBI_SRAM_CS3_SIZE			0x04000000
+#define EBI_SRAM_CS5_BASE			0x28000000
+#define EBI_SRAM_CS5_SIZE			0x04000000
+
+#define EBI_SDRAM_BASE				EBI_SRAM_CS1_BASE
+#define EBI_SDRAM_SIZE				EBI_SRAM_CS1_SIZE
+
+#define INTERNAL_ROM_BASE			0x04000000
+#define INTERNAL_ROM_SIZE			0x00008000
+#define INTERNAL_SRAM_BASE			0x08000000
+#define INTERNAL_SRAM_SIZE			0x00010000
+
+/* Devices on the High Speed Bus (HSB) */
+#define MPOP_SLAVE			0xf0000000
+#define LCDC_BASE			0xff000000
+#define DMACA_BASE			0xff100000
+#define USBB_SLAVE			0xff200000
+#define USBH_EHCI			0xff300000
+#define USBH_OHCI			0xff400000
+
+/* Devices on Peripheral Bus A (PBA) */
+#define INTC_BASE			0xffd00000
+#define PM_BASE				0xffd00400
+#define SDC_BASE			0xffd00800
+#define AST0_BASE			0xffd00c00
+#define AST1_BASE			0xffd01000
+#define WDT_BASE			0xffd01400
+#define EIC_BASE			0xffd01800
+#define FREQM_BASE			0xffd01c00
+#define GPIO_BASE			0xffd02000
+#define USART0_BASE			0xffd03000
+#define USART1_BASE			0xffd03400
+#define USART2_BASE			0xffd03800
+#define USART3_BASE			0xffd03c00
+#define USART4_BASE			0xffd04000
+#define USART5_BASE			0xffd04400
+#define TWI0_BASE			0xffd04800
+#define TWI1_BASE			0xffd04c00
+#define TC0_BASE			0xffd05000
+#define TC1_BASE			0xffd05400
+#define TSADCC_BASE			0xffd05800
+#define AC97C_BASE			0xffd05c00
+#define KEYPAD_BASE			0xffd06000
+#define BUSMONITOR_BASE			0xffd06400
+
+/* Devices on Peripheral Bus B (PBB) */
+#define PDMA_BASE			0xffe00000
+#define ISI_BASE			0xffe01000
+#define MPOP_BASE			0xffe02000
+#define USBB_BASE			0xffe03000
+#define MACB0_BASE			0xffe04000
+#define HSMC_BASE			0xffe04400
+#define HSDRAMC_BASE			0xffe04800
+#define ECC_BASE			0xffe04c00
+#define HMATRIX_BASE			0xffe05000
+#define SPI0_BASE			0xffe05400
+#define SPI1_BASE			0xffe05800
+#define SPI2_BASE			0xffe05c00
+#define SPI3_BASE			0xffe06000
+#define SSC0_BASE			0xffe06400
+#define SSC1_BASE			0xffe06800
+#define SSC2_BASE			0xffe06c00
+
+/* Devices on Peripheral Bus C (PBC) */
+#define MMCI_BASE			0xfff00000
+
+#endif /*__AT32AP7200_MEMORY_MAP_H__ */
diff --git a/include/asm-avr32/arch-at32ap720x/mmc.h b/include/asm-avr32/arch-at32ap720x/mmc.h
new file mode 100644
index 0000000..9caba91
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap720x/mmc.h
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2004-2006 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_MMC_H
+#define __ASM_AVR32_MMC_H
+
+struct mmc_cid {
+	unsigned long psn;
+	unsigned short oid;
+	unsigned char mid;
+	unsigned char prv;
+	unsigned char mdt;
+	char pnm[7];
+};
+
+struct mmc_csd
+{
+	u8	csd_structure:2,
+		spec_vers:4,
+		rsvd1:2;
+	u8	taac;
+	u8	nsac;
+	u8	tran_speed;
+	u16	ccc:12,
+		read_bl_len:4;
+	u64	read_bl_partial:1,
+		write_blk_misalign:1,
+		read_blk_misalign:1,
+		dsr_imp:1,
+		rsvd2:2,
+		c_size:12,
+		vdd_r_curr_min:3,
+		vdd_r_curr_max:3,
+		vdd_w_curr_min:3,
+		vdd_w_curr_max:3,
+		c_size_mult:3,
+		sector_size:5,
+		erase_grp_size:5,
+		wp_grp_size:5,
+		wp_grp_enable:1,
+		default_ecc:2,
+		r2w_factor:3,
+		write_bl_len:4,
+		write_bl_partial:1,
+		rsvd3:5;
+	u8	file_format_grp:1,
+		copy:1,
+		perm_write_protect:1,
+		tmp_write_protect:1,
+		file_format:2,
+		ecc:2;
+	u8	crc:7;
+	u8	one:1;
+};
+
+#define R1_ILLEGAL_COMMAND		(1 << 22)
+#define R1_APP_CMD			(1 << 5)
+
+#endif /* __ASM_AVR32_MMC_H */
diff --git a/include/asm-avr32/arch-at32ap720x/portmux.h b/include/asm-avr32/arch-at32ap720x/portmux.h
new file mode 100644
index 0000000..3cd570f
--- /dev/null
+++ b/include/asm-avr32/arch-at32ap720x/portmux.h
@@ -0,0 +1,100 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __ASM_AVR32_ARCH_PORTMUX_H__
+#define __ASM_AVR32_ARCH_PORTMUX_H__
+
+#include <asm/arch-common/portmux-gpio.h>
+
+#define PORTMUX_PORT_A		((void *)GPIO_BASE)
+#define PORTMUX_PORT_B		(PORTMUX_PORT_A + 0x200)
+#define PORTMUX_PORT_C		(PORTMUX_PORT_B + 0x200)
+#define PORTMUX_PORT_D		(PORTMUX_PORT_C + 0x200)
+#define PORTMUX_PORT_E		(PORTMUX_PORT_D + 0x200)
+#define PORTMUX_PORT_F		(PORTMUX_PORT_E + 0x200)
+#define PORTMUX_PORT_X0		(PORTMUX_PORT_F + 0x200)
+#define PORTMUX_PORT_X1		(PORTMUX_PORT_X0 + 0x200)
+
+void portmux_enable_ebi(unsigned int bus_width, unsigned int addr_width,
+		unsigned long flags, unsigned long drive_strength);
+
+#define PORTMUX_EBI_CS(x)	(1 << (x))
+#define PORTMUX_EBI_NAND	(1 << 6)
+#define PORTMUX_EBI_CF(x)	(1 << ((x) + 7))
+#define PORTMUX_EBI_NWAIT	(1 << 9)
+
+static inline void portmux_enable_usart0(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_B, (1 << 14) | (1 << 15),
+			PORTMUX_FUNC_B, 0);
+}
+
+static inline void portmux_enable_usart1(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 8) | (1 << 9),
+			PORTMUX_FUNC_A, 0);
+}
+
+static inline void portmux_enable_usart2(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 16) | (1 << 17),
+			PORTMUX_FUNC_A, 0);
+}
+
+static inline void portmux_enable_usart3(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_C, (1 << 10) | (1 << 11),
+			PORTMUX_FUNC_A, 0);
+}
+
+static inline void portmux_enable_usart4(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 14) | (1 << 15),
+			PORTMUX_FUNC_A, 0);
+}
+
+static inline void portmux_enable_usart5(unsigned long drive_strength)
+{
+	portmux_select_peripheral(PORTMUX_PORT_A, (1 << 22) | (1 << 23),
+			PORTMUX_FUNC_A, 0);
+}
+
+void portmux_enable_macb0(unsigned long flags, unsigned long drive_strength);
+void portmux_enable_macb1(unsigned long flags, unsigned long drive_strength);
+
+#define PORTMUX_MACB_RMII	(0)
+#define PORTMUX_MACB_MII	(1 << 0)
+#define PORTMUX_MACB_SPEED	(1 << 1)
+
+void portmux_enable_mmci(unsigned int slot, unsigned long flags,
+		unsigned long drive_strength);
+
+#define PORTMUX_MMCI_4BIT	(1 << 0)
+#define PORTMUX_MMCI_8BIT	(PORTMUX_MMCI_4BIT | (1 << 1))
+#define PORTMUX_MMCI_EXT_PULLUP	(1 << 2)
+
+void portmux_enable_spi0(unsigned long cs_mask, unsigned long drive_strength);
+void portmux_enable_spi1(unsigned long cs_mask, unsigned long drive_strength);
+
+/* FIXME */
+void portmux_enable_lcdc(void);
+
+#endif /* __ASM_AVR32_ARCH_PORTMUX_H__ */
diff --git a/include/asm-avr32/arch-common/portmux-gpio.h b/include/asm-avr32/arch-common/portmux-gpio.h
new file mode 100644
index 0000000..24943ec
--- /dev/null
+++ b/include/asm-avr32/arch-common/portmux-gpio.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __AVR32_PORTMUX_GPIO_H__
+#define __AVR32_PORTMUX_GPIO_H__
+
+#include <asm/io.h>
+
+/* Register offsets */
+struct gpio_regs {
+	u32	GPER;
+	u32	GPERS;
+	u32	GPERC;
+	u32	GPERT;
+	u32	PMR0;
+	u32	PMR0S;
+	u32	PMR0C;
+	u32	PMR0T;
+	u32	PMR1;
+	u32	PMR1S;
+	u32	PMR1C;
+	u32	PMR1T;
+	u32	__reserved0[4];
+	u32	ODER;
+	u32	ODERS;
+	u32	ODERC;
+	u32	ODERT;
+	u32	OVR;
+	u32	OVRS;
+	u32	OVRC;
+	u32	OVRT;
+	u32	PVR;
+	u32	__reserved_PVRS;
+	u32	__reserved_PVRC;
+	u32	__reserved_PVRT;
+	u32	PUER;
+	u32	PUERS;
+	u32	PUERC;
+	u32	PUERT;
+	u32	PDER;
+	u32	PDERS;
+	u32	PDERC;
+	u32	PDERT;
+	u32	IER;
+	u32	IERS;
+	u32	IERC;
+	u32	IERT;
+	u32	IMR0;
+	u32	IMR0S;
+	u32	IMR0C;
+	u32	IMR0T;
+	u32	IMR1;
+	u32	IMR1S;
+	u32	IMR1C;
+	u32	IMR1T;
+	u32	GFER;
+	u32	GFERS;
+	u32	GFERC;
+	u32	GFERT;
+	u32	IFR;
+	u32	__reserved_IFRS;
+	u32	IFRC;
+	u32	__reserved_IFRT;
+	u32	ODMER;
+	u32	ODMERS;
+	u32	ODMERC;
+	u32	ODMERT;
+	u32	__reserved1[4];
+	u32	ODCR0;
+	u32	ODCR0S;
+	u32	ODCR0C;
+	u32	ODCR0T;
+	u32	ODCR1;
+	u32	ODCR1S;
+	u32	ODCR1C;
+	u32	ODCR1T;
+	u32	__reserved2[4];
+	u32	OSRR0;
+	u32	OSRR0S;
+	u32	OSRR0C;
+	u32	OSRR0T;
+	u32	__reserved3[8];
+	u32	STER;
+	u32	STERS;
+	u32	STERC;
+	u32	STERT;
+	u32	__reserved4[35];
+	u32	VERSION;
+};
+
+/* Register access macros */
+#define gpio_readl(port, reg)						\
+	__raw_readl(&((struct gpio_regs *)port)->reg)
+#define gpio_writel(gpio, reg, value)					\
+	__raw_writel(value, &((struct gpio_regs *)port)->reg)
+
+/* Portmux API starts here. See doc/README.AVR32-port-muxing */
+
+enum portmux_function {
+	PORTMUX_FUNC_A,
+	PORTMUX_FUNC_B,
+	PORTMUX_FUNC_C,
+	PORTMUX_FUNC_D,
+};
+
+#define PORTMUX_DIR_INPUT	(0 << 0)
+#define PORTMUX_DIR_OUTPUT	(1 << 0)
+#define PORTMUX_INIT_LOW	(0 << 1)
+#define PORTMUX_INIT_HIGH	(1 << 1)
+#define PORTMUX_PULL_UP		(1 << 2)
+#define PORTMUX_PULL_DOWN	(2 << 2)
+#define PORTMUX_BUSKEEPER	(3 << 2)
+#define PORTMUX_DRIVE_MIN	(0 << 4)
+#define PORTMUX_DRIVE_LOW	(1 << 4)
+#define PORTMUX_DRIVE_HIGH	(2 << 4)
+#define PORTMUX_DRIVE_MAX	(3 << 4)
+#define PORTMUX_OPEN_DRAIN	(1 << 6)
+
+void portmux_select_peripheral(void *port, unsigned long pin_mask,
+		enum portmux_function func, unsigned long flags);
+void portmux_select_gpio(void *port, unsigned long pin_mask,
+		unsigned long flags);
+
+/* Internal helper functions */
+
+static inline void *gpio_pin_to_port(unsigned int pin)
+{
+	return (void *)GPIO_BASE + (pin >> 5) * 0x200;
+}
+
+static inline void __gpio_set_output_value(void *port, unsigned int pin,
+		int value)
+{
+	if (value)
+		gpio_writel(port, OVRS, 1 << pin);
+	else
+		gpio_writel(port, OVRC, 1 << pin);
+}
+
+static inline int __gpio_get_input_value(void *port, unsigned int pin)
+{
+	return (gpio_readl(port, PVR) >> pin) & 1;
+}
+
+void gpio_set_output_value(unsigned int pin, int value);
+int gpio_get_input_value(unsigned int pin);
+
+/* GPIO API starts here */
+
+/*
+ * GCC doesn't realize that the constant case is extremely trivial,
+ * so we need to help it make the right decision by using
+ * always_inline.
+ */
+__attribute__((always_inline))
+static inline void gpio_set_value(unsigned int pin, int value)
+{
+	if (__builtin_constant_p(pin))
+		__gpio_set_output_value(gpio_pin_to_port(pin),
+				pin & 0x1f, value);
+	else
+		gpio_set_output_value(pin, value);
+}
+
+__attribute__((always_inline))
+static inline int gpio_get_value(unsigned int pin)
+{
+	if (__builtin_constant_p(pin))
+		return __gpio_get_input_value(gpio_pin_to_port(pin),
+				pin & 0x1f);
+	else
+		return gpio_get_input_value(pin);
+}
+
+#endif /* __AVR32_PORTMUX_GPIO_H__ */
diff --git a/include/asm-avr32/arch-common/portmux-pio.h b/include/asm-avr32/arch-common/portmux-pio.h
new file mode 100644
index 0000000..1abe5be
--- /dev/null
+++ b/include/asm-avr32/arch-common/portmux-pio.h
@@ -0,0 +1,138 @@
+/*
+ * Copyright (C) 2006, 2008 Atmel Corporation
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __AVR32_PORTMUX_PIO_H__
+#define __AVR32_PORTMUX_PIO_H__
+
+#include <asm/io.h>
+
+/* PIO register offsets */
+#define PIO_PER			0x0000
+#define PIO_PDR			0x0004
+#define PIO_PSR			0x0008
+#define PIO_OER			0x0010
+#define PIO_ODR			0x0014
+#define PIO_OSR			0x0018
+#define PIO_IFER		0x0020
+#define PIO_IFDR		0x0024
+#define PIO_ISFR		0x0028
+#define PIO_SODR		0x0030
+#define PIO_CODR		0x0034
+#define PIO_ODSR		0x0038
+#define PIO_PDSR		0x003c
+#define PIO_IER			0x0040
+#define PIO_IDR			0x0044
+#define PIO_IMR			0x0048
+#define PIO_ISR			0x004c
+#define PIO_MDER		0x0050
+#define PIO_MDDR		0x0054
+#define PIO_MDSR		0x0058
+#define PIO_PUDR		0x0060
+#define PIO_PUER		0x0064
+#define PIO_PUSR		0x0068
+#define PIO_ASR			0x0070
+#define PIO_BSR			0x0074
+#define PIO_ABSR		0x0078
+#define PIO_OWER		0x00a0
+#define PIO_OWDR		0x00a4
+#define PIO_OWSR		0x00a8
+
+/* Hardware register access */
+#define pio_readl(base, reg)				\
+	__raw_readl((void *)base + PIO_##reg)
+#define pio_writel(base, reg, value)			\
+	__raw_writel((value), (void *)base + PIO_##reg)
+
+/* Portmux API starts here. See doc/README.AVR32-port-muxing */
+
+enum portmux_function {
+	PORTMUX_FUNC_A,
+	PORTMUX_FUNC_B,
+};
+
+/* Pull-down, buskeeper and drive strength are not supported */
+#define PORTMUX_DIR_INPUT	(0 << 0)
+#define PORTMUX_DIR_OUTPUT	(1 << 0)
+#define PORTMUX_INIT_LOW	(0 << 1)
+#define PORTMUX_INIT_HIGH	(1 << 1)
+#define PORTMUX_PULL_UP		(1 << 2)
+#define PORTMUX_PULL_DOWN	(0)
+#define PORTMUX_BUSKEEPER	PORTMUX_PULL_UP
+#define PORTMUX_DRIVE_MIN	(0)
+#define PORTMUX_DRIVE_LOW	(0)
+#define PORTMUX_DRIVE_HIGH	(0)
+#define PORTMUX_DRIVE_MAX	(0)
+#define PORTMUX_OPEN_DRAIN	(1 << 3)
+
+void portmux_select_peripheral(void *port, unsigned long pin_mask,
+		enum portmux_function func, unsigned long flags);
+void portmux_select_gpio(void *port, unsigned long pin_mask,
+		unsigned long flags);
+
+/* Internal helper functions */
+
+static inline void __pio_set_output_value(void *port, unsigned int pin,
+		int value)
+{
+	/*
+	 * value will usually be constant, but it's pretty cheap
+	 * either way.
+	 */
+	if (value)
+		pio_writel(port, SODR, 1 << pin);
+	else
+		pio_writel(port, CODR, 1 << pin);
+}
+
+static inline int __pio_get_input_value(void *port, unsigned int pin)
+{
+	return (pio_readl(port, PDSR) >> pin) & 1;
+}
+
+void pio_set_output_value(unsigned int pin, int value);
+int pio_get_input_value(unsigned int pin);
+
+/* GPIO API starts here */
+
+/*
+ * GCC doesn't realize that the constant case is extremely trivial,
+ * so we need to help it make the right decision by using
+ * always_inline.
+ */
+__attribute__((always_inline))
+static inline void gpio_set_value(unsigned int pin, int value)
+{
+	if (__builtin_constant_p(pin))
+		__pio_set_output_value(pio_pin_to_port(pin), pin & 0x1f, value);
+	else
+		pio_set_output_value(pin, value);
+}
+
+__attribute__((always_inline))
+static inline int gpio_get_value(unsigned int pin)
+{
+	if (__builtin_constant_p(pin))
+		return __pio_get_input_value(pio_pin_to_port(pin), pin & 0x1f);
+	else
+		return pio_get_input_value(pin);
+}
+
+#endif /* __AVR32_PORTMUX_PIO_H__ */
diff --git a/include/asm-avr32/global_data.h b/include/asm-avr32/global_data.h
index 007cfe4..7510401 100644
--- a/include/asm-avr32/global_data.h
+++ b/include/asm-avr32/global_data.h
@@ -41,6 +41,7 @@ typedef	struct	global_data {
 	unsigned long	reloc_off;	/* Relocation Offset */
 	unsigned long	env_addr;	/* Address of env struct */
 	unsigned long	env_valid;	/* Checksum of env valid? */
+	unsigned long	fb_base;	/* Base address of frame buffer */
 	unsigned long	cpu_hz;		/* cpu core clock frequency */
 	void		**jt;		/* jump table */
 } gd_t;
diff --git a/include/asm-avr32/initcalls.h b/include/asm-avr32/initcalls.h
index 583e5dc..57a278b 100644
--- a/include/asm-avr32/initcalls.h
+++ b/include/asm-avr32/initcalls.h
@@ -26,6 +26,5 @@
 
 extern int cpu_init(void);
 extern int timer_init(void);
-extern void board_init_info(void);
 
 #endif /* __ASM_AVR32_INITCALLS_H__ */
diff --git a/include/asm-avr32/sdram.h b/include/asm-avr32/sdram.h
index 7bdefc1..762acfa 100644
--- a/include/asm-avr32/sdram.h
+++ b/include/asm-avr32/sdram.h
@@ -25,8 +25,8 @@
 struct sdram_config {
 	/* Number of data bits. */
 	enum {
-		SDRAM_DATA_16BIT,
-		SDRAM_DATA_32BIT,
+		SDRAM_DATA_16BIT = 16,
+		SDRAM_DATA_32BIT = 32,
 	} data_bits;
 
 	/* Number of address bits */
diff --git a/include/common.h b/include/common.h
index 2fcb1fd..7c80fb9 100644
--- a/include/common.h
+++ b/include/common.h
@@ -222,7 +222,6 @@ void	board_init_r  (gd_t *, ulong) __attribute__ ((noreturn));
 int	checkboard    (void);
 int	checkflash    (void);
 int	checkdram     (void);
-char *	strmhz(char *buf, long hz);
 int	last_stage_init(void);
 extern ulong monitor_flash_len;
 int mac_read_from_eeprom(void);
@@ -613,6 +612,9 @@ int	sprintf(char * buf, const char *fmt, ...)
 		__attribute__ ((format (__printf__, 2, 3)));
 int	vsprintf(char *buf, const char *fmt, va_list args);
 
+/* lib_generic/strmhz.c */
+char *	strmhz(char *buf, long hz);
+
 /* lib_generic/crc32.c */
 uint32_t crc32 (uint32_t, const unsigned char *, uint);
 uint32_t crc32_wd (uint32_t, const unsigned char *, uint, uint);
diff --git a/include/configs/atngw100.h b/include/configs/atngw100.h
index f040b86..c0e48c4 100644
--- a/include/configs/atngw100.h
+++ b/include/configs/atngw100.h
@@ -124,7 +124,7 @@
 
 #define CONFIG_ATMEL_USART		1
 #define CONFIG_MACB			1
-#define CONFIG_PIO2			1
+#define CONFIG_PORTMUX_PIO		1
 #define CFG_NR_PIOS			5
 #define CFG_HSDRAMC			1
 #define CONFIG_MMC			1
diff --git a/include/configs/atstk1002.h b/include/configs/atstk1002.h
index 68f0cec..f0ffebe 100644
--- a/include/configs/atstk1002.h
+++ b/include/configs/atstk1002.h
@@ -32,6 +32,9 @@
 #define CONFIG_ATSTK1002		1
 #define CONFIG_ATSTK1000		1
 
+#define CFG_CPU_NAME			"AT32AP7000"
+#define CFG_BOARD_NAME			"ATSTK1002"
+
 #define CONFIG_ATSTK1000_EXT_FLASH	1
 
 /*
@@ -129,6 +132,8 @@
 #define CONFIG_BOOTP_SUBNETMASK
 #define CONFIG_BOOTP_GATEWAY
 
+/* LCD support. This will affect a few other settings */
+#define CONFIG_LCD			1
 
 /*
  * Command line configuration.
@@ -149,12 +154,32 @@
 
 #define CONFIG_ATMEL_USART		1
 #define CONFIG_MACB			1
-#define CONFIG_PIO2			1
+/* Enable both MACs by default */
+#define CONFIG_ATSTK1000_MACB0		1
+#define CONFIG_ATSTK1000_MACB1		1
+#define CONFIG_PORTMUX_PIO		1
 #define CFG_NR_PIOS			5
 #define CFG_HSDRAMC			1
 #define CONFIG_MMC			1
 #define CONFIG_ATMEL_MCI		1
 
+#ifdef CONFIG_LCD
+/* Second MACB conflicts with LCD signals */
+#undef CONFIG_ATSTK1000_MACB1
+#define CONFIG_ATMEL_SPI		1
+#define CFG_LCD_NPCS			1
+#define CFG_LCD_NPCS_PIN		GPIO_PIN_PA(4)
+#define CONFIG_ATMEL_LCD		1
+#define CONFIG_LCDC_PIXCLK_RATE		PLL0_RATE
+#define CONFIG_ATMEL_LCD_BGR555		1
+#define LCD_BPP				LCD_COLOR8
+#define CONFIG_LCD_LOGO			1
+#define CONFIG_LCD_INFO			1
+#define CONFIG_LCD_INFO_BELOW_LOGO	1
+#define CFG_WHITE_ON_BLACK		1
+#define CFG_CONSOLE_IS_IN_ENV		1
+#endif
+
 #define CFG_DCACHE_LINESZ		32
 #define CFG_ICACHE_LINESZ		32
 
diff --git a/include/configs/atstk1003.h b/include/configs/atstk1003.h
index d3a2f69..581ae4e 100644
--- a/include/configs/atstk1003.h
+++ b/include/configs/atstk1003.h
@@ -133,7 +133,7 @@
 #undef CONFIG_CMD_XIMG
 
 #define CONFIG_ATMEL_USART		1
-#define CONFIG_PIO2			1
+#define CONFIG_PORTMUX_PIO		1
 #define CFG_HSDRAMC			1
 #define CONFIG_MMC			1
 #define CONFIG_ATMEL_MCI		1
diff --git a/include/configs/atstk1004.h b/include/configs/atstk1004.h
index a37ba92..7bcd34b 100644
--- a/include/configs/atstk1004.h
+++ b/include/configs/atstk1004.h
@@ -133,7 +133,7 @@
 #undef CONFIG_CMD_XIMG
 
 #define CONFIG_ATMEL_USART		1
-#define CONFIG_PIO2			1
+#define CONFIG_PORTMUX_PIO		1
 #define CFG_HSDRAMC			1
 #define CONFIG_MMC			1
 #define CONFIG_ATMEL_MCI		1
diff --git a/include/configs/atstk1005.h b/include/configs/atstk1005.h
new file mode 100644
index 0000000..1ed3c2d
--- /dev/null
+++ b/include/configs/atstk1005.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * Configuration settings for the ATSTK1005 CPU daughterboard
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/memory-map.h>
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7200		1
+#define CONFIG_ATSTK1005		1
+#define CONFIG_ATSTK1000		1
+
+#define CFG_CPU_NAME			"AT32AP7200"
+#define CFG_BOARD_NAME			"ATSTK1005"
+
+#define CONFIG_ATSTK1000_EXT_FLASH	1
+
+/* This must always be defined as 1000. Hands off! */
+#define CFG_HZ				1000
+
+#define CFG_OSC0_HZ			20000000
+/* FIXME when the documentation becomes consistent */
+#define CFG_OSC0_MODE			0xa
+#define CFG_OSC0_STARTUP_US		90000
+
+#define CONFIG_PLL			1
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			10
+#define CFG_PLL0_SUPPRESS_CYCLES	31
+
+/*
+ * Set the CPU running at:
+ * PLL / (2^CFG_CLKDIV_CPU) = CPU MHz
+ */
+#define CFG_CLKDIV_CPU			0
+/*
+ * Set the HSB running at:
+ * PLL / (2^CFG_CLKDIV_HSB) = HSB MHz
+ */
+#define CFG_CLKDIV_HSB			1
+/*
+ * Set the PBA running at:
+ * PLL / (2^CFG_CLKDIV_PBA) = PBA MHz
+ */
+#define CFG_CLKDIV_PBA			2
+/*
+ * Set the PBB running at:
+ * PLL / (2^CFG_CLKDIV_PBB) = PBB MHz
+ */
+#define CFG_CLKDIV_PBB			1
+
+#define CONFIG_USART4			1
+
+#define CONFIG_DOS_PARTITION		1
+#define CONFIG_MMC			1
+#define CONFIG_ATMEL_MCI		1
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0 root=mtd1 rootfstype=jffs2 fbmem=600k"
+
+#define CONFIG_BOOTCOMMAND						\
+	"fsload; bootm"
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT				\
+	"Press SPACE to abort autoboot in %d seconds\n", bootdelay
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+/*
+ * After booting the board for the first time, new ethernet addresses
+ * should be generated and assigned to the environment variables
+ * "ethaddr" and "eth1addr". This is normally done during production.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_NET_MULTI		1
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_SF
+#define CONFIG_CMD_SPI
+
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_PORTMUX_GPIO		1
+#define CFG_NR_GPIO_PORTS		8
+#define CFG_HSDRAMC			1
+#define CONFIG_MACB			1
+/* AP7200 only has one ethernet MAC */
+#define CONFIG_ATSTK1000_MACB0		1
+#define CONFIG_ATMEL_SPI		1
+
+#define CONFIG_SPI_FLASH		1
+#define CONFIG_SPI_FLASH_ATMEL		1
+#define CFG_SPI_FLASH_NPCS		0
+#define CFG_SPI_FLASH_NPCS_PIN		GPIO_PIN_PB(3)
+
+/* LCD */
+#undef CONFIG_LCD
+#ifdef CONFIG_LCD
+#define CFG_LCD_NPCS			2
+#define CFG_LCD_NPCS_PIN		GPIO_PIN_PB(5)
+#define LCD_BPP				LCD_COLOR8
+#define CONFIG_LCD_LOGO			1
+#define CONFIG_LCD_INFO			1
+#define CONFIG_LCD_INFO_BELOW_LOGO	1
+#define CFG_WHITE_ON_BLACK		1
+#define CONFIG_SPLASH_SCREEN		1
+#define CONFIG_ATMEL_LCD		1
+#define CONFIG_LCDC_PIXCLK_RATE		PLL0_RATE
+#define CONFIG_ATMEL_LCD_BGR555		1
+#define CFG_CONSOLE_IS_IN_ENV		1
+#endif
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			INTERNAL_SRAM_BASE
+#define CFG_INTRAM_SIZE			INTERNAL_SRAM_SIZE
+#define CFG_SDRAM_BASE			EBI_SDRAM_BASE
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(256*1024)
+#define CFG_DMA_ALLOC_LEN		(16384)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(EBI_SDRAM_BASE + 0x00400000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"U-Boot> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START		EBI_SDRAM_BASE
+#define CFG_MEMTEST_END			(CFG_MEMTEST_START + 0x3f00000)
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/atstk1006.h b/include/configs/atstk1006.h
index a6c5b6e..082ad0b 100644
--- a/include/configs/atstk1006.h
+++ b/include/configs/atstk1006.h
@@ -32,6 +32,9 @@
 #define CONFIG_ATSTK1006		1
 #define CONFIG_ATSTK1000		1
 
+#define CFG_CPU_NAME			"AT32AP7000"
+#define CFG_BOARD_NAME			"ATSTK1006"
+
 #define CONFIG_ATSTK1000_EXT_FLASH	1
 
 /*
@@ -130,6 +133,9 @@
 #define CONFIG_BOOTP_GATEWAY
 
 
+/* LCD support. This will affect a few other settings */
+#define CONFIG_LCD			1
+
 /*
  * Command line configuration.
  */
@@ -149,12 +155,32 @@
 
 #define CONFIG_ATMEL_USART		1
 #define CONFIG_MACB			1
-#define CONFIG_PIO2			1
+/* Enable both MACs by default */
+#define CONFIG_ATSTK1000_MACB0		1
+#define CONFIG_ATSTK1000_MACB1		1
+#define CONFIG_PORTMUX_PIO		1
 #define CFG_NR_PIOS			5
 #define CFG_HSDRAMC			1
 #define CONFIG_MMC			1
 #define CONFIG_ATMEL_MCI		1
 
+#ifdef CONFIG_LCD
+/* Second MACB conflicts with LCD signals */
+#undef CONFIG_ATSTK1000_MACB1
+#define CONFIG_ATMEL_SPI		1
+#define CFG_LCD_NPCS			1
+#define CFG_LCD_NPCS_PIN		GPIO_PIN_PA(4)
+#define CONFIG_ATMEL_LCD		1
+#define CONFIG_LCDC_PIXCLK_RATE		PLL0_RATE
+#define CONFIG_ATMEL_LCD_BGR555		1
+#define LCD_BPP				LCD_COLOR8
+#define CONFIG_LCD_LOGO			1
+#define CONFIG_LCD_INFO			1
+#define CONFIG_LCD_INFO_BELOW_LOGO	1
+#define CFG_WHITE_ON_BLACK		1
+#define CFG_CONSOLE_IS_IN_ENV		1
+#endif
+
 #define CFG_DCACHE_LINESZ		32
 #define CFG_ICACHE_LINESZ		32
 
diff --git a/include/configs/favr-32-ezkit.h b/include/configs/favr-32-ezkit.h
new file mode 100644
index 0000000..3c9420c
--- /dev/null
+++ b/include/configs/favr-32-ezkit.h
@@ -0,0 +1,201 @@
+/*
+ * Copyright (C) 2008 Atmel Corporation
+ *
+ * Configuration settings for the Favr-32 EarthLCD LCD kit.
+ *
+ * See file CREDITS for list of people who contributed to this project.
+ *
+ * This program is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License as published by the Free
+ * Software Foundation; either version 2 of the License, or (at your option)
+ * any later version.
+ *
+ * This program is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ * more details.
+ *
+ * You should have received a copy of the GNU General Public License along with
+ * this program; if not, write to the Free Software Foundation, Inc., 59 Temple
+ * Place, Suite 330, Boston, MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/memory-map.h>
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7000		1
+#define CONFIG_FAVR32_EZKIT		1
+
+#define CONFIG_FAVR32_EZKIT_EXT_FLASH	1
+
+/*
+ * Timer clock frequency. We're using the CPU-internal COUNT register
+ * for this, so this is equivalent to the CPU core clock frequency
+ */
+#define CFG_HZ				1000
+
+/*
+ * Set up the PLL to run at 140 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB at 1/2, and the PBA to run at 1/4 the
+ * PLL frequency.
+ * (CFG_OSC0_HZ * CFG_PLL0_MUL) / CFG_PLL0_DIV = PLL MHz
+ */
+#define CONFIG_PLL			1
+#define CFG_POWER_MANAGER		1
+#define CFG_OSC0_HZ			20000000
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			7
+#define CFG_PLL0_SUPPRESS_CYCLES	16
+/*
+ * Set the CPU running at:
+ * PLL / (2^CFG_CLKDIV_CPU) = CPU MHz
+ */
+#define CFG_CLKDIV_CPU			0
+/*
+ * Set the HSB running at:
+ * PLL / (2^CFG_CLKDIV_HSB) = HSB MHz
+ */
+#define CFG_CLKDIV_HSB			1
+/*
+ * Set the PBA running at:
+ * PLL / (2^CFG_CLKDIV_PBA) = PBA MHz
+ */
+#define CFG_CLKDIV_PBA			2
+/*
+ * Set the PBB running at:
+ * PLL / (2^CFG_CLKDIV_PBB) = PBB MHz
+ */
+#define CFG_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CFG_PLL0_OPT			0x04
+
+#undef CONFIG_USART0
+#undef CONFIG_USART1
+#undef CONFIG_USART2
+#define CONFIG_USART3			1
+
+/* User serviceable stuff */
+#define CONFIG_DOS_PARTITION		1
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"root=/dev/mtdblock1 rootfstype=jffs fbmem=1800k"
+
+#define CONFIG_BOOTCOMMAND						\
+	"fsload; bootm $(fileaddr)"
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT		\
+	"Press SPACE to abort autoboot in %d seconds\n", bootdelay
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+/*
+ * After booting the board for the first time, new ethernet addresses
+ * should be generated and assigned to the environment variables
+ * "ethaddr" and "eth1addr". This is normally done during production.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_NET_MULTI		1
+
+/*
+ * BOOTP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+
+#undef CONFIG_CMD_AUTOSCRIPT
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_SETGETDCR
+#undef CONFIG_CMD_XIMG
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_MACB			1
+#define CONFIG_PORTMUX_PIO		1
+#define CFG_NR_PIOS			5
+#define CFG_HSDRAMC			1
+#define CONFIG_MMC			1
+#define CONFIG_ATMEL_MCI		1
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+/* External flash on Favr-32 */
+#if 0
+#define CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+#endif
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			INTERNAL_SRAM_BASE
+#define CFG_INTRAM_SIZE			INTERNAL_SRAM_SIZE
+#define CFG_SDRAM_BASE			EBI_SDRAM_BASE
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(256*1024)
+#define CFG_DMA_ALLOC_LEN		(16384)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(EBI_SDRAM_BASE + 0x00400000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"U-Boot> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START		EBI_SDRAM_BASE
+#define CFG_MEMTEST_END			(CFG_MEMTEST_START + 0x700000)
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/hammerhead.h b/include/configs/hammerhead.h
new file mode 100644
index 0000000..2e19fd3
--- /dev/null
+++ b/include/configs/hammerhead.h
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2008 Miromico AG
+ *
+ * Configuration settings for the Miromico Hammerhead AVR32 board
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7000		1
+#define CONFIG_HAMMERHEAD		1
+
+#define CFG_HZ				1000
+
+/*
+ * Set up the PLL to run at 125 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB busses to run at 1/2 the PLL frequency
+ * and the PBA bus to run at 1/4 the PLL frequency.
+ */
+#define CONFIG_PLL			1
+#define CFG_POWER_MANAGER		1
+#define CFG_OSC0_HZ			25000000
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			5
+#define CFG_PLL0_SUPPRESS_CYCLES	16
+#define CFG_CLKDIV_CPU			0
+#define CFG_CLKDIV_HSB			1
+#define CFG_CLKDIV_PBA			2
+#define CFG_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CFG_PLL0_OPT			0x04
+
+#define CONFIG_USART1			1
+
+#define CONFIG_HOSTNAME			hammerhead
+
+/* User serviceable stuff */
+#define CONFIG_DOS_PARTITION		1
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0 root=mtd1 rootfstype=jffs2"
+#define CONFIG_BOOTCOMMAND						\
+	"fsload; bootm"
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		1
+#define CONFIG_AUTOBOOT			1
+#define CONFIG_AUTOBOOT_KEYED		1
+#define CONFIG_AUTOBOOT_PROMPT				\
+	"Press SPACE to abort autoboot in %d seconds\n", bootdelay
+#define CONFIG_AUTOBOOT_DELAY_STR	"d"
+#define CONFIG_AUTOBOOT_STOP_STR	" "
+
+/*
+ * After booting the board for the first time, new ethernet address
+ * should be generated and assigned to the environment variables
+ * "ethaddr". This is normally done during production.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_NET_MULTI		1
+
+/*
+ * BOOTP/DHCP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+#undef CONFIG_CMD_FPGA
+#undef CONFIG_CMD_SETGETDCR
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_MACB			1
+#define CONFIG_PORTMUX_PIO		1
+#define CFG_NR_PIOS			5
+#define CFG_HSDRAMC			1
+#define CONFIG_MMC			1
+#define CONFIG_ATMEL_MCI		1
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			0x24000000
+#define CFG_INTRAM_SIZE			0x8000
+
+#define CFG_SDRAM_BASE			0x10000000
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(256*1024)
+
+#define CFG_DMA_ALLOC_LEN		(16384)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(CFG_SDRAM_BASE + 0x00400000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"Hammerhead> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START		CFG_SDRAM_BASE
+#define CFG_MEMTEST_END			(CFG_MEMTEST_START + 0x1f00000)
+
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/configs/mimc200.h b/include/configs/mimc200.h
new file mode 100644
index 0000000..df4fd91
--- /dev/null
+++ b/include/configs/mimc200.h
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2006 Atmel Corporation
+ *
+ * Configuration settings for the AVR32 Network Gateway
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#ifndef __CONFIG_H
+#define __CONFIG_H
+
+#include <asm/arch/memory-map.h>
+
+#define CONFIG_AVR32			1
+#define CONFIG_AT32AP			1
+#define CONFIG_AT32AP7000		1
+#define CONFIG_MIMC200			1
+
+#define CONFIG_MIMC200_EXT_FLASH	1
+
+#define CFG_HZ				1000
+
+/*
+ * Set up the PLL to run at 140 MHz, the CPU to run at the PLL
+ * frequency, the HSB and PBB busses to run at 1/2 the PLL frequency
+ * and the PBA bus to run at 1/4 the PLL frequency.
+ */
+#define CONFIG_PLL			1
+#define CFG_POWER_MANAGER		1
+#define CFG_OSC0_HZ			10000000
+#define CFG_PLL0_DIV			1
+#define CFG_PLL0_MUL			15
+#define CFG_PLL0_SUPPRESS_CYCLES	16
+#define CFG_CLKDIV_CPU			0
+#define CFG_CLKDIV_HSB			1
+#define CFG_CLKDIV_PBA			2
+#define CFG_CLKDIV_PBB			1
+
+/*
+ * The PLLOPT register controls the PLL like this:
+ *   icp = PLLOPT<2>
+ *   ivco = PLLOPT<1:0>
+ *
+ * We want icp=1 (default) and ivco=0 (80-160 MHz) or ivco=2 (150-240MHz).
+ */
+#define CFG_PLL0_OPT			0x04
+
+#define CONFIG_USART1			1
+#define CONFIG_MIMC200_DBGLINK		1
+
+/* User serviceable stuff */
+#define CONFIG_DOS_PARTITION		1
+
+#define CONFIG_CMDLINE_TAG		1
+#define CONFIG_SETUP_MEMORY_TAGS	1
+#define CONFIG_INITRD_TAG		1
+
+#define CONFIG_STACKSIZE		(2048)
+
+#define CONFIG_BAUDRATE			115200
+#define CONFIG_BOOTARGS							\
+	"console=ttyS0 root=/dev/mtdblock1 fbmem=600k rootfstype=jffs2"
+#define CONFIG_BOOTCOMMAND						\
+	"fsload; bootm"
+
+#define CONFIG_SILENT_CONSOLE		1	/* enable silent startup */
+#define CONFIG_SILENT_CONSOLE_INPUT	1	/* disable console inputs */
+#define CFG_DEVICE_NULLDEV		1	/* include nulldev device */
+
+/*
+ * Only interrupt autoboot if <space> is pressed. Otherwise, garbage
+ * data on the serial line may interrupt the boot sequence.
+ */
+#define CONFIG_BOOTDELAY		0
+#define CONFIG_ZERO_BOOTDELAY_CHECK 	1
+#define CONFIG_AUTOBOOT			1
+
+/*
+ * After booting the board for the first time, new ethernet addresses
+ * should be generated and assigned to the environment variables
+ * "ethaddr" and "eth1addr". This is normally done during production.
+ */
+#define CONFIG_OVERWRITE_ETHADDR_ONCE	1
+#define CONFIG_NET_MULTI		1
+
+/*
+ * BOOTP/DHCP options
+ */
+#define CONFIG_BOOTP_SUBNETMASK
+#define CONFIG_BOOTP_GATEWAY
+
+#define CONFIG_DOS_PARTITION		1
+
+/*
+ * Command line configuration.
+ */
+#include <config_cmd_default.h>
+
+#define CONFIG_CMD_ASKENV
+#define CONFIG_CMD_DHCP
+#define CONFIG_CMD_EXT2
+#define CONFIG_CMD_FAT
+#define CONFIG_CMD_JFFS2
+#define CONFIG_CMD_MMC
+#define CONFIG_CMD_NET
+
+#define CONFIG_ATMEL_USART		1
+#define CONFIG_MACB			1
+#define CONFIG_PORTMUX_PIO		1
+#define CFG_NR_PIOS			5
+#define CFG_HSDRAMC			1
+#define CONFIG_MMC			1
+#define CONFIG_ATMEL_MCI		1
+
+#define CFG_DCACHE_LINESZ		32
+#define CFG_ICACHE_LINESZ		32
+
+#define CONFIG_NR_DRAM_BANKS		1
+
+#define CFG_FLASH_CFI			1
+#define CFG_FLASH_CFI_DRIVER		1
+
+#define CFG_FLASH_BASE			0x00000000
+#define CFG_FLASH_SIZE			0x800000
+#define CFG_MAX_FLASH_BANKS		1
+#define CFG_MAX_FLASH_SECT		135
+
+#define CFG_MONITOR_BASE		CFG_FLASH_BASE
+
+#define CFG_INTRAM_BASE			INTERNAL_SRAM_BASE
+#define CFG_INTRAM_SIZE			INTERNAL_SRAM_SIZE
+#define CFG_SDRAM_BASE			EBI_SDRAM_BASE
+
+#define CFG_FRAM_BASE			0x08000000
+#define CFG_FRAM_SIZE			0x20000
+
+#define CFG_ENV_IS_IN_FLASH		1
+#define CFG_ENV_SIZE			65536
+#define CFG_ENV_ADDR			(CFG_FLASH_BASE + CFG_FLASH_SIZE - CFG_ENV_SIZE)
+
+#define CFG_INIT_SP_ADDR		(CFG_INTRAM_BASE + CFG_INTRAM_SIZE)
+
+#define CFG_MALLOC_LEN			(1024*1024)
+#define CFG_DMA_ALLOC_LEN		(16384)
+
+/* Allow 4MB for the kernel run-time image */
+#define CFG_LOAD_ADDR			(EBI_SDRAM_BASE + 0x00400000)
+#define CFG_BOOTPARAMS_LEN		(16 * 1024)
+
+/* Other configuration settings that shouldn't have to change all that often */
+#define CFG_PROMPT			"U-Boot> "
+#define CFG_CBSIZE			256
+#define CFG_MAXARGS			16
+#define CFG_PBSIZE			(CFG_CBSIZE + sizeof(CFG_PROMPT) + 16)
+#define CFG_LONGHELP			1
+
+#define CFG_MEMTEST_START		EBI_SDRAM_BASE
+#define CFG_MEMTEST_END			(CFG_MEMTEST_START + 0x1f00000)
+
+#define CFG_BAUDRATE_TABLE { 115200, 38400, 19200, 9600, 2400 }
+
+#endif /* __CONFIG_H */
diff --git a/include/lcd.h b/include/lcd.h
index 44ac8ef..ead9e1d 100644
--- a/include/lcd.h
+++ b/include/lcd.h
@@ -197,6 +197,8 @@ void	lcd_putc	(const char c);
 void	lcd_puts	(const char *s);
 void	lcd_printf	(const char *fmt, ...);
 
+/* Allow boards to customize the information displayed */
+void lcd_show_board_info(void);
 
 /************************************************************************/
 /* ** BITMAP DISPLAY SUPPORT						*/
diff --git a/include/spi.h b/include/spi.h
index 320e50e..be87173 100644
--- a/include/spi.h
+++ b/include/spi.h
@@ -176,6 +176,19 @@ void spi_cs_activate(struct spi_slave *slave);
 void spi_cs_deactivate(struct spi_slave *slave);
 
 /*-----------------------------------------------------------------------
+ * Single SPI Transfer
+ *
+ * Convenience wrapper for doing a single SPI transfer, i.e. asserting
+ * CS before, and deasserting it after the transfer.
+ */
+static inline int spi_xfer_single(struct spi_slave *slave,
+		unsigned int bitlen, const void *dout, void *din)
+{
+	return spi_xfer(slave, bitlen, dout, din,
+			SPI_XFER_BEGIN | SPI_XFER_END);
+}
+
+/*-----------------------------------------------------------------------
  * Write 8 bits, then read 8 bits.
  *   slave:	The SPI slave we're communicating with
  *   byte:	Byte to be written
@@ -193,7 +206,7 @@ static inline int spi_w8r8(struct spi_slave *slave, unsigned char byte)
 	dout[0] = byte;
 	dout[1] = 0;
 
-	ret = spi_xfer(slave, 16, dout, din, SPI_XFER_BEGIN | SPI_XFER_END);
+	ret = spi_xfer_single(slave, 16, dout, din);
 	return ret < 0 ? ret : din[1];
 }
 
diff --git a/lib_arm/board.c b/lib_arm/board.c
index a093860..6e3ef08 100644
--- a/lib_arm/board.c
+++ b/lib_arm/board.c
@@ -115,19 +115,6 @@ void *sbrk (ptrdiff_t increment)
 	return ((void *) old);
 }
 
-char *strmhz(char *buf, long hz)
-{
-	long l, n;
-	long m;
-
-	n = hz / 1000000L;
-	l = sprintf (buf, "%ld", n);
-	m = (hz % 1000000L) / 1000L;
-	if (m != 0)
-		sprintf (buf + l, ".%03ld", m);
-	return (buf);
-}
-
 
 /************************************************************************
  * Coloured LED functionality
diff --git a/lib_avr32/board.c b/lib_avr32/board.c
index d6423d4..ba77106 100644
--- a/lib_avr32/board.c
+++ b/lib_avr32/board.c
@@ -47,6 +47,14 @@ static unsigned long mem_malloc_start = 0;
 static unsigned long mem_malloc_end = 0;
 static unsigned long mem_malloc_brk = 0;
 
+/* Weak aliases for optional board functions */
+static int __do_nothing(void)
+{
+	return 0;
+}
+int board_postclk_init(void) __attribute__((weak, alias("__do_nothing")));
+int board_early_init_r(void) __attribute__((weak, alias("__do_nothing")));
+
 /* The malloc area is right below the monitor image in RAM */
 static void mem_malloc_init(void)
 {
@@ -169,6 +177,16 @@ static void display_flash_config (void)
 	printf("at address 0x%08lx\n", gd->bd->bi_flashstart);
 }
 
+#include <asm/arch/clk.h>
+static void show_clocks(void)
+{
+	printf("CPU: %lu Mhz HSB: %lu MHz PBA: %lu MHz PBB: %lu MHz\n",
+			get_cpu_clk_rate() / 1000000,
+			get_hsb_clk_rate() / 1000000,
+			get_pba_clk_rate() / 1000000,
+			get_pbb_clk_rate() / 1000000);
+}
+
 void board_init_f(ulong board_type)
 {
 	gd_t gd_data;
@@ -187,11 +205,13 @@ void board_init_f(ulong board_type)
 	/* Perform initialization sequence */
 	board_early_init_f();
 	cpu_init();
+	board_postclk_init();
 	env_init();
 	init_baudrate();
 	serial_init();
 	console_init_f();
 	display_banner();
+	show_clocks();
 	sdram_size = initdram(board_type);
 
 	/* If we have no SDRAM, we can't go on */
@@ -229,6 +249,12 @@ void board_init_f(ulong board_type)
 	addr -= CFG_DMA_ALLOC_LEN;
 #endif
 
+#ifdef CONFIG_LCD
+	/* Reserve memory for LCD display (always full pages) */
+	addr = lcd_setmem(addr);
+	gd->fb_base = addr;
+#endif
+
 	/* Allocate a Board Info struct on a word boundary */
 	addr -= sizeof(bd_t);
 	addr &= ~3UL;
@@ -274,6 +300,8 @@ void board_init_r(gd_t *new_gd, ulong dest_addr)
 	gd->flags |= GD_FLG_RELOC;
 	gd->reloc_off = dest_addr - CFG_MONITOR_BASE;
 
+	board_early_init_r();
+
 	monitor_flash_len = _edata - _text;
 
 	/*
@@ -310,7 +338,6 @@ void board_init_r(gd_t *new_gd, ulong dest_addr)
 	mem_malloc_init();
 	malloc_bin_reloc();
 	dma_alloc_init();
-	board_init_info();
 
 	enable_interrupts();
 
diff --git a/lib_generic/Makefile b/lib_generic/Makefile
index 4f6ce73..bf0e31d 100644
--- a/lib_generic/Makefile
+++ b/lib_generic/Makefile
@@ -40,6 +40,7 @@ COBJS-$(CONFIG_MD5) += md5.o
 COBJS-y += sha1.o
 COBJS-$(CONFIG_SHA256) += sha256.o
 COBJS-y += string.o
+COBJS-y	+= strmhz.o
 COBJS-y += vsprintf.o
 COBJS-y += zlib.o
 
diff --git a/lib_generic/strmhz.c b/lib_generic/strmhz.c
new file mode 100644
index 0000000..d0b6bc6
--- /dev/null
+++ b/lib_generic/strmhz.c
@@ -0,0 +1,36 @@
+/*
+ * (C) Copyright 2002-2006
+ * Wolfgang Denk, DENX Software Engineering, wd@denx.de.
+ *
+ * See file CREDITS for list of people who contributed to this
+ * project.
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License as
+ * published by the Free Software Foundation; either version 2 of
+ * the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston,
+ * MA 02111-1307 USA
+ */
+#include <common.h>
+
+char *strmhz (char *buf, long hz)
+{
+	long l, n;
+	long m;
+
+	n = hz / 1000000L;
+	l = sprintf (buf, "%ld", n);
+	m = (hz % 1000000L) / 1000L;
+	if (m != 0)
+		sprintf (buf + l, ".%03ld", m);
+	return (buf);
+}
diff --git a/lib_i386/board.c b/lib_i386/board.c
index 22191e6..55fa42a 100644
--- a/lib_i386/board.c
+++ b/lib_i386/board.c
@@ -108,19 +108,6 @@ void *sbrk (ptrdiff_t increment)
 	return ((void *) old);
 }
 
-char *strmhz (char *buf, long hz)
-{
-	long l, n;
-	long m;
-
-	n = hz / 1000000L;
-	l = sprintf (buf, "%ld", n);
-	m = (hz % 1000000L) / 1000L;
-	if (m != 0)
-		sprintf (buf + l, ".%03ld", m);
-	return (buf);
-}
-
 /************************************************************************
  * Init Utilities							*
  ************************************************************************
diff --git a/lib_m68k/board.c b/lib_m68k/board.c
index a13ea26..39e8f23 100644
--- a/lib_m68k/board.c
+++ b/lib_m68k/board.c
@@ -136,23 +136,6 @@ void *sbrk (ptrdiff_t increment)
 	return ((void *)old);
 }
 
-char *strmhz(char *buf, long hz)
-{
-	long l, n;
-	long m;
-
-	n = hz / 1000000L;
-
-	l = sprintf (buf, "%ld", n);
-
-	m = (hz % 1000000L) / 1000L;
-
-	if (m != 0)
-		sprintf (buf+l, ".%03ld", m);
-
-	return (buf);
-}
-
 /*
  * All attempts to come up with a "common" initialization sequence
  * that works for all boards and architectures failed: some of the
diff --git a/lib_ppc/board.c b/lib_ppc/board.c
index 71a70db..c8f075f 100644
--- a/lib_ppc/board.c
+++ b/lib_ppc/board.c
@@ -168,19 +168,6 @@ void *sbrk (ptrdiff_t increment)
 	return ((void *) old);
 }
 
-char *strmhz (char *buf, long hz)
-{
-	long l, n;
-	long m;
-
-	n = hz / 1000000L;
-	l = sprintf (buf, "%ld", n);
-	m = (hz % 1000000L) / 1000L;
-	if (m != 0)
-		sprintf (buf + l, ".%03ld", m);
-	return (buf);
-}
-
 /*
  * All attempts to come up with a "common" initialization sequence
  * that works for all boards and architectures failed: some of the
diff --git a/net/eth.c b/net/eth.c
index 38979aa..8e83b66 100644
--- a/net/eth.c
+++ b/net/eth.c
@@ -69,9 +69,7 @@ extern int uli526x_initialize(bd_t *);
 extern int npe_initialize(bd_t *);
 extern int uec_initialize(int);
 extern int bfin_EMAC_initialize(bd_t *);
-extern int atstk1000_eth_initialize(bd_t *);
 extern int greth_initialize(bd_t *);
-extern int atngw100_eth_initialize(bd_t *);
 extern int mcffec_initialize(bd_t*);
 extern int mcdmafec_initialize(bd_t*);
 extern int at91sam9_eth_initialize(bd_t *);
@@ -271,15 +269,9 @@ int eth_initialize(bd_t *bis)
 #if defined(CONFIG_BF537)
 	bfin_EMAC_initialize(bis);
 #endif
-#if defined(CONFIG_ATSTK1000)
-	atstk1000_eth_initialize(bis);
-#endif
 #if defined(CONFIG_GRETH)
 	greth_initialize(bis);
 #endif
-#if defined(CONFIG_ATNGW100)
-	atngw100_eth_initialize(bis);
-#endif
 #if defined(CONFIG_MCFFEC)
 	mcffec_initialize(bis);
 #endif
